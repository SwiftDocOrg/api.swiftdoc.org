{"operators":[{"kind":"operator","place":"infix","name":"!=","slug":"excleq","assignment":false,"associativity":"none","precedence":"130","comment":"","functions":[{"kind":"operator func","name":"!=","slug":"excleq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=(lhs: Int, rhs: Int) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=(lhs: Int8, rhs: Int8) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=(lhs: Int16, rhs: Int16) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=(lhs: Int32, rhs: Int32) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=(lhs: Int64, rhs: Int64) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=(lhs: UInt, rhs: UInt) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=(lhs: UInt8, rhs: UInt8) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=(lhs: UInt16, rhs: UInt16) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=(lhs: UInt32, rhs: UInt32) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=(lhs: UInt64, rhs: UInt64) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{"line":"Key : Equatable, Value : Equatable","types":["Equatable","Key","Value"]},"place":"","params":[{"name":"lhs","type":"[Key : Value]","note":"","default":"","types":["Key","Value"]},{"name":"rhs","type":"[Key : Value]","note":"","default":"","types":["Key","Value"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=<Key : Equatable, Value : Equatable>(lhs: [Key : Value], rhs: [Key : Value]) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{"line":"T : Equatable","types":["Equatable"]},"place":"","params":[{"name":"lhs","type":"[T]","note":"","default":"","types":[]},{"name":"rhs","type":"[T]","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=<T : Equatable>(lhs: [T], rhs: [T]) -> Bool","comment":"Returns true if the arrays do not contain the same elements."},{"kind":"operator func","name":"!=","slug":"excleq","generic":{"line":"T : Equatable","types":["Equatable"]},"place":"","params":[{"name":"lhs","type":"ContiguousArray<T>","note":"","default":"","types":["ContiguousArray"]},{"name":"rhs","type":"ContiguousArray<T>","note":"","default":"","types":["ContiguousArray"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=<T : Equatable>(lhs: ContiguousArray<T>, rhs: ContiguousArray<T>) -> Bool","comment":"Returns true if the arrays do not contain the same elements."},{"kind":"operator func","name":"!=","slug":"excleq","generic":{"line":"T : Equatable","types":["Equatable"]},"place":"","params":[{"name":"lhs","type":"Slice<T>","note":"","default":"","types":["Slice"]},{"name":"rhs","type":"Slice<T>","note":"","default":"","types":["Slice"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=<T : Equatable>(lhs: Slice<T>, rhs: Slice<T>) -> Bool","comment":"Returns true if the arrays do not contain the same elements."},{"kind":"operator func","name":"!=","slug":"excleq","generic":{"line":"T : Equatable","types":["Equatable"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=<T : Equatable>(lhs: T, rhs: T) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{"line":"T : Equatable","types":["Equatable"]},"place":"","params":[{"name":"lhs","type":"T?","note":"","default":"","types":[]},{"name":"rhs","type":"T?","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=<T : Equatable>(lhs: T?, rhs: T?) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"_OptionalNilComparisonType","note":"","default":"","types":["_OptionalNilComparisonType"]},{"name":"rhs","type":"T?","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=<T>(lhs: _OptionalNilComparisonType, rhs: T?) -> Bool","comment":""},{"kind":"operator func","name":"!=","slug":"excleq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"T?","note":"","default":"","types":[]},{"name":"rhs","type":"_OptionalNilComparisonType","note":"","default":"","types":["_OptionalNilComparisonType"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !=<T>(lhs: T?, rhs: _OptionalNilComparisonType) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":"!==","slug":"excleqeq","assignment":false,"associativity":"none","precedence":"130","comment":"","functions":[{"kind":"operator func","name":"!==","slug":"excleqeq","generic":{},"place":"","params":[{"name":"lhs","type":"AnyObject?","note":"","default":"","types":["AnyObject"]},{"name":"rhs","type":"AnyObject?","note":"","default":"","types":["AnyObject"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func !==(lhs: AnyObject?, rhs: AnyObject?) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":"%","slug":"pct","assignment":false,"associativity":"left","precedence":"150","comment":"","functions":[{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"func %(lhs: Double, rhs: Double) -> Double","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"func %(lhs: Float, rhs: Float) -> Float","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"func %(lhs: Float80, rhs: Float80) -> Float80","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func %(lhs: Int, rhs: Int) -> Int","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"func %(lhs: Int8, rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"func %(lhs: Int16, rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"func %(lhs: Int32, rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"func %(lhs: Int64, rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"func %(lhs: UInt, rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"func %(lhs: UInt8, rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"func %(lhs: UInt16, rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"func %(lhs: UInt32, rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"func %(lhs: UInt64, rhs: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"%","slug":"pct","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func %<T : _IntegerArithmeticType>(lhs: T, rhs: T) -> T","comment":"Divide `lhs` and `rhs`, returning the remainder and trapping in case of\narithmetic overflow (except in -Ounchecked builds)."}]},{"kind":"operator","place":"infix","name":"%=","slug":"pcteq","assignment":true,"associativity":"right","precedence":"90","comment":"","functions":[{"kind":"operator func","name":"%=","slug":"pcteq","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"inout","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{},"attr":"","line":"func %=(inout lhs: Double, rhs: Double)","comment":""},{"kind":"operator func","name":"%=","slug":"pcteq","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"inout","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{},"attr":"","line":"func %=(inout lhs: Float, rhs: Float)","comment":""},{"kind":"operator func","name":"%=","slug":"pcteq","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"inout","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{},"attr":"","line":"func %=(inout lhs: Float80, rhs: Float80)","comment":""},{"kind":"operator func","name":"%=","slug":"pcteq","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"inout","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func %=<T : _IntegerArithmeticType>(inout lhs: T, rhs: T)","comment":"remainder `lhs` and `rhs` and store the result in `lhs`, trapping in\ncase of arithmetic overflow (except in -Ounchecked builds)."}]},{"kind":"operator","place":"infix","name":"&","slug":"amp","assignment":false,"associativity":"left","precedence":"150","comment":"","functions":[{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"Bool","note":"","default":"","types":["Bool"]},{"name":"rhs","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func &(lhs: Bool, rhs: Bool) -> Bool","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func &(lhs: Int, rhs: Int) -> Int","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"func &(lhs: Int8, rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"func &(lhs: Int16, rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"func &(lhs: Int32, rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"func &(lhs: Int64, rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"func &(lhs: UInt, rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"func &(lhs: UInt8, rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"func &(lhs: UInt16, rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"func &(lhs: UInt32, rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"func &(lhs: UInt64, rhs: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"&","slug":"amp","generic":{"line":"T : _RawOptionSetType","types":["_RawOptionSetType"]},"place":"","params":[{"name":"a","type":"T","note":"","default":"","types":[]},{"name":"b","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func &<T : _RawOptionSetType>(a: T, b: T) -> T","comment":""}]},{"kind":"operator","place":"infix","name":"&%","slug":"amppct","assignment":false,"associativity":"left","precedence":"150","comment":"","functions":[{"kind":"operator func","name":"&%","slug":"amppct","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func &%<T : _IntegerArithmeticType>(lhs: T, rhs: T) -> T","comment":"remainder `lhs` and `rhs`, silently discarding any overflow."}]},{"kind":"operator","place":"infix","name":"&&","slug":"ampamp","assignment":false,"associativity":"left","precedence":"120","comment":"","functions":[{"kind":"operator func","name":"&&","slug":"ampamp","generic":{"line":"T : BooleanType, U : BooleanType","types":["BooleanType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"@autoclosure () -> U","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"@inline(__always) ","line":"func &&<T : BooleanType, U : BooleanType>(lhs: T, rhs: @autoclosure () -> U) -> Bool","comment":"If `lhs` is `false`, return it.  Otherwise, evaluate `rhs` and\nreturn its `boolValue`."},{"kind":"operator func","name":"&&","slug":"ampamp","generic":{"line":"T : BooleanType","types":["BooleanType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"@autoclosure () -> Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func &&<T : BooleanType>(lhs: T, rhs: @autoclosure () -> Bool) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":"&*","slug":"ampstar","assignment":false,"associativity":"left","precedence":"150","comment":"","functions":[{"kind":"operator func","name":"&*","slug":"ampstar","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func &*<T : _IntegerArithmeticType>(lhs: T, rhs: T) -> T","comment":"multiply `lhs` and `rhs`, silently discarding any overflow."}]},{"kind":"operator","place":"infix","name":"&+","slug":"amppls","assignment":false,"associativity":"left","precedence":"140","comment":"","functions":[{"kind":"operator func","name":"&+","slug":"amppls","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func &+<T : _IntegerArithmeticType>(lhs: T, rhs: T) -> T","comment":"add `lhs` and `rhs`, silently discarding any overflow."}]},{"kind":"operator","place":"infix","name":"&-","slug":"ampmns","assignment":false,"associativity":"left","precedence":"140","comment":"","functions":[{"kind":"operator func","name":"&-","slug":"ampmns","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func &-<T : _IntegerArithmeticType>(lhs: T, rhs: T) -> T","comment":"subtract `lhs` and `rhs`, silently discarding any overflow."}]},{"kind":"operator","place":"infix","name":"&/","slug":"ampslash","assignment":false,"associativity":"left","precedence":"150","comment":"","functions":[{"kind":"operator func","name":"&/","slug":"ampslash","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func &/<T : _IntegerArithmeticType>(lhs: T, rhs: T) -> T","comment":"divide `lhs` and `rhs`, silently discarding any overflow."}]},{"kind":"operator","place":"infix","name":"&=","slug":"ampeq","assignment":true,"associativity":"right","precedence":"90","comment":"","functions":[{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"Bool","note":"inout","default":"","types":["Bool"]},{"name":"rhs","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{},"attr":"","line":"func &=(inout lhs: Bool, rhs: Bool)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"inout","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func &=(inout lhs: Int, rhs: Int)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"inout","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{},"attr":"","line":"func &=(inout lhs: Int8, rhs: Int8)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"inout","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{},"attr":"","line":"func &=(inout lhs: Int16, rhs: Int16)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"inout","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{},"attr":"","line":"func &=(inout lhs: Int32, rhs: Int32)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"inout","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{},"attr":"","line":"func &=(inout lhs: Int64, rhs: Int64)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"inout","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{},"attr":"","line":"func &=(inout lhs: UInt, rhs: UInt)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"inout","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{},"attr":"","line":"func &=(inout lhs: UInt8, rhs: UInt8)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"inout","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{},"attr":"","line":"func &=(inout lhs: UInt16, rhs: UInt16)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"inout","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{},"attr":"","line":"func &=(inout lhs: UInt32, rhs: UInt32)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"inout","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{},"attr":"","line":"func &=(inout lhs: UInt64, rhs: UInt64)","comment":""},{"kind":"operator func","name":"&=","slug":"ampeq","generic":{"line":"T : BitwiseOperationsType","types":["BitwiseOperationsType"]},"place":"","params":[{"name":"lhs","type":"T","note":"inout","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func &=<T : BitwiseOperationsType>(inout lhs: T, rhs: T)","comment":""}]},{"kind":"operator","place":"infix","name":"*","slug":"star","assignment":false,"associativity":"left","precedence":"150","comment":"","functions":[{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"func *(lhs: Double, rhs: Double) -> Double","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"func *(lhs: Float, rhs: Float) -> Float","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"func *(lhs: Float80, rhs: Float80) -> Float80","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func *(lhs: Int, rhs: Int) -> Int","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"func *(lhs: Int8, rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"func *(lhs: Int16, rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"func *(lhs: Int32, rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"func *(lhs: Int64, rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"func *(lhs: UInt, rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"func *(lhs: UInt8, rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"func *(lhs: UInt16, rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"func *(lhs: UInt32, rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"func *(lhs: UInt64, rhs: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"*","slug":"star","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func *<T : _IntegerArithmeticType>(lhs: T, rhs: T) -> T","comment":"Multiply `lhs` and `rhs`, returning a result and trapping in case of\narithmetic overflow (except in -Ounchecked builds)."}]},{"kind":"operator","place":"infix","name":"*=","slug":"stareq","assignment":true,"associativity":"right","precedence":"90","comment":"","functions":[{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"inout","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{},"attr":"","line":"func *=(inout lhs: Double, rhs: Double)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"inout","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{},"attr":"","line":"func *=(inout lhs: Float, rhs: Float)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"inout","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{},"attr":"","line":"func *=(inout lhs: Float80, rhs: Float80)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"inout","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func *=(inout lhs: Int, rhs: Int)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"inout","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{},"attr":"","line":"func *=(inout lhs: Int8, rhs: Int8)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"inout","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{},"attr":"","line":"func *=(inout lhs: Int16, rhs: Int16)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"inout","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{},"attr":"","line":"func *=(inout lhs: Int32, rhs: Int32)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"inout","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{},"attr":"","line":"func *=(inout lhs: Int64, rhs: Int64)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"inout","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{},"attr":"","line":"func *=(inout lhs: UInt, rhs: UInt)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"inout","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{},"attr":"","line":"func *=(inout lhs: UInt8, rhs: UInt8)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"inout","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{},"attr":"","line":"func *=(inout lhs: UInt16, rhs: UInt16)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"inout","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{},"attr":"","line":"func *=(inout lhs: UInt32, rhs: UInt32)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"inout","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{},"attr":"","line":"func *=(inout lhs: UInt64, rhs: UInt64)","comment":""},{"kind":"operator func","name":"*=","slug":"stareq","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"inout","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func *=<T : _IntegerArithmeticType>(inout lhs: T, rhs: T)","comment":"multiply `lhs` and `rhs` and store the result in `lhs`, trapping in\ncase of arithmetic overflow (except in -Ounchecked builds)."}]},{"kind":"operator","place":"infix","name":"+","slug":"pls","assignment":false,"associativity":"left","precedence":"140","comment":"","functions":[{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"func +(lhs: Double, rhs: Double) -> Double","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"func +(lhs: Float, rhs: Float) -> Float","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"func +(lhs: Float80, rhs: Float80) -> Float80","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func +(lhs: Int, rhs: Int) -> Int","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"func +(lhs: Int8, rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"func +(lhs: Int16, rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"func +(lhs: Int32, rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"func +(lhs: Int64, rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"String","note":"","default":"","types":["String"]},{"name":"rhs","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"String","types":["String"]},"attr":"","line":"func +(lhs: String, rhs: String) -> String","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"func +(lhs: UInt, rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"func +(lhs: UInt8, rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"func +(lhs: UInt16, rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"func +(lhs: UInt32, rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"func +(lhs: UInt64, rhs: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"C : _ExtensibleCollectionType, S : CollectionType where S.Generator.Element == S.Generator.Element","types":["CollectionType","Element","Generator","_ExtensibleCollectionType"]},"place":"","params":[{"name":"lhs","type":"C","note":"","default":"","types":[]},{"name":"rhs","type":"S","note":"","default":"","types":[]}],"ret":{"line":"C","types":[]},"attr":"","line":"func +<C : _ExtensibleCollectionType, S : CollectionType where S.Generator.Element == S.Generator.Element>(lhs: C, rhs: S) -> C","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"C : _ExtensibleCollectionType, S : SequenceType where S.Generator.Element == S.Generator.Element","types":["Element","Generator","SequenceType","_ExtensibleCollectionType"]},"place":"","params":[{"name":"lhs","type":"C","note":"","default":"","types":[]},{"name":"rhs","type":"S","note":"","default":"","types":[]}],"ret":{"line":"C","types":[]},"attr":"","line":"func +<C : _ExtensibleCollectionType, S : SequenceType where S.Generator.Element == S.Generator.Element>(lhs: C, rhs: S) -> C","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"C : _ExtensibleCollectionType, S : SequenceType where S.Generator.Element == S.Generator.Element","types":["Element","Generator","SequenceType","_ExtensibleCollectionType"]},"place":"","params":[{"name":"lhs","type":"S","note":"","default":"","types":[]},{"name":"rhs","type":"C","note":"","default":"","types":[]}],"ret":{"line":"C","types":[]},"attr":"","line":"func +<C : _ExtensibleCollectionType, S : SequenceType where S.Generator.Element == S.Generator.Element>(lhs: S, rhs: C) -> C","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"EC1 : _ExtensibleCollectionType, EC2 : _ExtensibleCollectionType where EC1.Generator.Element == EC1.Generator.Element","types":["EC1","EC2","Element","Generator","_ExtensibleCollectionType"]},"place":"","params":[{"name":"lhs","type":"EC1","note":"","default":"","types":["EC1"]},{"name":"rhs","type":"EC2","note":"","default":"","types":["EC2"]}],"ret":{"line":"EC1","types":["EC1"]},"attr":"","line":"func +<EC1 : _ExtensibleCollectionType, EC2 : _ExtensibleCollectionType where EC1.Generator.Element == EC1.Generator.Element>(lhs: EC1, rhs: EC2) -> EC1","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func +<T : _IntegerArithmeticType>(lhs: T, rhs: T) -> T","comment":"Add `lhs` and `rhs`, returning a result and trapping in case of\narithmetic overflow (except in -Ounchecked builds)."},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"T : Strideable","types":["Strideable"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T.Stride","note":"","default":"","types":["Stride"]}],"ret":{"line":"T","types":[]},"attr":"","line":"func +<T : Strideable>(lhs: T, rhs: T.Stride) -> T","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"T : Strideable","types":["Strideable"]},"place":"","params":[{"name":"lhs","type":"T.Stride","note":"","default":"","types":["Stride"]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func +<T : Strideable>(lhs: T.Stride, rhs: T) -> T","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]}],"ret":{"line":"UnsafeMutablePointer<T>","types":["UnsafeMutablePointer"]},"attr":"","line":"func +<T>(lhs: Int, rhs: UnsafeMutablePointer<T>) -> UnsafeMutablePointer<T>","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]}],"ret":{"line":"UnsafePointer<T>","types":["UnsafePointer"]},"attr":"","line":"func +<T>(lhs: Int, rhs: UnsafePointer<T>) -> UnsafePointer<T>","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"UnsafeMutablePointer<T>","types":["UnsafeMutablePointer"]},"attr":"","line":"func +<T>(lhs: UnsafeMutablePointer<T>, rhs: Int) -> UnsafeMutablePointer<T>","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"UnsafePointer<T>","types":["UnsafePointer"]},"attr":"","line":"func +<T>(lhs: UnsafePointer<T>, rhs: Int) -> UnsafePointer<T>","comment":""}]},{"kind":"operator","place":"infix","name":"+=","slug":"plseq","assignment":true,"associativity":"right","precedence":"90","comment":"","functions":[{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"inout","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{},"attr":"","line":"func +=(inout lhs: Double, rhs: Double)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"inout","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{},"attr":"","line":"func +=(inout lhs: Float, rhs: Float)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"inout","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{},"attr":"","line":"func +=(inout lhs: Float80, rhs: Float80)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"inout","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func +=(inout lhs: Int, rhs: Int)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"inout","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{},"attr":"","line":"func +=(inout lhs: Int8, rhs: Int8)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"inout","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{},"attr":"","line":"func +=(inout lhs: Int16, rhs: Int16)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"inout","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{},"attr":"","line":"func +=(inout lhs: Int32, rhs: Int32)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"inout","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{},"attr":"","line":"func +=(inout lhs: Int64, rhs: Int64)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"String","note":"inout","default":"","types":["String"]},{"name":"rhs","type":"String","note":"","default":"","types":["String"]}],"ret":{},"attr":"","line":"func +=(inout lhs: String, rhs: String)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"inout","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{},"attr":"","line":"func +=(inout lhs: UInt, rhs: UInt)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"inout","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{},"attr":"","line":"func +=(inout lhs: UInt8, rhs: UInt8)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"inout","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{},"attr":"","line":"func +=(inout lhs: UInt16, rhs: UInt16)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"inout","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{},"attr":"","line":"func +=(inout lhs: UInt32, rhs: UInt32)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"inout","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{},"attr":"","line":"func +=(inout lhs: UInt64, rhs: UInt64)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"inout","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func +=<T : _IntegerArithmeticType>(inout lhs: T, rhs: T)","comment":"add `lhs` and `rhs` and store the result in `lhs`, trapping in\ncase of arithmetic overflow (except in -Ounchecked builds)."},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T : Strideable","types":["Strideable"]},"place":"","params":[{"name":"lhs","type":"T","note":"inout","default":"","types":[]},{"name":"rhs","type":"T.Stride","note":"","default":"","types":["Stride"]}],"ret":{},"attr":"","line":"func +=<T : Strideable>(inout lhs: T, rhs: T.Stride)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T, C : CollectionType where T == T","types":["CollectionType"]},"place":"","params":[{"name":"lhs","type":"[T]","note":"inout","default":"","types":[]},{"name":"rhs","type":"C","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func +=<T, C : CollectionType where T == T>(inout lhs: [T], rhs: C)","comment":"Extend `lhs` with the elements of `rhs`"},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T, C : CollectionType where T == T","types":["CollectionType"]},"place":"","params":[{"name":"lhs","type":"_ContiguousArrayBuffer<T>","note":"inout","default":"","types":["_ContiguousArrayBuffer"]},{"name":"rhs","type":"C","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func +=<T, C : CollectionType where T == T>(inout lhs: _ContiguousArrayBuffer<T>, rhs: C)","comment":"Append the elements of rhs to lhs"},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T, C : CollectionType where T == T","types":["CollectionType"]},"place":"","params":[{"name":"lhs","type":"ContiguousArray<T>","note":"inout","default":"","types":["ContiguousArray"]},{"name":"rhs","type":"C","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func +=<T, C : CollectionType where T == T>(inout lhs: ContiguousArray<T>, rhs: C)","comment":"Extend `lhs` with the elements of `rhs`"},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T, C : CollectionType where T == T","types":["CollectionType"]},"place":"","params":[{"name":"lhs","type":"Slice<T>","note":"inout","default":"","types":["Slice"]},{"name":"rhs","type":"C","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func +=<T, C : CollectionType where T == T>(inout lhs: Slice<T>, rhs: C)","comment":"Extend `lhs` with the elements of `rhs`"},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T, S : SequenceType where T == T","types":["SequenceType"]},"place":"","params":[{"name":"lhs","type":"[T]","note":"inout","default":"","types":[]},{"name":"rhs","type":"S","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func +=<T, S : SequenceType where T == T>(inout lhs: [T], rhs: S)","comment":"Extend `lhs` with the elements of `rhs`"},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T, S : SequenceType where T == T","types":["SequenceType"]},"place":"","params":[{"name":"lhs","type":"ContiguousArray<T>","note":"inout","default":"","types":["ContiguousArray"]},{"name":"rhs","type":"S","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func +=<T, S : SequenceType where T == T>(inout lhs: ContiguousArray<T>, rhs: S)","comment":"Extend `lhs` with the elements of `rhs`"},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T, S : SequenceType where T == T","types":["SequenceType"]},"place":"","params":[{"name":"lhs","type":"Slice<T>","note":"inout","default":"","types":["Slice"]},{"name":"rhs","type":"S","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func +=<T, S : SequenceType where T == T>(inout lhs: Slice<T>, rhs: S)","comment":"Extend `lhs` with the elements of `rhs`"},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"_ContiguousArrayBuffer<T>","note":"inout","default":"","types":["_ContiguousArrayBuffer"]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func +=<T>(inout lhs: _ContiguousArrayBuffer<T>, rhs: T)","comment":"Append rhs to lhs"},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafeMutablePointer<T>","note":"inout","default":"","types":["UnsafeMutablePointer"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func +=<T>(inout lhs: UnsafeMutablePointer<T>, rhs: Int)","comment":""},{"kind":"operator func","name":"+=","slug":"plseq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafePointer<T>","note":"inout","default":"","types":["UnsafePointer"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func +=<T>(inout lhs: UnsafePointer<T>, rhs: Int)","comment":""}]},{"kind":"operator","place":"infix","name":"-","slug":"mns","assignment":false,"associativity":"left","precedence":"140","comment":"","functions":[{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"func -(lhs: Double, rhs: Double) -> Double","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"func -(lhs: Float, rhs: Float) -> Float","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"func -(lhs: Float80, rhs: Float80) -> Float80","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func -(lhs: Int, rhs: Int) -> Int","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"func -(lhs: Int8, rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"func -(lhs: Int16, rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"func -(lhs: Int32, rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"func -(lhs: Int64, rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"func -(lhs: UInt, rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"func -(lhs: UInt8, rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"func -(lhs: UInt16, rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"func -(lhs: UInt32, rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"func -(lhs: UInt64, rhs: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func -<T : _IntegerArithmeticType>(lhs: T, rhs: T) -> T","comment":"Subtract `lhs` and `rhs`, returning a result and trapping in case of\narithmetic overflow (except in -Ounchecked builds)."},{"kind":"operator func","name":"-","slug":"mns","generic":{"line":"T : Strideable","types":["Strideable"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T.Stride","types":["Stride"]},"attr":"","line":"func -<T : Strideable>(lhs: T, rhs: T) -> T.Stride","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{"line":"T : Strideable","types":["Strideable"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T.Stride","note":"","default":"","types":["Stride"]}],"ret":{"line":"T","types":[]},"attr":"","line":"func -<T : Strideable>(lhs: T, rhs: T.Stride) -> T","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"UnsafeMutablePointer<T>","types":["UnsafeMutablePointer"]},"attr":"","line":"func -<T>(lhs: UnsafeMutablePointer<T>, rhs: Int) -> UnsafeMutablePointer<T>","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"rhs","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func -<T>(lhs: UnsafeMutablePointer<T>, rhs: UnsafeMutablePointer<T>) -> Int","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"UnsafePointer<T>","types":["UnsafePointer"]},"attr":"","line":"func -<T>(lhs: UnsafePointer<T>, rhs: Int) -> UnsafePointer<T>","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]},{"name":"rhs","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func -<T>(lhs: UnsafePointer<T>, rhs: UnsafePointer<T>) -> Int","comment":""}]},{"kind":"operator","place":"infix","name":"-=","slug":"mnseq","assignment":true,"associativity":"right","precedence":"90","comment":"","functions":[{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"inout","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{},"attr":"","line":"func -=(inout lhs: Double, rhs: Double)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"inout","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{},"attr":"","line":"func -=(inout lhs: Float, rhs: Float)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"inout","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{},"attr":"","line":"func -=(inout lhs: Float80, rhs: Float80)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"inout","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func -=(inout lhs: Int, rhs: Int)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"inout","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{},"attr":"","line":"func -=(inout lhs: Int8, rhs: Int8)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"inout","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{},"attr":"","line":"func -=(inout lhs: Int16, rhs: Int16)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"inout","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{},"attr":"","line":"func -=(inout lhs: Int32, rhs: Int32)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"inout","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{},"attr":"","line":"func -=(inout lhs: Int64, rhs: Int64)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"inout","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{},"attr":"","line":"func -=(inout lhs: UInt, rhs: UInt)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"inout","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{},"attr":"","line":"func -=(inout lhs: UInt8, rhs: UInt8)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"inout","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{},"attr":"","line":"func -=(inout lhs: UInt16, rhs: UInt16)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"inout","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{},"attr":"","line":"func -=(inout lhs: UInt32, rhs: UInt32)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"inout","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{},"attr":"","line":"func -=(inout lhs: UInt64, rhs: UInt64)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"inout","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func -=<T : _IntegerArithmeticType>(inout lhs: T, rhs: T)","comment":"subtract `lhs` and `rhs` and store the result in `lhs`, trapping in\ncase of arithmetic overflow (except in -Ounchecked builds)."},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{"line":"T : Strideable","types":["Strideable"]},"place":"","params":[{"name":"lhs","type":"T","note":"inout","default":"","types":[]},{"name":"rhs","type":"T.Stride","note":"","default":"","types":["Stride"]}],"ret":{},"attr":"","line":"func -=<T : Strideable>(inout lhs: T, rhs: T.Stride)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafeMutablePointer<T>","note":"inout","default":"","types":["UnsafeMutablePointer"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func -=<T>(inout lhs: UnsafeMutablePointer<T>, rhs: Int)","comment":""},{"kind":"operator func","name":"-=","slug":"mnseq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafePointer<T>","note":"inout","default":"","types":["UnsafePointer"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func -=<T>(inout lhs: UnsafePointer<T>, rhs: Int)","comment":""}]},{"kind":"operator","place":"infix","name":"...","slug":"dotdotdot","assignment":false,"associativity":"none","precedence":"135","comment":"","functions":[{"kind":"operator func","name":"...","slug":"dotdotdot","generic":{"line":"Pos : ForwardIndexType where Pos : Comparable","types":["Comparable","ForwardIndexType","Pos"]},"place":"","params":[{"name":"start","type":"Pos","note":"","default":"","types":["Pos"]},{"name":"end","type":"Pos","note":"","default":"","types":["Pos"]}],"ret":{"line":"Range<Pos>","types":["Pos","Range"]},"attr":"","line":"func ...<Pos : ForwardIndexType where Pos : Comparable>(start: Pos, end: Pos) -> Range<Pos>","comment":"Forms a closed range that contains both `start` and `end`.\nRequres: `start <= end`"},{"kind":"operator func","name":"...","slug":"dotdotdot","generic":{"line":"Pos : ForwardIndexType","types":["ForwardIndexType","Pos"]},"place":"","params":[{"name":"minimum","type":"Pos","note":"","default":"","types":["Pos"]},{"name":"maximum","type":"Pos","note":"","default":"","types":["Pos"]}],"ret":{"line":"Range<Pos>","types":["Pos","Range"]},"attr":"","line":"func ...<Pos : ForwardIndexType>(minimum: Pos, maximum: Pos) -> Range<Pos>","comment":"Forms a closed range that contains both `minimum` and `maximum`."},{"kind":"operator func","name":"...","slug":"dotdotdot","generic":{"line":"T : Comparable","types":["Comparable"]},"place":"","params":[{"name":"start","type":"T","note":"","default":"","types":[]},{"name":"end","type":"T","note":"","default":"","types":[]}],"ret":{"line":"ClosedInterval<T>","types":["ClosedInterval"]},"attr":"","line":"func ...<T : Comparable>(start: T, end: T) -> ClosedInterval<T>","comment":"Returns a closed interval from `start` through `end`"}]},{"kind":"operator","place":"infix","name":"..<","slug":"dotdotlt","assignment":false,"associativity":"none","precedence":"135","comment":"","functions":[{"kind":"operator func","name":"..<","slug":"dotdotlt","generic":{"line":"Pos : ForwardIndexType where Pos : Comparable","types":["Comparable","ForwardIndexType","Pos"]},"place":"","params":[{"name":"start","type":"Pos","note":"","default":"","types":["Pos"]},{"name":"end","type":"Pos","note":"","default":"","types":["Pos"]}],"ret":{"line":"Range<Pos>","types":["Pos","Range"]},"attr":"","line":"func ..<<Pos : ForwardIndexType where Pos : Comparable>(start: Pos, end: Pos) -> Range<Pos>","comment":"Forms a half-open range that contains `start`, but not\n`end`.  Requires: `start <= end`"},{"kind":"operator func","name":"..<","slug":"dotdotlt","generic":{"line":"Pos : ForwardIndexType","types":["ForwardIndexType","Pos"]},"place":"","params":[{"name":"minimum","type":"Pos","note":"","default":"","types":["Pos"]},{"name":"maximum","type":"Pos","note":"","default":"","types":["Pos"]}],"ret":{"line":"Range<Pos>","types":["Pos","Range"]},"attr":"","line":"func ..<<Pos : ForwardIndexType>(minimum: Pos, maximum: Pos) -> Range<Pos>","comment":"Forms a half-open range that contains `minimum`, but not\n`maximum`."},{"kind":"operator func","name":"..<","slug":"dotdotlt","generic":{"line":"T : Comparable","types":["Comparable"]},"place":"","params":[{"name":"start","type":"T","note":"","default":"","types":[]},{"name":"end","type":"T","note":"","default":"","types":[]}],"ret":{"line":"HalfOpenInterval<T>","types":["HalfOpenInterval"]},"attr":"","line":"func ..<<T : Comparable>(start: T, end: T) -> HalfOpenInterval<T>","comment":"Returns a half-open interval from `start` to `end`"}]},{"kind":"operator","place":"infix","name":"/","slug":"slash","assignment":false,"associativity":"left","precedence":"150","comment":"","functions":[{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"func /(lhs: Double, rhs: Double) -> Double","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"func /(lhs: Float, rhs: Float) -> Float","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"func /(lhs: Float80, rhs: Float80) -> Float80","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func /(lhs: Int, rhs: Int) -> Int","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"func /(lhs: Int8, rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"func /(lhs: Int16, rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"func /(lhs: Int32, rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"func /(lhs: Int64, rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"func /(lhs: UInt, rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"func /(lhs: UInt8, rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"func /(lhs: UInt16, rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"func /(lhs: UInt32, rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"func /(lhs: UInt64, rhs: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"/","slug":"slash","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func /<T : _IntegerArithmeticType>(lhs: T, rhs: T) -> T","comment":"Divide `lhs` and `rhs`, returning a result and trapping in case of\narithmetic overflow (except in -Ounchecked builds)."}]},{"kind":"operator","place":"infix","name":"/=","slug":"slasheq","assignment":true,"associativity":"right","precedence":"90","comment":"","functions":[{"kind":"operator func","name":"/=","slug":"slasheq","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"inout","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{},"attr":"","line":"func /=(inout lhs: Double, rhs: Double)","comment":""},{"kind":"operator func","name":"/=","slug":"slasheq","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"inout","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{},"attr":"","line":"func /=(inout lhs: Float, rhs: Float)","comment":""},{"kind":"operator func","name":"/=","slug":"slasheq","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"inout","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{},"attr":"","line":"func /=(inout lhs: Float80, rhs: Float80)","comment":""},{"kind":"operator func","name":"/=","slug":"slasheq","generic":{"line":"T : _IntegerArithmeticType","types":["_IntegerArithmeticType"]},"place":"","params":[{"name":"lhs","type":"T","note":"inout","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func /=<T : _IntegerArithmeticType>(inout lhs: T, rhs: T)","comment":"divide `lhs` and `rhs` and store the result in `lhs`, trapping in\ncase of arithmetic overflow (except in -Ounchecked builds)."}]},{"kind":"operator","place":"infix","name":"<","slug":"lt","assignment":false,"associativity":"none","precedence":"130","comment":"","functions":[{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Bit","note":"","default":"","types":["Bit"]},{"name":"rhs","type":"Bit","note":"","default":"","types":["Bit"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Bit, rhs: Bit) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Character","note":"","default":"","types":["Character"]},{"name":"rhs","type":"Character","note":"","default":"","types":["Character"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Character, rhs: Character) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Double, rhs: Double) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Float, rhs: Float) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Float80, rhs: Float80) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Int, rhs: Int) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Int8, rhs: Int8) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Int16, rhs: Int16) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Int32, rhs: Int32) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Int64, rhs: Int64) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"String","note":"","default":"","types":["String"]},{"name":"rhs","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: String, rhs: String) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"String.Index","note":"","default":"","types":["Index","String"]},{"name":"rhs","type":"String.Index","note":"","default":"","types":["Index","String"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: String.Index, rhs: String.Index) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"String.UnicodeScalarView.Index","note":"","default":"","types":["Index","String","UnicodeScalarView"]},{"name":"rhs","type":"String.UnicodeScalarView.Index","note":"","default":"","types":["Index","String","UnicodeScalarView"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: String.UnicodeScalarView.Index, rhs: String.UnicodeScalarView.Index) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: UInt, rhs: UInt) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: UInt8, rhs: UInt8) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: UInt16, rhs: UInt16) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: UInt32, rhs: UInt32) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: UInt64, rhs: UInt64) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]},{"name":"rhs","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: UnicodeScalar, rhs: UnicodeScalar) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{"line":"Key : Hashable, Value","types":["Hashable","Key","Value"]},"place":"","params":[{"name":"lhs","type":"DictionaryIndex<Key, Value>","note":"","default":"","types":["DictionaryIndex","Key","Value"]},{"name":"rhs","type":"DictionaryIndex<Key, Value>","note":"","default":"","types":["DictionaryIndex","Key","Value"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <<Key : Hashable, Value>(lhs: DictionaryIndex<Key, Value>, rhs: DictionaryIndex<Key, Value>) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{"line":"T : _Comparable","types":["_Comparable"]},"place":"","params":[{"name":"lhs","type":"T?","note":"","default":"","types":[]},{"name":"rhs","type":"T?","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <<T : _Comparable>(lhs: T?, rhs: T?) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{"line":"T : _Strideable","types":["_Strideable"]},"place":"","params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"y","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <<T : _Strideable>(x: T, y: T) -> Bool","comment":"Compare two Strideables"},{"kind":"operator func","name":"<","slug":"lt","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"rhs","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <<T>(lhs: UnsafeMutablePointer<T>, rhs: UnsafeMutablePointer<T>) -> Bool","comment":""},{"kind":"operator func","name":"<","slug":"lt","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]},{"name":"rhs","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <<T>(lhs: UnsafePointer<T>, rhs: UnsafePointer<T>) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":"<<","slug":"ltlt","assignment":false,"associativity":"none","precedence":"160","comment":"","functions":[{"kind":"operator func","name":"<<","slug":"ltlt","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func <<(lhs: Int, rhs: Int) -> Int","comment":""},{"kind":"operator func","name":"<<","slug":"ltlt","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"func <<(lhs: Int8, rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":"<<","slug":"ltlt","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"func <<(lhs: Int16, rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":"<<","slug":"ltlt","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"func <<(lhs: Int32, rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":"<<","slug":"ltlt","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"func <<(lhs: Int64, rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":"<<","slug":"ltlt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"func <<(lhs: UInt, rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":"<<","slug":"ltlt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"func <<(lhs: UInt8, rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"<<","slug":"ltlt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"func <<(lhs: UInt16, rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"<<","slug":"ltlt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"func <<(lhs: UInt32, rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"<<","slug":"ltlt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"func <<(lhs: UInt64, rhs: UInt64) -> UInt64","comment":""}]},{"kind":"operator","place":"infix","name":"<<=","slug":"ltlteq","assignment":true,"associativity":"right","precedence":"90","comment":"","functions":[{"kind":"operator func","name":"<<=","slug":"ltlteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"inout","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func <<=(inout lhs: Int, rhs: Int)","comment":""},{"kind":"operator func","name":"<<=","slug":"ltlteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"inout","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{},"attr":"","line":"func <<=(inout lhs: Int8, rhs: Int8)","comment":""},{"kind":"operator func","name":"<<=","slug":"ltlteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"inout","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{},"attr":"","line":"func <<=(inout lhs: Int16, rhs: Int16)","comment":""},{"kind":"operator func","name":"<<=","slug":"ltlteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"inout","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{},"attr":"","line":"func <<=(inout lhs: Int32, rhs: Int32)","comment":""},{"kind":"operator func","name":"<<=","slug":"ltlteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"inout","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{},"attr":"","line":"func <<=(inout lhs: Int64, rhs: Int64)","comment":""},{"kind":"operator func","name":"<<=","slug":"ltlteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"inout","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{},"attr":"","line":"func <<=(inout lhs: UInt, rhs: UInt)","comment":""},{"kind":"operator func","name":"<<=","slug":"ltlteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"inout","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{},"attr":"","line":"func <<=(inout lhs: UInt8, rhs: UInt8)","comment":""},{"kind":"operator func","name":"<<=","slug":"ltlteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"inout","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{},"attr":"","line":"func <<=(inout lhs: UInt16, rhs: UInt16)","comment":""},{"kind":"operator func","name":"<<=","slug":"ltlteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"inout","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{},"attr":"","line":"func <<=(inout lhs: UInt32, rhs: UInt32)","comment":""},{"kind":"operator func","name":"<<=","slug":"ltlteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"inout","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{},"attr":"","line":"func <<=(inout lhs: UInt64, rhs: UInt64)","comment":""}]},{"kind":"operator","place":"infix","name":"<=","slug":"lteq","assignment":false,"associativity":"none","precedence":"130","comment":"","functions":[{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: Int, rhs: Int) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: Int8, rhs: Int8) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: Int16, rhs: Int16) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: Int32, rhs: Int32) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: Int64, rhs: Int64) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: UInt, rhs: UInt) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: UInt8, rhs: UInt8) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: UInt16, rhs: UInt16) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: UInt32, rhs: UInt32) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: UInt64, rhs: UInt64) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{"line":"T : _Comparable","types":["_Comparable"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=<T : _Comparable>(lhs: T, rhs: T) -> Bool","comment":""},{"kind":"operator func","name":"<=","slug":"lteq","generic":{"line":"T : _Comparable","types":["_Comparable"]},"place":"","params":[{"name":"lhs","type":"T?","note":"","default":"","types":[]},{"name":"rhs","type":"T?","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=<T : _Comparable>(lhs: T?, rhs: T?) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":"==","slug":"eqeq","assignment":false,"associativity":"none","precedence":"130","comment":"","functions":[{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Bit","note":"","default":"","types":["Bit"]},{"name":"rhs","type":"Bit","note":"","default":"","types":["Bit"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Bit, rhs: Bit) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Bool","note":"","default":"","types":["Bool"]},{"name":"rhs","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Bool, rhs: Bool) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"COpaquePointer","note":"","default":"","types":["COpaquePointer"]},{"name":"rhs","type":"COpaquePointer","note":"","default":"","types":["COpaquePointer"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: COpaquePointer, rhs: COpaquePointer) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Character","note":"","default":"","types":["Character"]},{"name":"rhs","type":"Character","note":"","default":"","types":["Character"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Character, rhs: Character) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Double","note":"","default":"","types":["Double"]},{"name":"rhs","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Double, rhs: Double) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Float","note":"","default":"","types":["Float"]},{"name":"rhs","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Float, rhs: Float) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Float80","note":"","default":"","types":["Float80"]},{"name":"rhs","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Float80, rhs: Float80) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"FloatingPointClassification","note":"","default":"","types":["FloatingPointClassification"]},{"name":"rhs","type":"FloatingPointClassification","note":"","default":"","types":["FloatingPointClassification"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: FloatingPointClassification, rhs: FloatingPointClassification) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Int, rhs: Int) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Int8, rhs: Int8) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Int16, rhs: Int16) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Int32, rhs: Int32) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Int64, rhs: Int64) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"String","note":"","default":"","types":["String"]},{"name":"rhs","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: String, rhs: String) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"String.Index","note":"","default":"","types":["Index","String"]},{"name":"rhs","type":"String.Index","note":"","default":"","types":["Index","String"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: String.Index, rhs: String.Index) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"String.UTF8View.Index","note":"","default":"","types":["Index","String","UTF8View"]},{"name":"rhs","type":"String.UTF8View.Index","note":"","default":"","types":["Index","String","UTF8View"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: String.UTF8View.Index, rhs: String.UTF8View.Index) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"String.UnicodeScalarView.Index","note":"","default":"","types":["Index","String","UnicodeScalarView"]},{"name":"rhs","type":"String.UnicodeScalarView.Index","note":"","default":"","types":["Index","String","UnicodeScalarView"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: String.UnicodeScalarView.Index, rhs: String.UnicodeScalarView.Index) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: UInt, rhs: UInt) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: UInt8, rhs: UInt8) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: UInt16, rhs: UInt16) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: UInt32, rhs: UInt32) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: UInt64, rhs: UInt64) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]},{"name":"rhs","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: UnicodeScalar, rhs: UnicodeScalar) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"x","type":"ObjectIdentifier","note":"","default":"","types":["ObjectIdentifier"]},{"name":"y","type":"ObjectIdentifier","note":"","default":"","types":["ObjectIdentifier"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(x: ObjectIdentifier, y: ObjectIdentifier) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"Base : CollectionType","types":["Base","CollectionType"]},"place":"","params":[{"name":"lhs","type":"FilterCollectionViewIndex<Base>","note":"","default":"","types":["Base","FilterCollectionViewIndex"]},{"name":"rhs","type":"FilterCollectionViewIndex<Base>","note":"","default":"","types":["Base","FilterCollectionViewIndex"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<Base : CollectionType>(lhs: FilterCollectionViewIndex<Base>, rhs: FilterCollectionViewIndex<Base>) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"I","types":[]},"place":"","params":[{"name":"lhs","type":"ReverseBidirectionalIndex<I>","note":"","default":"","types":["ReverseBidirectionalIndex"]},{"name":"rhs","type":"ReverseBidirectionalIndex<I>","note":"","default":"","types":["ReverseBidirectionalIndex"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<I>(lhs: ReverseBidirectionalIndex<I>, rhs: ReverseBidirectionalIndex<I>) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"I","types":[]},"place":"","params":[{"name":"lhs","type":"ReverseRandomAccessIndex<I>","note":"","default":"","types":["ReverseRandomAccessIndex"]},{"name":"rhs","type":"ReverseRandomAccessIndex<I>","note":"","default":"","types":["ReverseRandomAccessIndex"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<I>(lhs: ReverseRandomAccessIndex<I>, rhs: ReverseRandomAccessIndex<I>) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"Key : Equatable, Value : Equatable","types":["Equatable","Key","Value"]},"place":"","params":[{"name":"lhs","type":"[Key : Value]","note":"","default":"","types":["Key","Value"]},{"name":"rhs","type":"[Key : Value]","note":"","default":"","types":["Key","Value"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<Key : Equatable, Value : Equatable>(lhs: [Key : Value], rhs: [Key : Value]) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"Key : Hashable, Value","types":["Hashable","Key","Value"]},"place":"","params":[{"name":"lhs","type":"DictionaryIndex<Key, Value>","note":"","default":"","types":["DictionaryIndex","Key","Value"]},{"name":"rhs","type":"DictionaryIndex<Key, Value>","note":"","default":"","types":["DictionaryIndex","Key","Value"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<Key : Hashable, Value>(lhs: DictionaryIndex<Key, Value>, rhs: DictionaryIndex<Key, Value>) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T : _RawOptionSetType","types":["_RawOptionSetType"]},"place":"","params":[{"name":"a","type":"T","note":"","default":"","types":[]},{"name":"b","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T : _RawOptionSetType>(a: T, b: T) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T : _Strideable","types":["_Strideable"]},"place":"","params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"y","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T : _Strideable>(x: T, y: T) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T : Comparable","types":["Comparable"]},"place":"","params":[{"name":"lhs","type":"ClosedInterval<T>","note":"","default":"","types":["ClosedInterval"]},{"name":"rhs","type":"ClosedInterval<T>","note":"","default":"","types":["ClosedInterval"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T : Comparable>(lhs: ClosedInterval<T>, rhs: ClosedInterval<T>) -> Bool","comment":"Two `ClosedInterval`\\ s are equal if their `start` and `end` are\nequal"},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T : Comparable","types":["Comparable"]},"place":"","params":[{"name":"lhs","type":"HalfOpenInterval<T>","note":"","default":"","types":["HalfOpenInterval"]},{"name":"rhs","type":"HalfOpenInterval<T>","note":"","default":"","types":["HalfOpenInterval"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T : Comparable>(lhs: HalfOpenInterval<T>, rhs: HalfOpenInterval<T>) -> Bool","comment":"Two `HalfOpenInterval`\\ s are equal if their `start` and `end` are\nequal"},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T : Equatable","types":["Equatable"]},"place":"","params":[{"name":"lhs","type":"[T]","note":"","default":"","types":[]},{"name":"rhs","type":"[T]","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T : Equatable>(lhs: [T], rhs: [T]) -> Bool","comment":"Returns true if these arrays contain the same elements."},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T : Equatable","types":["Equatable"]},"place":"","params":[{"name":"lhs","type":"ContiguousArray<T>","note":"","default":"","types":["ContiguousArray"]},{"name":"rhs","type":"ContiguousArray<T>","note":"","default":"","types":["ContiguousArray"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T : Equatable>(lhs: ContiguousArray<T>, rhs: ContiguousArray<T>) -> Bool","comment":"Returns true if these arrays contain the same elements."},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T : Equatable","types":["Equatable"]},"place":"","params":[{"name":"lhs","type":"Slice<T>","note":"","default":"","types":["Slice"]},{"name":"rhs","type":"Slice<T>","note":"","default":"","types":["Slice"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T : Equatable>(lhs: Slice<T>, rhs: Slice<T>) -> Bool","comment":"Returns true if these arrays contain the same elements."},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T : Equatable","types":["Equatable"]},"place":"","params":[{"name":"lhs","type":"T?","note":"","default":"","types":[]},{"name":"rhs","type":"T?","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T : Equatable>(lhs: T?, rhs: T?) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"_OptionalNilComparisonType","note":"","default":"","types":["_OptionalNilComparisonType"]},{"name":"rhs","type":"T?","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T>(lhs: _OptionalNilComparisonType, rhs: T?) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"AutoreleasingUnsafeMutablePointer<T>","note":"","default":"","types":["AutoreleasingUnsafeMutablePointer"]},{"name":"rhs","type":"AutoreleasingUnsafeMutablePointer<T>","note":"","default":"","types":["AutoreleasingUnsafeMutablePointer"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T>(lhs: AutoreleasingUnsafeMutablePointer<T>, rhs: AutoreleasingUnsafeMutablePointer<T>) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"CFunctionPointer<T>","note":"","default":"","types":["CFunctionPointer"]},{"name":"rhs","type":"CFunctionPointer<T>","note":"","default":"","types":["CFunctionPointer"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T>(lhs: CFunctionPointer<T>, rhs: CFunctionPointer<T>) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"Range<T>","note":"","default":"","types":["Range"]},{"name":"rhs","type":"Range<T>","note":"","default":"","types":["Range"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T>(lhs: Range<T>, rhs: Range<T>) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"T?","note":"","default":"","types":[]},{"name":"rhs","type":"_OptionalNilComparisonType","note":"","default":"","types":["_OptionalNilComparisonType"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T>(lhs: T?, rhs: _OptionalNilComparisonType) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"rhs","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T>(lhs: UnsafeMutablePointer<T>, rhs: UnsafeMutablePointer<T>) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]},{"name":"rhs","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<T>(lhs: UnsafePointer<T>, rhs: UnsafePointer<T>) -> Bool","comment":""},{"kind":"operator func","name":"==","slug":"eqeq","generic":{"line":"Value, Element","types":["Element","Value"]},"place":"","params":[{"name":"lhs","type":"HeapBuffer<Value, Element>","note":"","default":"","types":["Element","HeapBuffer","Value"]},{"name":"rhs","type":"HeapBuffer<Value, Element>","note":"","default":"","types":["Element","HeapBuffer","Value"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==<Value, Element>(lhs: HeapBuffer<Value, Element>, rhs: HeapBuffer<Value, Element>) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":"===","slug":"eqeqeq","assignment":false,"associativity":"none","precedence":"130","comment":"","functions":[{"kind":"operator func","name":"===","slug":"eqeqeq","generic":{},"place":"","params":[{"name":"lhs","type":"AnyObject?","note":"","default":"","types":["AnyObject"]},{"name":"rhs","type":"AnyObject?","note":"","default":"","types":["AnyObject"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ===(lhs: AnyObject?, rhs: AnyObject?) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":">","slug":"gt","assignment":false,"associativity":"none","precedence":"130","comment":"","functions":[{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: Int, rhs: Int) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: Int8, rhs: Int8) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: Int16, rhs: Int16) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: Int32, rhs: Int32) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: Int64, rhs: Int64) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: UInt, rhs: UInt) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: UInt8, rhs: UInt8) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: UInt16, rhs: UInt16) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: UInt32, rhs: UInt32) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: UInt64, rhs: UInt64) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{"line":"T : _Comparable","types":["_Comparable"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ><T : _Comparable>(lhs: T, rhs: T) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{"line":"T : _Comparable","types":["_Comparable"]},"place":"","params":[{"name":"lhs","type":"T?","note":"","default":"","types":[]},{"name":"rhs","type":"T?","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ><T : _Comparable>(lhs: T?, rhs: T?) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":">=","slug":"gteq","assignment":false,"associativity":"none","precedence":"130","comment":"","functions":[{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: Int, rhs: Int) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: Int8, rhs: Int8) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: Int16, rhs: Int16) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: Int32, rhs: Int32) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: Int64, rhs: Int64) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: UInt, rhs: UInt) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: UInt8, rhs: UInt8) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: UInt16, rhs: UInt16) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: UInt32, rhs: UInt32) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: UInt64, rhs: UInt64) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{"line":"T : _Comparable","types":["_Comparable"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=<T : _Comparable>(lhs: T, rhs: T) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{"line":"T : _Comparable","types":["_Comparable"]},"place":"","params":[{"name":"lhs","type":"T?","note":"","default":"","types":[]},{"name":"rhs","type":"T?","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=<T : _Comparable>(lhs: T?, rhs: T?) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":">>","slug":"gtgt","assignment":false,"associativity":"none","precedence":"160","comment":"","functions":[{"kind":"operator func","name":">>","slug":"gtgt","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func >>(lhs: Int, rhs: Int) -> Int","comment":""},{"kind":"operator func","name":">>","slug":"gtgt","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"func >>(lhs: Int8, rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":">>","slug":"gtgt","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"func >>(lhs: Int16, rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":">>","slug":"gtgt","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"func >>(lhs: Int32, rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":">>","slug":"gtgt","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"func >>(lhs: Int64, rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":">>","slug":"gtgt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"func >>(lhs: UInt, rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":">>","slug":"gtgt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"func >>(lhs: UInt8, rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":">>","slug":"gtgt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"func >>(lhs: UInt16, rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":">>","slug":"gtgt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"func >>(lhs: UInt32, rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":">>","slug":"gtgt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"func >>(lhs: UInt64, rhs: UInt64) -> UInt64","comment":""}]},{"kind":"operator","place":"infix","name":">>=","slug":"gtgteq","assignment":true,"associativity":"right","precedence":"90","comment":"","functions":[{"kind":"operator func","name":">>=","slug":"gtgteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"inout","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func >>=(inout lhs: Int, rhs: Int)","comment":""},{"kind":"operator func","name":">>=","slug":"gtgteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"inout","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{},"attr":"","line":"func >>=(inout lhs: Int8, rhs: Int8)","comment":""},{"kind":"operator func","name":">>=","slug":"gtgteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"inout","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{},"attr":"","line":"func >>=(inout lhs: Int16, rhs: Int16)","comment":""},{"kind":"operator func","name":">>=","slug":"gtgteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"inout","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{},"attr":"","line":"func >>=(inout lhs: Int32, rhs: Int32)","comment":""},{"kind":"operator func","name":">>=","slug":"gtgteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"inout","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{},"attr":"","line":"func >>=(inout lhs: Int64, rhs: Int64)","comment":""},{"kind":"operator func","name":">>=","slug":"gtgteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"inout","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{},"attr":"","line":"func >>=(inout lhs: UInt, rhs: UInt)","comment":""},{"kind":"operator func","name":">>=","slug":"gtgteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"inout","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{},"attr":"","line":"func >>=(inout lhs: UInt8, rhs: UInt8)","comment":""},{"kind":"operator func","name":">>=","slug":"gtgteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"inout","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{},"attr":"","line":"func >>=(inout lhs: UInt16, rhs: UInt16)","comment":""},{"kind":"operator func","name":">>=","slug":"gtgteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"inout","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{},"attr":"","line":"func >>=(inout lhs: UInt32, rhs: UInt32)","comment":""},{"kind":"operator func","name":">>=","slug":"gtgteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"inout","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{},"attr":"","line":"func >>=(inout lhs: UInt64, rhs: UInt64)","comment":""}]},{"kind":"operator","place":"infix","name":"??","slug":"qmqm","assignment":false,"associativity":"right","precedence":"110","comment":"","functions":[{"kind":"operator func","name":"??","slug":"qmqm","generic":{"line":"T","types":[]},"place":"","params":[{"name":"optional","type":"T?","note":"","default":"","types":[]},{"name":"defaultValue","type":"@autoclosure () -> T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func ??<T>(optional: T?, defaultValue: @autoclosure () -> T) -> T","comment":""},{"kind":"operator func","name":"??","slug":"qmqm","generic":{"line":"T","types":[]},"place":"","params":[{"name":"optional","type":"T?","note":"","default":"","types":[]},{"name":"defaultValue","type":"@autoclosure () -> T?","note":"","default":"","types":[]}],"ret":{"line":"T?","types":[]},"attr":"","line":"func ??<T>(optional: T?, defaultValue: @autoclosure () -> T?) -> T?","comment":""}]},{"kind":"operator","place":"infix","name":"^","slug":"crt","assignment":false,"associativity":"left","precedence":"140","comment":"","functions":[{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"Bool","note":"","default":"","types":["Bool"]},{"name":"rhs","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ^(lhs: Bool, rhs: Bool) -> Bool","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func ^(lhs: Int, rhs: Int) -> Int","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"func ^(lhs: Int8, rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"func ^(lhs: Int16, rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"func ^(lhs: Int32, rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"func ^(lhs: Int64, rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"func ^(lhs: UInt, rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"func ^(lhs: UInt8, rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"func ^(lhs: UInt16, rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"func ^(lhs: UInt32, rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"func ^(lhs: UInt64, rhs: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"^","slug":"crt","generic":{"line":"T : _RawOptionSetType","types":["_RawOptionSetType"]},"place":"","params":[{"name":"a","type":"T","note":"","default":"","types":[]},{"name":"b","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func ^<T : _RawOptionSetType>(a: T, b: T) -> T","comment":""}]},{"kind":"operator","place":"infix","name":"^=","slug":"crteq","assignment":true,"associativity":"right","precedence":"90","comment":"","functions":[{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"Bool","note":"inout","default":"","types":["Bool"]},{"name":"rhs","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: Bool, rhs: Bool)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"inout","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: Int, rhs: Int)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"inout","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: Int8, rhs: Int8)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"inout","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: Int16, rhs: Int16)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"inout","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: Int32, rhs: Int32)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"inout","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: Int64, rhs: Int64)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"inout","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: UInt, rhs: UInt)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"inout","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: UInt8, rhs: UInt8)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"inout","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: UInt16, rhs: UInt16)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"inout","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: UInt32, rhs: UInt32)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"inout","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{},"attr":"","line":"func ^=(inout lhs: UInt64, rhs: UInt64)","comment":""},{"kind":"operator func","name":"^=","slug":"crteq","generic":{"line":"T : BitwiseOperationsType","types":["BitwiseOperationsType"]},"place":"","params":[{"name":"lhs","type":"T","note":"inout","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func ^=<T : BitwiseOperationsType>(inout lhs: T, rhs: T)","comment":""}]},{"kind":"operator","place":"infix","name":"|","slug":"bar","assignment":false,"associativity":"left","precedence":"140","comment":"","functions":[{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"Bool","note":"","default":"","types":["Bool"]},{"name":"rhs","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func |(lhs: Bool, rhs: Bool) -> Bool","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"func |(lhs: Int, rhs: Int) -> Int","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"func |(lhs: Int8, rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"func |(lhs: Int16, rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"func |(lhs: Int32, rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"func |(lhs: Int64, rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"func |(lhs: UInt, rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"func |(lhs: UInt8, rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"func |(lhs: UInt16, rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"func |(lhs: UInt32, rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"func |(lhs: UInt64, rhs: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"|","slug":"bar","generic":{"line":"T : _RawOptionSetType","types":["_RawOptionSetType"]},"place":"","params":[{"name":"a","type":"T","note":"","default":"","types":[]},{"name":"b","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"func |<T : _RawOptionSetType>(a: T, b: T) -> T","comment":""}]},{"kind":"operator","place":"infix","name":"|=","slug":"bareq","assignment":true,"associativity":"right","precedence":"90","comment":"","functions":[{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"Bool","note":"inout","default":"","types":["Bool"]},{"name":"rhs","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{},"attr":"","line":"func |=(inout lhs: Bool, rhs: Bool)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"Int","note":"inout","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"attr":"","line":"func |=(inout lhs: Int, rhs: Int)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"Int8","note":"inout","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{},"attr":"","line":"func |=(inout lhs: Int8, rhs: Int8)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"Int16","note":"inout","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{},"attr":"","line":"func |=(inout lhs: Int16, rhs: Int16)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"Int32","note":"inout","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{},"attr":"","line":"func |=(inout lhs: Int32, rhs: Int32)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"Int64","note":"inout","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{},"attr":"","line":"func |=(inout lhs: Int64, rhs: Int64)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt","note":"inout","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{},"attr":"","line":"func |=(inout lhs: UInt, rhs: UInt)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt8","note":"inout","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{},"attr":"","line":"func |=(inout lhs: UInt8, rhs: UInt8)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt16","note":"inout","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{},"attr":"","line":"func |=(inout lhs: UInt16, rhs: UInt16)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt32","note":"inout","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{},"attr":"","line":"func |=(inout lhs: UInt32, rhs: UInt32)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{},"place":"","params":[{"name":"lhs","type":"UInt64","note":"inout","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{},"attr":"","line":"func |=(inout lhs: UInt64, rhs: UInt64)","comment":""},{"kind":"operator func","name":"|=","slug":"bareq","generic":{"line":"T : BitwiseOperationsType","types":["BitwiseOperationsType"]},"place":"","params":[{"name":"lhs","type":"T","note":"inout","default":"","types":[]},{"name":"rhs","type":"T","note":"","default":"","types":[]}],"ret":{},"attr":"","line":"func |=<T : BitwiseOperationsType>(inout lhs: T, rhs: T)","comment":""}]},{"kind":"operator","place":"infix","name":"||","slug":"barbar","assignment":false,"associativity":"left","precedence":"110","comment":"","functions":[{"kind":"operator func","name":"||","slug":"barbar","generic":{"line":"T : BooleanType, U : BooleanType","types":["BooleanType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"@autoclosure () -> U","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"@inline(__always) ","line":"func ||<T : BooleanType, U : BooleanType>(lhs: T, rhs: @autoclosure () -> U) -> Bool","comment":"If `lhs` is `true`, return it.  Otherwise, evaluate `rhs` and\nreturn its `boolValue`."},{"kind":"operator func","name":"||","slug":"barbar","generic":{"line":"T : BooleanType","types":["BooleanType"]},"place":"","params":[{"name":"lhs","type":"T","note":"","default":"","types":[]},{"name":"rhs","type":"@autoclosure () -> Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ||<T : BooleanType>(lhs: T, rhs: @autoclosure () -> Bool) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":"~=","slug":"tildeeq","assignment":false,"associativity":"none","precedence":"130","comment":"","functions":[{"kind":"operator func","name":"~=","slug":"tildeeq","generic":{"line":"I : IntervalType","types":["IntervalType"]},"place":"","params":[{"name":"pattern","type":"I","note":"","default":"","types":[]},{"name":"value","type":"I.Bound","note":"","default":"","types":["Bound"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ~=<I : IntervalType>(pattern: I, value: I.Bound) -> Bool","comment":"Returns `true` iff `pattern` contains `value`"},{"kind":"operator func","name":"~=","slug":"tildeeq","generic":{"line":"T : Equatable","types":["Equatable"]},"place":"","params":[{"name":"a","type":"T","note":"","default":"","types":[]},{"name":"b","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ~=<T : Equatable>(a: T, b: T) -> Bool","comment":""},{"kind":"operator func","name":"~=","slug":"tildeeq","generic":{"line":"T","types":[]},"place":"","params":[{"name":"lhs","type":"_OptionalNilComparisonType","note":"","default":"","types":["_OptionalNilComparisonType"]},{"name":"rhs","type":"T?","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ~=<T>(lhs: _OptionalNilComparisonType, rhs: T?) -> Bool","comment":""}]},{"kind":"operator","place":"infix","name":"~>","slug":"tildegt","assignment":false,"associativity":"left","precedence":"255","comment":"","functions":[]},{"kind":"operator","place":"prefix","name":"prefix !","slug":"prefix_excl","assignment":false,"associativity":"","precedence":"","comment":"","functions":[{"kind":"operator func","name":"!","slug":"excl","generic":{},"place":"prefix","params":[{"name":"a","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"prefix func !(a: Bool) -> Bool","comment":""},{"kind":"operator func","name":"!","slug":"excl","generic":{"line":"T : BooleanType","types":["BooleanType"]},"place":"prefix","params":[{"name":"a","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"prefix func !<T : BooleanType>(a: T) -> Bool","comment":"Return the result of inverting `a`\\ 's logic value"}]},{"kind":"operator","place":"prefix","name":"prefix +","slug":"prefix_pls","assignment":false,"associativity":"","precedence":"","comment":"","functions":[{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"prefix","params":[{"name":"x","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"prefix func +(x: Double) -> Double","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"prefix","params":[{"name":"x","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"prefix func +(x: Float) -> Float","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"prefix","params":[{"name":"x","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"prefix func +(x: Float80) -> Float80","comment":""},{"kind":"operator func","name":"+","slug":"pls","generic":{"line":"T : _SignedNumberType","types":["_SignedNumberType"]},"place":"prefix","params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"prefix func +<T : _SignedNumberType>(x: T) -> T","comment":""}]},{"kind":"operator","place":"prefix","name":"prefix ++","slug":"prefix_plspls","assignment":false,"associativity":"","precedence":"","comment":"","functions":[{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Double","note":"inout","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"prefix func ++(inout rhs: Double) -> Double","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Float","note":"inout","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"prefix func ++(inout rhs: Float) -> Float","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Float80","note":"inout","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"prefix func ++(inout rhs: Float80) -> Float80","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"x","type":"Int","note":"inout","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"prefix func ++(inout x: Int) -> Int","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"x","type":"Int8","note":"inout","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"prefix func ++(inout x: Int8) -> Int8","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"x","type":"Int16","note":"inout","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"prefix func ++(inout x: Int16) -> Int16","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"x","type":"Int32","note":"inout","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"prefix func ++(inout x: Int32) -> Int32","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"x","type":"Int64","note":"inout","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"prefix func ++(inout x: Int64) -> Int64","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"x","type":"UInt","note":"inout","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"prefix func ++(inout x: UInt) -> UInt","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"x","type":"UInt8","note":"inout","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"prefix func ++(inout x: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"x","type":"UInt16","note":"inout","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"prefix func ++(inout x: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"x","type":"UInt32","note":"inout","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"prefix func ++(inout x: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"prefix","params":[{"name":"x","type":"UInt64","note":"inout","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"prefix func ++(inout x: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{"line":"T : _Incrementable","types":["_Incrementable"]},"place":"prefix","params":[{"name":"x","type":"T","note":"inout","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"prefix func ++<T : _Incrementable>(inout x: T) -> T","comment":""}]},{"kind":"operator","place":"prefix","name":"prefix -","slug":"prefix_mns","assignment":false,"associativity":"","precedence":"","comment":"","functions":[{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"prefix","params":[{"name":"x","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"prefix func -(x: Double) -> Double","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"prefix","params":[{"name":"x","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"prefix func -(x: Float) -> Float","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"prefix","params":[{"name":"x","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"prefix func -(x: Float80) -> Float80","comment":""},{"kind":"operator func","name":"-","slug":"mns","generic":{"line":"T : _SignedNumberType","types":["_SignedNumberType"]},"place":"prefix","params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"prefix func -<T : _SignedNumberType>(x: T) -> T","comment":""}]},{"kind":"operator","place":"prefix","name":"prefix --","slug":"prefix_mnsmns","assignment":false,"associativity":"","precedence":"","comment":"","functions":[{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Double","note":"inout","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"prefix func --(inout rhs: Double) -> Double","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Float","note":"inout","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"prefix func --(inout rhs: Float) -> Float","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Float80","note":"inout","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"prefix func --(inout rhs: Float80) -> Float80","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"x","type":"Int","note":"inout","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"prefix func --(inout x: Int) -> Int","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"x","type":"Int8","note":"inout","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"prefix func --(inout x: Int8) -> Int8","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"x","type":"Int16","note":"inout","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"prefix func --(inout x: Int16) -> Int16","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"x","type":"Int32","note":"inout","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"prefix func --(inout x: Int32) -> Int32","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"x","type":"Int64","note":"inout","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"prefix func --(inout x: Int64) -> Int64","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"x","type":"UInt","note":"inout","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"prefix func --(inout x: UInt) -> UInt","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"x","type":"UInt8","note":"inout","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"prefix func --(inout x: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"x","type":"UInt16","note":"inout","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"prefix func --(inout x: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"x","type":"UInt32","note":"inout","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"prefix func --(inout x: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"prefix","params":[{"name":"x","type":"UInt64","note":"inout","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"prefix func --(inout x: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{"line":"T : _BidirectionalIndexType","types":["_BidirectionalIndexType"]},"place":"prefix","params":[{"name":"x","type":"T","note":"inout","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"prefix func --<T : _BidirectionalIndexType>(inout x: T) -> T","comment":""}]},{"kind":"operator","place":"prefix","name":"prefix ~","slug":"prefix_tilde","assignment":false,"associativity":"","precedence":"","comment":"","functions":[{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"a","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"prefix func ~(a: Bool) -> Bool","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"prefix func ~(rhs: Int) -> Int","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"prefix func ~(rhs: Int8) -> Int8","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"prefix func ~(rhs: Int16) -> Int16","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"prefix func ~(rhs: Int32) -> Int32","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"rhs","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"prefix func ~(rhs: Int64) -> Int64","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"rhs","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"prefix func ~(rhs: UInt) -> UInt","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"rhs","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"prefix func ~(rhs: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"rhs","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"prefix func ~(rhs: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"rhs","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"prefix func ~(rhs: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"rhs","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"prefix func ~(rhs: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"~","slug":"tilde","generic":{"line":"T : _RawOptionSetType","types":["_RawOptionSetType"]},"place":"prefix","params":[{"name":"a","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"prefix func ~<T : _RawOptionSetType>(a: T) -> T","comment":""}]},{"kind":"operator","place":"postfix","name":"postfix ++","slug":"postfix_plspls","assignment":false,"associativity":"","precedence":"","comment":"","functions":[{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"lhs","type":"Double","note":"inout","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"postfix func ++(inout lhs: Double) -> Double","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"lhs","type":"Float","note":"inout","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"postfix func ++(inout lhs: Float) -> Float","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"lhs","type":"Float80","note":"inout","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"postfix func ++(inout lhs: Float80) -> Float80","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"x","type":"Int","note":"inout","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"postfix func ++(inout x: Int) -> Int","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"x","type":"Int8","note":"inout","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"postfix func ++(inout x: Int8) -> Int8","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"x","type":"Int16","note":"inout","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"postfix func ++(inout x: Int16) -> Int16","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"x","type":"Int32","note":"inout","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"postfix func ++(inout x: Int32) -> Int32","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"x","type":"Int64","note":"inout","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"postfix func ++(inout x: Int64) -> Int64","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"x","type":"UInt","note":"inout","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"postfix func ++(inout x: UInt) -> UInt","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"x","type":"UInt8","note":"inout","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"postfix func ++(inout x: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"x","type":"UInt16","note":"inout","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"postfix func ++(inout x: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"x","type":"UInt32","note":"inout","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"postfix func ++(inout x: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{},"place":"postfix","params":[{"name":"x","type":"UInt64","note":"inout","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"postfix func ++(inout x: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"++","slug":"plspls","generic":{"line":"T : _Incrementable","types":["_Incrementable"]},"place":"postfix","params":[{"name":"x","type":"T","note":"inout","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"postfix func ++<T : _Incrementable>(inout x: T) -> T","comment":""}]},{"kind":"operator","place":"postfix","name":"postfix --","slug":"postfix_mnsmns","assignment":false,"associativity":"","precedence":"","comment":"","functions":[{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"lhs","type":"Double","note":"inout","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"attr":"","line":"postfix func --(inout lhs: Double) -> Double","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"lhs","type":"Float","note":"inout","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"attr":"","line":"postfix func --(inout lhs: Float) -> Float","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"lhs","type":"Float80","note":"inout","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"attr":"","line":"postfix func --(inout lhs: Float80) -> Float80","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"x","type":"Int","note":"inout","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"attr":"","line":"postfix func --(inout x: Int) -> Int","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"x","type":"Int8","note":"inout","default":"","types":["Int8"]}],"ret":{"line":"Int8","types":["Int8"]},"attr":"","line":"postfix func --(inout x: Int8) -> Int8","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"x","type":"Int16","note":"inout","default":"","types":["Int16"]}],"ret":{"line":"Int16","types":["Int16"]},"attr":"","line":"postfix func --(inout x: Int16) -> Int16","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"x","type":"Int32","note":"inout","default":"","types":["Int32"]}],"ret":{"line":"Int32","types":["Int32"]},"attr":"","line":"postfix func --(inout x: Int32) -> Int32","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"x","type":"Int64","note":"inout","default":"","types":["Int64"]}],"ret":{"line":"Int64","types":["Int64"]},"attr":"","line":"postfix func --(inout x: Int64) -> Int64","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"x","type":"UInt","note":"inout","default":"","types":["UInt"]}],"ret":{"line":"UInt","types":["UInt"]},"attr":"","line":"postfix func --(inout x: UInt) -> UInt","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"x","type":"UInt8","note":"inout","default":"","types":["UInt8"]}],"ret":{"line":"UInt8","types":["UInt8"]},"attr":"","line":"postfix func --(inout x: UInt8) -> UInt8","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"x","type":"UInt16","note":"inout","default":"","types":["UInt16"]}],"ret":{"line":"UInt16","types":["UInt16"]},"attr":"","line":"postfix func --(inout x: UInt16) -> UInt16","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"x","type":"UInt32","note":"inout","default":"","types":["UInt32"]}],"ret":{"line":"UInt32","types":["UInt32"]},"attr":"","line":"postfix func --(inout x: UInt32) -> UInt32","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{},"place":"postfix","params":[{"name":"x","type":"UInt64","note":"inout","default":"","types":["UInt64"]}],"ret":{"line":"UInt64","types":["UInt64"]},"attr":"","line":"postfix func --(inout x: UInt64) -> UInt64","comment":""},{"kind":"operator func","name":"--","slug":"mnsmns","generic":{"line":"T : _BidirectionalIndexType","types":["_BidirectionalIndexType"]},"place":"postfix","params":[{"name":"x","type":"T","note":"inout","default":"","types":[]}],"ret":{"line":"T","types":[]},"attr":"","line":"postfix func --<T : _BidirectionalIndexType>(inout x: T) -> T","comment":""}]}],"functions":[{"kind":"func","name":"abs","slug":"abs","generic":{"line":"T : SignedNumberType","types":["SignedNumberType"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func abs<T : SignedNumberType>(x: T) -> T","comment":"Return the absolute value of `x`.\n\nConcrete instances of `SignedNumberType` can specialize this\nfunction by conforming to `AbsoluteValuable`."},{"kind":"func","name":"advance","slug":"advance","generic":{"line":"T : ForwardIndexType","types":["ForwardIndexType"]},"params":[{"name":"start","type":"T","note":"","default":"","types":[]},{"name":"n","type":"T.Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func advance<T : ForwardIndexType>(start: T, n: T.Distance) -> T","comment":"Return the result of advancing `start` by `n` positions.  If `T`\nmodels `RandomAccessIndexType`, executes in O(1).  Otherwise,\nexecutes in O(`abs(n)`).  If `T` does not model\n`BidirectionalIndexType`, requires that `n` is non-negative.\n\n`advance(i, n)` is a synonym for `i++n'"},{"kind":"func","name":"advance","slug":"advance","generic":{"line":"T : ForwardIndexType","types":["ForwardIndexType"]},"params":[{"name":"start","type":"T","note":"","default":"","types":[]},{"name":"n","type":"T.Distance","note":"","default":"","types":["Distance"]},{"name":"end","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func advance<T : ForwardIndexType>(start: T, n: T.Distance, end: T) -> T","comment":"Return the result of advancing start by `n` positions, or until it\nequals `end`.  If `T` models `RandomAccessIndexType`, executes in\nO(1).  Otherwise, executes in O(`abs(n)`).  If `T` does not model\n`BidirectionalIndexType`, requires that `n` is non-negative."},{"kind":"func","name":"alignof","slug":"alignof","generic":{"line":"T","types":[]},"params":[{"name":"_","type":"T.Type","note":"","default":"","types":["Type"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func alignof<T>(_: T.Type) -> Int","comment":"Returns the minimum memory alignment of `T`."},{"kind":"func","name":"alignofValue","slug":"alignofValue","generic":{"line":"T","types":[]},"params":[{"name":"_","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func alignofValue<T>(_: T) -> Int","comment":"Returns the minimum memory alignment of `T`."},{"kind":"func","name":"assert","slug":"assert","generic":{},"params":[{"name":"condition","type":"@autoclosure () -> Bool","note":"","default":"","types":["Bool"]},{"name":"message","type":"@autoclosure () -> String","note":"_","default":"default","types":["String"]},{"name":"file","type":"StaticString","note":"","default":"default","types":["StaticString"]},{"name":"line","type":"UWord","note":"","default":"default","types":["UWord"]}],"ret":{},"note":"","attr":"","line":"func assert(condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = default, line: UWord = default)","comment":"User code assertions.\n\nUser code assertions and fatal errors are only enabled in debug mode. In\nrelease or fast mode these checks are disabled. This means they may have no\neffect on program semantics, depending on the assert configuration.\nTraditional C-style assert with an optional message.\n\nWhen assertions are enabled and `condition` is false, stop program\nexecution in a debuggable state after printing a message.  When\nassertions are disabled in release and fast builds, `condition` is not even\nevaluated.\n\nWhen assertions are turned off, the optimizer can assume that the\n`condition` is true."},{"kind":"func","name":"assertionFailure","slug":"assertionFailure","generic":{},"params":[{"name":"message","type":"@autoclosure () -> String","note":"_","default":"default","types":["String"]},{"name":"file","type":"StaticString","note":"","default":"default","types":["StaticString"]},{"name":"line","type":"UWord","note":"","default":"default","types":["UWord"]}],"ret":{},"note":"","attr":"@noreturn ","line":"func assertionFailure(_ message: @autoclosure () -> String = default, file: StaticString = default, line: UWord = default)","comment":"A fatal error occurred and program execution should stop in debug mode.  In\noptimized builds this is a noop."},{"kind":"func","name":"contains","slug":"contains","generic":{"line":"S : SequenceType where S.Generator.Element : Equatable","types":["Element","Equatable","Generator","SequenceType"]},"params":[{"name":"seq","type":"S","note":"","default":"","types":[]},{"name":"x","type":"S.Generator.Element","note":"","default":"","types":["Element","Generator"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func contains<S : SequenceType where S.Generator.Element : Equatable>(seq: S, x: S.Generator.Element) -> Bool","comment":"Return `true` iff `x` is in `seq`."},{"kind":"func","name":"contains","slug":"contains","generic":{"line":"S : SequenceType, L : BooleanType","types":["BooleanType","SequenceType"]},"params":[{"name":"seq","type":"S","note":"","default":"","types":[]},{"name":"predicate","type":"(S.Generator.Element) -> L","note":"","default":"","types":["Element","Generator"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func contains<S : SequenceType, L : BooleanType>(seq: S, predicate: (S.Generator.Element) -> L) -> Bool","comment":"Return `true` iff an element in `seq` satisfies `predicate`."},{"kind":"func","name":"count","slug":"count","generic":{"line":"I : RandomAccessIndexType","types":["RandomAccessIndexType"]},"params":[{"name":"r","type":"Range<I>","note":"","default":"","types":["Range"]}],"ret":{"line":"I.Distance","types":["Distance"]},"note":"","attr":"","line":"func count<I : RandomAccessIndexType>(r: Range<I>) -> I.Distance","comment":"Equivalent to countElements(r)"},{"kind":"func","name":"countElements","slug":"countElements","generic":{"line":"T : _CollectionType","types":["_CollectionType"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T.Index.Distance","types":["Distance","Index"]},"note":"","attr":"","line":"func countElements<T : _CollectionType>(x: T) -> T.Index.Distance","comment":"Return the number of elements in x.\n\nO(1) if T.Index is RandomAccessIndexType; O(N) otherwise."},{"kind":"func","name":"debugPrint","slug":"debugPrint","generic":{"line":"T, TargetStream : OutputStreamType","types":["OutputStreamType","TargetStream"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"target","type":"TargetStream","note":"inout","default":"","types":["TargetStream"]}],"ret":{},"note":"","attr":"","line":"func debugPrint<T, TargetStream : OutputStreamType>(x: T, inout target: TargetStream)","comment":"Write to `target` the textual representation of `x` most suitable\nfor debugging.\n\n* If `T` conforms to `DebugPrintable`, write `x.debugDescription`\n* Otherwise, if `T` conforms to `Printable`, write `x.description`\n* Otherwise, if `T` conforms to `Stramable`, write `x`\n* Otherwise, fall back to a default textual representation.\n\nSee also: `debugPrintln(x, &target)`"},{"kind":"func","name":"debugPrint","slug":"debugPrint","generic":{"line":"T","types":[]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func debugPrint<T>(x: T)","comment":"Write to the console the textual representation of `x` most suitable\nfor debugging.\n\n* If `T` conforms to `DebugPrintable`, write `x.debugDescription`\n* Otherwise, if `T` conforms to `Printable`, write `x.description`\n* Otherwise, if `T` conforms to `Stramable`, write `x`\n* Otherwise, fall back to a default textual representation.\n\nSee also: `debugPrintln(x)`"},{"kind":"func","name":"debugPrintln","slug":"debugPrintln","generic":{"line":"T, TargetStream : OutputStreamType","types":["OutputStreamType","TargetStream"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"target","type":"TargetStream","note":"inout","default":"","types":["TargetStream"]}],"ret":{},"note":"","attr":"","line":"func debugPrintln<T, TargetStream : OutputStreamType>(x: T, inout target: TargetStream)","comment":"Write to `target` the textual representation of `x` most suitable\nfor debugging, followed by a newline.\n\n* If `T` conforms to `DebugPrintable`, write `x.debugDescription`\n* Otherwise, if `T` conforms to `Printable`, write `x.description`\n* Otherwise, if `T` conforms to `Stramable`, write `x`\n* Otherwise, fall back to a default textual representation.\n\nSee also: `debugPrint(x, &target)`"},{"kind":"func","name":"debugPrintln","slug":"debugPrintln","generic":{"line":"T","types":[]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func debugPrintln<T>(x: T)","comment":"Write to the console the textual representation of `x` most suitable\nfor debugging, followed by a newline.\n\n* If `T` conforms to `DebugPrintable`, write `x.debugDescription`\n* Otherwise, if `T` conforms to `Printable`, write `x.description`\n* Otherwise, if `T` conforms to `Stramable`, write `x`\n* Otherwise, fall back to a default textual representation.\n\nSee also: `debugPrint(x)`"},{"kind":"func","name":"distance","slug":"distance","generic":{"line":"T : ForwardIndexType","types":["ForwardIndexType"]},"params":[{"name":"start","type":"T","note":"","default":"","types":[]},{"name":"end","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T.Distance","types":["Distance"]},"note":"","attr":"","line":"func distance<T : ForwardIndexType>(start: T, end: T) -> T.Distance","comment":"Measure the distance between `start` and `end`.\n\nIf `T` models `RandomAccessIndexType`, requires that `start` and `end` are\npart of the same sequence, and executes in O(1).\n\nOtherwise, requires that `end` is reachable from `start` by\nincrementation, and executes in O(N), where N is the function's\nresult."},{"kind":"func","name":"dropFirst","slug":"dropFirst","generic":{"line":"Seq : Sliceable","types":["Seq","Sliceable"]},"params":[{"name":"s","type":"Seq","note":"","default":"","types":["Seq"]}],"ret":{"line":"Seq.SubSlice","types":["Seq","SubSlice"]},"note":"","attr":"","line":"func dropFirst<Seq : Sliceable>(s: Seq) -> Seq.SubSlice","comment":"Return a slice containing all but the first element of `s`.\n\nRequires: `s` is non-empty."},{"kind":"func","name":"dropLast","slug":"dropLast","generic":{"line":"S : Sliceable where S.Index : BidirectionalIndexType","types":["BidirectionalIndexType","Index","Sliceable"]},"params":[{"name":"s","type":"S","note":"","default":"","types":[]}],"ret":{"line":"S.SubSlice","types":["SubSlice"]},"note":"","attr":"","line":"func dropLast<S : Sliceable where S.Index : BidirectionalIndexType>(s: S) -> S.SubSlice","comment":"Return a slice containing all but the last element of `s`.\n\nRequires: `s` is non-empty."},{"kind":"func","name":"dump","slug":"dump","generic":{"line":"T","types":[]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"name","type":"String?","note":"","default":"default","types":["String"]},{"name":"indent","type":"Int","note":"","default":"default","types":["Int"]},{"name":"maxDepth","type":"Int","note":"","default":"default","types":["Int"]},{"name":"maxItems","type":"Int","note":"","default":"default","types":["Int"]}],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func dump<T>(x: T, name: String? = default, indent: Int = default, maxDepth: Int = default, maxItems: Int = default) -> T","comment":"Dump an object's contents using its mirror to standard output."},{"kind":"func","name":"dump","slug":"dump","generic":{"line":"T, TargetStream : OutputStreamType","types":["OutputStreamType","TargetStream"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"targetStream","type":"TargetStream","note":"inout","default":"","types":["TargetStream"]},{"name":"name","type":"String?","note":"","default":"default","types":["String"]},{"name":"indent","type":"Int","note":"","default":"default","types":["Int"]},{"name":"maxDepth","type":"Int","note":"","default":"default","types":["Int"]},{"name":"maxItems","type":"Int","note":"","default":"default","types":["Int"]}],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func dump<T, TargetStream : OutputStreamType>(x: T, inout targetStream: TargetStream, name: String? = default, indent: Int = default, maxDepth: Int = default, maxItems: Int = default) -> T","comment":"Dump an object's contents using its mirror to the specified output stream."},{"kind":"func","name":"enumerate","slug":"enumerate","generic":{"line":"Seq : SequenceType","types":["Seq","SequenceType"]},"params":[{"name":"base","type":"Seq","note":"","default":"","types":["Seq"]}],"ret":{"line":"EnumerateSequence<Seq>","types":["EnumerateSequence","Seq"]},"note":"","attr":"","line":"func enumerate<Seq : SequenceType>(base: Seq) -> EnumerateSequence<Seq>","comment":"Return a lazy `SequenceType` containing pairs (*n*, *x*), where\n*n*\\ s are consecutive `Int`\\ s starting at zero, and *x*\\ s are\nthe elements of `base`::\n\n  > for (n, c) in enumerate(\"Swift\") { println(\"\\(n): '\\(c)'\" )}\n  0: 'S'\n  1: 'w'\n  2: 'i'\n  3: 'f'\n  4: 't'"},{"kind":"func","name":"equal","slug":"equal","generic":{"line":"S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element, S1.Generator.Element : Equatable","types":["Element","Equatable","Generator","S1","S2","SequenceType"]},"params":[{"name":"a1","type":"S1","note":"","default":"","types":["S1"]},{"name":"a2","type":"S2","note":"","default":"","types":["S2"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func equal<S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element, S1.Generator.Element : Equatable>(a1: S1, a2: S2) -> Bool","comment":"Return `true` iff `a1` and `a2` contain the same elements in the\nsame order."},{"kind":"func","name":"equal","slug":"equal","generic":{"line":"S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element","types":["Element","Generator","S1","S2","SequenceType"]},"params":[{"name":"a1","type":"S1","note":"","default":"","types":["S1"]},{"name":"a2","type":"S2","note":"","default":"","types":["S2"]},{"name":"isEquivalent","type":"(S1.Generator.Element, S1.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator","S1"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func equal<S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element>(a1: S1, a2: S2, isEquivalent: (S1.Generator.Element, S1.Generator.Element) -> Bool) -> Bool","comment":"Return true iff `a1` and `a2` contain equivalent elements, using\n`isEquivalent` as the equivalence test.  Requires: `isEquivalent`\nis an `equivalence relation\n<http://en.wikipedia.org/wiki/Equivalence_relation>`_"},{"kind":"func","name":"extend","slug":"extend","generic":{"line":"C : RangeReplaceableCollectionType, S : CollectionType where S.Generator.Element == S.Generator.Element","types":["CollectionType","Element","Generator","RangeReplaceableCollectionType"]},"params":[{"name":"x","type":"C","note":"inout","default":"","types":[]},{"name":"newElements","type":"S","note":"","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func extend<C : RangeReplaceableCollectionType, S : CollectionType where S.Generator.Element == S.Generator.Element>(inout x: C, newElements: S)","comment":"Append elements from `newElements` to `x`.  Complexity:\nO(N)"},{"kind":"func","name":"fatalError","slug":"fatalError","generic":{},"params":[{"name":"message","type":"@autoclosure () -> String","note":"_","default":"default","types":["String"]},{"name":"file","type":"StaticString","note":"","default":"default","types":["StaticString"]},{"name":"line","type":"UWord","note":"","default":"default","types":["UWord"]}],"ret":{},"note":"","attr":"@noreturn ","line":"func fatalError(_ message: @autoclosure () -> String = default, file: StaticString = default, line: UWord = default)","comment":"A fatal error occurred and program execution should stop in debug,\noptimized and unchecked modes."},{"kind":"func","name":"filter","slug":"filter","generic":{"line":"S : SequenceType","types":["SequenceType"]},"params":[{"name":"source","type":"S","note":"","default":"","types":[]},{"name":"includeElement","type":"(S.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator"]}],"ret":{"line":"[S.Generator.Element]","types":["Element","Generator"]},"note":"","attr":"","line":"func filter<S : SequenceType>(source: S, includeElement: (S.Generator.Element) -> Bool) -> [S.Generator.Element]","comment":"Return an `Array` containing the elements of `source`,\nin order, that satisfy the predicate `includeElement`."},{"kind":"func","name":"find","slug":"find","generic":{"line":"C : CollectionType where C.Generator.Element : Equatable","types":["CollectionType","Element","Equatable","Generator"]},"params":[{"name":"domain","type":"C","note":"","default":"","types":[]},{"name":"value","type":"C.Generator.Element","note":"","default":"","types":["Element","Generator"]}],"ret":{"line":"C.Index?","types":["Index"]},"note":"","attr":"","line":"func find<C : CollectionType where C.Generator.Element : Equatable>(domain: C, value: C.Generator.Element) -> C.Index?","comment":"Returns the first index where `value` appears in `domain` or `nil` if\n`value` is not found.\n\nComplexity: O(\\ `countElements(domain)`\\ )"},{"kind":"func","name":"first","slug":"first","generic":{"line":"C : CollectionType","types":["CollectionType"]},"params":[{"name":"x","type":"C","note":"","default":"","types":[]}],"ret":{"line":"C.Generator.Element?","types":["Element","Generator"]},"note":"","attr":"","line":"func first<C : CollectionType>(x: C) -> C.Generator.Element?","comment":"Returns the first element of `x`, or `nil` if `x` is empty."},{"kind":"func","name":"getVaList","slug":"getVaList","generic":{},"params":[{"name":"args","type":"[CVarArgType]","note":"","default":"","types":["CVarArgType"]}],"ret":{"line":"CVaListPointer","types":["CVaListPointer"]},"note":"","attr":"","line":"func getVaList(args: [CVarArgType]) -> CVaListPointer","comment":"Returns a `CVaListPointer` built from `args` that's backed by\nautoreleased storage.\n\n.. Warning:: This function is best avoided in favor of\n   `withVaList`, but occasionally (i.e. in a `class` initializer) you\n   may find that the language rules don't allow you to use\n   `withVaList` as intended."},{"kind":"func","name":"indices","slug":"indices","generic":{"line":"C : CollectionType","types":["CollectionType"]},"params":[{"name":"x","type":"C","note":"","default":"","types":[]}],"ret":{"line":"Range<C.Index>","types":["Index","Range"]},"note":"","attr":"","line":"func indices<C : CollectionType>(x: C) -> Range<C.Index>","comment":"Return the range of `x` 's valid index values.\n\nThe result's `endIndex` is the same as that of `x`.  Because\n`Range` is half-open, iterating the values of the result produces\nall valid subscript arguments for `x`, omitting its `endIndex`."},{"kind":"func","name":"insert","slug":"insert","generic":{"line":"C : RangeReplaceableCollectionType","types":["RangeReplaceableCollectionType"]},"params":[{"name":"x","type":"C","note":"inout","default":"","types":[]},{"name":"newElement","type":"C.Generator.Element","note":"","default":"","types":["Element","Generator"]},{"name":"i","type":"C.Index","note":"atIndex","default":"","types":["Index"]}],"ret":{},"note":"","attr":"","line":"func insert<C : RangeReplaceableCollectionType>(inout x: C, newElement: C.Generator.Element, atIndex i: C.Index)","comment":"Insert `newElement` into `x` at index `i`.\n\nInvalidates all indices with respect to `x`.\n\nComplexity: O(\\ `countElements(x)`\\ )."},{"kind":"func","name":"isEmpty","slug":"isEmpty","generic":{"line":"C : CollectionType","types":["CollectionType"]},"params":[{"name":"x","type":"C","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func isEmpty<C : CollectionType>(x: C) -> Bool","comment":"Returns `true` iff `x` is empty."},{"kind":"func","name":"join","slug":"join","generic":{"line":"C : ExtensibleCollectionType, S : SequenceType where C == C","types":["ExtensibleCollectionType","SequenceType"]},"params":[{"name":"separator","type":"C","note":"","default":"","types":[]},{"name":"elements","type":"S","note":"","default":"","types":[]}],"ret":{"line":"C","types":[]},"note":"","attr":"","line":"func join<C : ExtensibleCollectionType, S : SequenceType where C == C>(separator: C, elements: S) -> C","comment":"Creates and returns a collection of type `C` that is the result of\ninterposing a given separator between the elements of the sequence\n`elements`.\n\nFor example, this code excerpt writes \"``here be dragons``\" to the standard\noutput::\n\n  println(join(\" \", [ \"here\", \"be\", \"dragons\" ]))"},{"kind":"func","name":"last","slug":"last","generic":{"line":"C : CollectionType where C.Index : BidirectionalIndexType","types":["BidirectionalIndexType","CollectionType","Index"]},"params":[{"name":"x","type":"C","note":"","default":"","types":[]}],"ret":{"line":"C.Generator.Element?","types":["Element","Generator"]},"note":"","attr":"","line":"func last<C : CollectionType where C.Index : BidirectionalIndexType>(x: C) -> C.Generator.Element?","comment":"Returns the last element of `x`, or `nil` if `x` is empty."},{"kind":"func","name":"lazy","slug":"lazy","generic":{"line":"S : CollectionType where S.Index : ForwardIndexType","types":["CollectionType","ForwardIndexType","Index"]},"params":[{"name":"s","type":"S","note":"","default":"","types":[]}],"ret":{"line":"LazyForwardCollection<S>","types":["LazyForwardCollection"]},"note":"","attr":"","line":"func lazy<S : CollectionType where S.Index : ForwardIndexType>(s: S) -> LazyForwardCollection<S>","comment":"Augment `s` with lazy methods such as `map`, `filter`, etc."},{"kind":"func","name":"lazy","slug":"lazy","generic":{"line":"S : CollectionType where S.Index : BidirectionalIndexType","types":["BidirectionalIndexType","CollectionType","Index"]},"params":[{"name":"s","type":"S","note":"","default":"","types":[]}],"ret":{"line":"LazyBidirectionalCollection<S>","types":["LazyBidirectionalCollection"]},"note":"","attr":"","line":"func lazy<S : CollectionType where S.Index : BidirectionalIndexType>(s: S) -> LazyBidirectionalCollection<S>","comment":"Augment `s` with lazy methods such as `map`, `filter`, etc."},{"kind":"func","name":"lazy","slug":"lazy","generic":{"line":"S : CollectionType where S.Index : RandomAccessIndexType","types":["CollectionType","Index","RandomAccessIndexType"]},"params":[{"name":"s","type":"S","note":"","default":"","types":[]}],"ret":{"line":"LazyRandomAccessCollection<S>","types":["LazyRandomAccessCollection"]},"note":"","attr":"","line":"func lazy<S : CollectionType where S.Index : RandomAccessIndexType>(s: S) -> LazyRandomAccessCollection<S>","comment":"Augment `s` with lazy methods such as `map`, `filter`, etc."},{"kind":"func","name":"lazy","slug":"lazy","generic":{"line":"S : SequenceType","types":["SequenceType"]},"params":[{"name":"s","type":"S","note":"","default":"","types":[]}],"ret":{"line":"LazySequence<S>","types":["LazySequence"]},"note":"","attr":"","line":"func lazy<S : SequenceType>(s: S) -> LazySequence<S>","comment":"Augment `s` with lazy methods such as `map`, `filter`, etc."},{"kind":"func","name":"lexicographicalCompare","slug":"lexicographicalCompare","generic":{"line":"S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element","types":["Element","Generator","S1","S2","SequenceType"]},"params":[{"name":"a1","type":"S1","note":"","default":"","types":["S1"]},{"name":"a2","type":"S2","note":"","default":"","types":["S2"]},{"name":"less","type":"(S1.Generator.Element, S1.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator","S1"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func lexicographicalCompare<S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element>(a1: S1, a2: S2, less: (S1.Generator.Element, S1.Generator.Element) -> Bool) -> Bool","comment":"Return true iff `a1` precedes `a2` in a lexicographical (\"dictionary\")\nordering, using `less` as the comparison between elements."},{"kind":"func","name":"lexicographicalCompare","slug":"lexicographicalCompare","generic":{"line":"S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element, S1.Generator.Element : Comparable","types":["Comparable","Element","Generator","S1","S2","SequenceType"]},"params":[{"name":"a1","type":"S1","note":"","default":"","types":["S1"]},{"name":"a2","type":"S2","note":"","default":"","types":["S2"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func lexicographicalCompare<S1 : SequenceType, S2 : SequenceType where S1.Generator.Element == S1.Generator.Element, S1.Generator.Element : Comparable>(a1: S1, a2: S2) -> Bool","comment":"Return true iff a1 precedes a2 in a lexicographical (\"dictionary\")\nordering, using \"<\" as the comparison between elements."},{"kind":"func","name":"map","slug":"map","generic":{"line":"T, U","types":[]},"params":[{"name":"x","type":"T?","note":"","default":"","types":[]},{"name":"f","type":"(T) -> U","note":"","default":"","types":[]}],"ret":{"line":"U?","types":[]},"note":"","attr":"","line":"func map<T, U>(x: T?, f: (T) -> U) -> U?","comment":"Haskell's fmap for Optionals."},{"kind":"func","name":"map","slug":"map","generic":{"line":"C : CollectionType, T","types":["CollectionType"]},"params":[{"name":"source","type":"C","note":"","default":"","types":[]},{"name":"transform","type":"(C.Generator.Element) -> T","note":"","default":"","types":["Element","Generator"]}],"ret":{"line":"[T]","types":[]},"note":"","attr":"","line":"func map<C : CollectionType, T>(source: C, transform: (C.Generator.Element) -> T) -> [T]","comment":"Return an `Array` containing the results of mapping `transform`\nover `source`."},{"kind":"func","name":"map","slug":"map","generic":{"line":"S : SequenceType, T","types":["SequenceType"]},"params":[{"name":"source","type":"S","note":"","default":"","types":[]},{"name":"transform","type":"(S.Generator.Element) -> T","note":"","default":"","types":["Element","Generator"]}],"ret":{"line":"[T]","types":[]},"note":"","attr":"","line":"func map<S : SequenceType, T>(source: S, transform: (S.Generator.Element) -> T) -> [T]","comment":"Return an `Array` containing the results of mapping `transform`\nover `source`."},{"kind":"func","name":"max","slug":"max","generic":{"line":"T : Comparable","types":["Comparable"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"y","type":"T","note":"","default":"","types":[]},{"name":"z","type":"T","note":"","default":"","types":[]},{"name":"rest","type":"T...","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func max<T : Comparable>(x: T, y: T, z: T, rest: T...) -> T","comment":"Return the greatest argument passed"},{"kind":"func","name":"max","slug":"max","generic":{"line":"T : Comparable","types":["Comparable"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"y","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func max<T : Comparable>(x: T, y: T) -> T","comment":"Return the greater of `x` and `y`"},{"kind":"func","name":"maxElement","slug":"maxElement","generic":{"line":"R : SequenceType where R.Generator.Element : Comparable","types":["Comparable","Element","Generator","SequenceType"]},"params":[{"name":"elements","type":"R","note":"","default":"","types":[]}],"ret":{"line":"R.Generator.Element","types":["Element","Generator"]},"note":"","attr":"","line":"func maxElement<R : SequenceType where R.Generator.Element : Comparable>(elements: R) -> R.Generator.Element","comment":"Returns the maximum element in `elements`.  Requires:\n`elements` is non-empty. O(countElements(elements))"},{"kind":"func","name":"min","slug":"min","generic":{"line":"T : Comparable","types":["Comparable"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"y","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func min<T : Comparable>(x: T, y: T) -> T","comment":"Return the lesser of `x` and `y`"},{"kind":"func","name":"min","slug":"min","generic":{"line":"T : Comparable","types":["Comparable"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"y","type":"T","note":"","default":"","types":[]},{"name":"z","type":"T","note":"","default":"","types":[]},{"name":"rest","type":"T...","note":"","default":"","types":[]}],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func min<T : Comparable>(x: T, y: T, z: T, rest: T...) -> T","comment":"Return the least argument passed"},{"kind":"func","name":"minElement","slug":"minElement","generic":{"line":"R : SequenceType where R.Generator.Element : Comparable","types":["Comparable","Element","Generator","SequenceType"]},"params":[{"name":"elements","type":"R","note":"","default":"","types":[]}],"ret":{"line":"R.Generator.Element","types":["Element","Generator"]},"note":"","attr":"","line":"func minElement<R : SequenceType where R.Generator.Element : Comparable>(elements: R) -> R.Generator.Element","comment":"Returns the minimum element in `elements`.  Requires:\n`elements` is non-empty. O(countElements(elements))"},{"kind":"func","name":"numericCast","slug":"numericCast","generic":{"line":"T : _UnsignedIntegerType, U : _SignedIntegerType","types":["_SignedIntegerType","_UnsignedIntegerType"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"U","types":[]},"note":"","attr":"","line":"func numericCast<T : _UnsignedIntegerType, U : _SignedIntegerType>(x: T) -> U","comment":"Convert `x` to type `U`, trapping on overflow in -Onone and -O\nbuilds.\n\nTypically used to do conversion to any contextually-deduced\ninteger type::\n\n  func f(x: Int32) {}\n  func g(x: UInt64) { f(numericCast(x)) }"},{"kind":"func","name":"numericCast","slug":"numericCast","generic":{"line":"T : _SignedIntegerType, U : _UnsignedIntegerType","types":["_SignedIntegerType","_UnsignedIntegerType"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"U","types":[]},"note":"","attr":"","line":"func numericCast<T : _SignedIntegerType, U : _UnsignedIntegerType>(x: T) -> U","comment":"Convert `x` to type `U`, trapping on overflow in -Onone and -O\nbuilds.\n\nTypically used to do conversion to any contextually-deduced\ninteger type::\n\n  func f(x: UInt32) {}\n  func g(x: Int64) { f(numericCast(x)) }"},{"kind":"func","name":"numericCast","slug":"numericCast","generic":{"line":"T : _UnsignedIntegerType, U : _UnsignedIntegerType","types":["_UnsignedIntegerType"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"U","types":[]},"note":"","attr":"","line":"func numericCast<T : _UnsignedIntegerType, U : _UnsignedIntegerType>(x: T) -> U","comment":"Convert `x` to type `U`, trapping on overflow in -Onone and -O\nbuilds.\n\nTypically used to do conversion to any contextually-deduced\ninteger type::\n\n  func f(x: UInt32) {}\n  func g(x: UInt64) { f(numericCast(x)) }"},{"kind":"func","name":"numericCast","slug":"numericCast","generic":{"line":"T : _SignedIntegerType, U : _SignedIntegerType","types":["_SignedIntegerType"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"U","types":[]},"note":"","attr":"","line":"func numericCast<T : _SignedIntegerType, U : _SignedIntegerType>(x: T) -> U","comment":"Convert `x` to type `U`, trapping on overflow in -Onone and -O\nbuilds.\n\nTypically used to do conversion to any contextually-deduced\ninteger type::\n\n  func f(x: Int32) {}\n  func g(x: Int64) { f(numericCast(x)) }"},{"kind":"func","name":"overlaps","slug":"overlaps","generic":{"line":"I0 : IntervalType, I1 : IntervalType where I0.Bound == I0.Bound","types":["Bound","I0","I1","IntervalType"]},"params":[{"name":"lhs","type":"I0","note":"","default":"","types":["I0"]},{"name":"rhs","type":"I1","note":"","default":"","types":["I1"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func overlaps<I0 : IntervalType, I1 : IntervalType where I0.Bound == I0.Bound>(lhs: I0, rhs: I1) -> Bool","comment":"Returns `true` if `lhs` and `rhs` have a non-empty intersection"},{"kind":"func","name":"partition","slug":"partition","generic":{"line":"C : MutableCollectionType where C.Index : RandomAccessIndexType","types":["Index","MutableCollectionType","RandomAccessIndexType"]},"params":[{"name":"elements","type":"C","note":"inout","default":"","types":[]},{"name":"range","type":"Range<C.Index>","note":"","default":"","types":["Index","Range"]},{"name":"isOrderedBefore","type":"(C.Generator.Element, C.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator"]}],"ret":{"line":"C.Index","types":["Index"]},"note":"","attr":"","line":"func partition<C : MutableCollectionType where C.Index : RandomAccessIndexType>(inout elements: C, range: Range<C.Index>, isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool) -> C.Index","comment":"Re-order the given `range` of `elements` and return a pivot index\n*p*.  Postcondition: for all *i* in `range.startIndex..<`\\ *p*,\nand *j* in *p*\\ `..<range.endIndex`, `less(elements[`\\ *i*\\ `],\nelements[`\\ *j*\\ `]) && !less(elements[`\\ *j*\\ `], elements[`\\\n*p*\\ `])`.  Only returns `range.endIndex` when `elements` is\nempty.\nRequires: `isOrderedBefore` is a `strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover `elements`."},{"kind":"func","name":"partition","slug":"partition","generic":{"line":"C : MutableCollectionType where C.Index : RandomAccessIndexType, C.Generator.Element : Comparable","types":["Comparable","Element","Generator","Index","MutableCollectionType","RandomAccessIndexType"]},"params":[{"name":"elements","type":"C","note":"inout","default":"","types":[]},{"name":"range","type":"Range<C.Index>","note":"","default":"","types":["Index","Range"]}],"ret":{"line":"C.Index","types":["Index"]},"note":"","attr":"","line":"func partition<C : MutableCollectionType where C.Index : RandomAccessIndexType, C.Generator.Element : Comparable>(inout elements: C, range: Range<C.Index>) -> C.Index","comment":"Re-order the given `range` of `elements` and return a pivot index\n*p*.  Postcondition: for all *i* in `range.startIndex..<`\\ *p*,\nand *j* in *p*\\ `..<range.endIndex`, `less(elements[`\\ *i*\\ `],\nelements[`\\ *j*\\ `]) && !less(elements[`\\ *j*\\ `], elements[`\\\n*p*\\ `])`.  Only returns `range.endIndex` when `elements` is\nempty.\nRequires: The less-than operator (`func <`) defined in the `Comparable`\nconformance is a `strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover `elements`."},{"kind":"func","name":"precondition","slug":"precondition","generic":{},"params":[{"name":"condition","type":"@autoclosure () -> Bool","note":"","default":"","types":["Bool"]},{"name":"message","type":"@autoclosure () -> String","note":"_","default":"default","types":["String"]},{"name":"file","type":"StaticString","note":"","default":"default","types":["StaticString"]},{"name":"line","type":"UWord","note":"","default":"default","types":["UWord"]}],"ret":{},"note":"","attr":"","line":"func precondition(condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = default, line: UWord = default)","comment":"Ensure that the `condition` is true.\n\nIf the `condition` is false, in debug and release modes the program stops.\n\nIn unchecked mode the optimizer can assume that the `condition` is true."},{"kind":"func","name":"preconditionFailure","slug":"preconditionFailure","generic":{},"params":[{"name":"message","type":"@autoclosure () -> String","note":"_","default":"default","types":["String"]},{"name":"file","type":"StaticString","note":"","default":"default","types":["StaticString"]},{"name":"line","type":"UWord","note":"","default":"default","types":["UWord"]}],"ret":{},"note":"","attr":"@noreturn ","line":"func preconditionFailure(_ message: @autoclosure () -> String = default, file: StaticString = default, line: UWord = default)","comment":"A fatal error occurred and program execution should stop in debug mode and\nin optimized mode.  In unchecked builds this is a noop, but the\noptimizer can still assume that the call is unreachable."},{"kind":"func","name":"prefix","slug":"prefix","generic":{"line":"S : Sliceable","types":["Sliceable"]},"params":[{"name":"s","type":"S","note":"","default":"","types":[]},{"name":"maxLength","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"S.SubSlice","types":["SubSlice"]},"note":"","attr":"","line":"func prefix<S : Sliceable>(s: S, maxLength: Int) -> S.SubSlice","comment":"Return a slice, up to `maxLength` in length, containing the\ninitial elements of `s`.\n\nIf `maxLength` exceeds `countElements(s)`, the result contains all\nthe elements of `s`.\n\nComplexity: O(1)+K when `S.Index` conforms to\n`RandomAccessIndexType` and O(N)+K otherwise, where K is the cost\nof slicing `s`."},{"kind":"func","name":"print","slug":"print","generic":{"line":"T","types":[]},"params":[{"name":"object","type":"T","note":"","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func print<T>(object: T)","comment":"Writes the textual representation of `object` into the standard output.\n\nThe textual representation is obtained from the `object` using its protocol\nconformances, in the following order of preference: `Streamable`,\n`Printable`, `DebugPrintable`.\n\nDo not overload this function for your type.  Instead, adopt one of the\nprotocols mentioned above."},{"kind":"func","name":"print","slug":"print","generic":{"line":"T, TargetStream : OutputStreamType","types":["OutputStreamType","TargetStream"]},"params":[{"name":"object","type":"T","note":"","default":"","types":[]},{"name":"target","type":"TargetStream","note":"inout","default":"","types":["TargetStream"]}],"ret":{},"note":"","attr":"","line":"func print<T, TargetStream : OutputStreamType>(object: T, inout target: TargetStream)","comment":"Writes the textual representation of `object` into the stream `target`.\n\nThe textual representation is obtained from the `object` using its protocol\nconformances, in the following order of preference: `Streamable`,\n`Printable`, `DebugPrintable`.\n\nDo not overload this function for your type.  Instead, adopt one of the\nprotocols mentioned above."},{"kind":"func","name":"println","slug":"println","generic":{},"params":[],"ret":{},"note":"","attr":"","line":"func println()","comment":"Writes a single newline character into the standard output."},{"kind":"func","name":"println","slug":"println","generic":{"line":"T","types":[]},"params":[{"name":"object","type":"T","note":"","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func println<T>(object: T)","comment":"Writes the textual representation of `object` and a newline character into\nthe standard output.\n\nThe textual representation is obtained from the `object` using its protocol\nconformances, in the following order of preference: `Streamable`,\n`Printable`, `DebugPrintable`.\n\nDo not overload this function for your type.  Instead, adopt one of the\nprotocols mentioned above."},{"kind":"func","name":"println","slug":"println","generic":{"line":"T, TargetStream : OutputStreamType","types":["OutputStreamType","TargetStream"]},"params":[{"name":"object","type":"T","note":"","default":"","types":[]},{"name":"target","type":"TargetStream","note":"inout","default":"","types":["TargetStream"]}],"ret":{},"note":"","attr":"","line":"func println<T, TargetStream : OutputStreamType>(object: T, inout target: TargetStream)","comment":"Writes the textual representation of `object` and a newline character into\nthe stream `target`.\n\nThe textual representation is obtained from the `object` using its protocol\nconformances, in the following order of preference: `Streamable`,\n`Printable`, `DebugPrintable`.\n\nDo not overload this function for your type.  Instead, adopt one of the\nprotocols mentioned above."},{"kind":"func","name":"reduce","slug":"reduce","generic":{"line":"S : SequenceType, U","types":["SequenceType"]},"params":[{"name":"sequence","type":"S","note":"","default":"","types":[]},{"name":"initial","type":"U","note":"","default":"","types":[]},{"name":"combine","type":"(U, S.Generator.Element) -> U","note":"","default":"","types":["Element","Generator"]}],"ret":{"line":"U","types":[]},"note":"","attr":"","line":"func reduce<S : SequenceType, U>(sequence: S, initial: U, combine: (U, S.Generator.Element) -> U) -> U","comment":"Return the result of repeatedly calling `combine` with an\naccumulated value initialized to `initial` and each element of\n`sequence`, in turn."},{"kind":"func","name":"reflect","slug":"reflect","generic":{"line":"T","types":[]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func reflect<T>(x: T) -> MirrorType","comment":"Produce a mirror for any value. If the value's type conforms to Reflectable,\ninvoke its getMirror() method; otherwise, fall back to an implementation\nin the runtime that structurally reflects values of any type."},{"kind":"func","name":"removeAll","slug":"removeAll","generic":{"line":"C : RangeReplaceableCollectionType","types":["RangeReplaceableCollectionType"]},"params":[{"name":"x","type":"C","note":"inout","default":"","types":[]},{"name":"keepCapacity","type":"Bool","note":"","default":"default","types":["Bool"]}],"ret":{},"note":"","attr":"","line":"func removeAll<C : RangeReplaceableCollectionType>(inout x: C, keepCapacity: Bool = default)","comment":"Remove all elements from `x`\n\nInvalidates all indices with respect to `x`.\n\n:param: `keepCapacity`, if `true`, is a non-binding request to\n   avoid releasing storage, which can be a useful optimization\n   when `x` is going to be grown again.\n\nComplexity: O(\\ `countElements(x)`\\ )."},{"kind":"func","name":"removeAtIndex","slug":"removeAtIndex","generic":{"line":"C : RangeReplaceableCollectionType","types":["RangeReplaceableCollectionType"]},"params":[{"name":"x","type":"C","note":"inout","default":"","types":[]},{"name":"index","type":"C.Index","note":"","default":"","types":["Index"]}],"ret":{"line":"C.Generator.Element","types":["Element","Generator"]},"note":"","attr":"","line":"func removeAtIndex<C : RangeReplaceableCollectionType>(inout x: C, index: C.Index) -> C.Generator.Element","comment":"Remove from `x` and return the element at index `i` \n\nInvalidates all indices with respect to `x`.\n\nComplexity: O(\\ `countElements(x)`\\ )."},{"kind":"func","name":"removeLast","slug":"removeLast","generic":{"line":"C : RangeReplaceableCollectionType where C.Index : BidirectionalIndexType","types":["BidirectionalIndexType","Index","RangeReplaceableCollectionType"]},"params":[{"name":"x","type":"C","note":"inout","default":"","types":[]}],"ret":{"line":"C.Generator.Element","types":["Element","Generator"]},"note":"","attr":"","line":"func removeLast<C : RangeReplaceableCollectionType where C.Index : BidirectionalIndexType>(inout x: C) -> C.Generator.Element","comment":"Remove an element from the end of `x`  in O(1).\nRequires: `x` is nonempty"},{"kind":"func","name":"removeRange","slug":"removeRange","generic":{"line":"C : RangeReplaceableCollectionType","types":["RangeReplaceableCollectionType"]},"params":[{"name":"x","type":"C","note":"inout","default":"","types":[]},{"name":"subRange","type":"Range<C.Index>","note":"","default":"","types":["Index","Range"]}],"ret":{},"note":"","attr":"","line":"func removeRange<C : RangeReplaceableCollectionType>(inout x: C, subRange: Range<C.Index>)","comment":"Remove from `x` the indicated `subRange` of elements\n\nInvalidates all indices with respect to `x`.\n\nComplexity: O(\\ `countElements(x)`\\ )."},{"kind":"func","name":"reverse","slug":"reverse","generic":{"line":"C : CollectionType where C.Index : BidirectionalIndexType","types":["BidirectionalIndexType","CollectionType","Index"]},"params":[{"name":"source","type":"C","note":"","default":"","types":[]}],"ret":{"line":"[C.Generator.Element]","types":["Element","Generator"]},"note":"","attr":"","line":"func reverse<C : CollectionType where C.Index : BidirectionalIndexType>(source: C) -> [C.Generator.Element]","comment":"Return an `Array` containing the elements of `source` in reverse\norder."},{"kind":"func","name":"sizeof","slug":"sizeof","generic":{"line":"T","types":[]},"params":[{"name":"_","type":"T.Type","note":"","default":"","types":["Type"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func sizeof<T>(_: T.Type) -> Int","comment":"Returns the contiguous memory footprint of `T`.\n\nDoes not include any dynamically-allocated or \"remote\" storage.\nIn particular, `sizeof(X.self)`, when `X` is a class type, is the\nsame regardless of how many stored properties `X` has."},{"kind":"func","name":"sizeofValue","slug":"sizeofValue","generic":{"line":"T","types":[]},"params":[{"name":"_","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func sizeofValue<T>(_: T) -> Int","comment":"Returns the contiguous memory footprint of  `T`.\n\nDoes not include any dynamically-allocated or \"remote\" storage.\nIn particular, `sizeof(a)`, when `a` is a class instance, is the\nsame regardless of how many stored properties `a` has."},{"kind":"func","name":"sort","slug":"sort","generic":{"line":"T : Comparable","types":["Comparable"]},"params":[{"name":"array","type":"ContiguousArray<T>","note":"inout","default":"","types":["ContiguousArray"]}],"ret":{},"note":"","attr":"","line":"func sort<T : Comparable>(inout array: ContiguousArray<T>)","comment":""},{"kind":"func","name":"sort","slug":"sort","generic":{"line":"T : Comparable","types":["Comparable"]},"params":[{"name":"array","type":"[T]","note":"inout","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func sort<T : Comparable>(inout array: [T])","comment":""},{"kind":"func","name":"sort","slug":"sort","generic":{"line":"C : MutableCollectionType where C.Index : RandomAccessIndexType, C.Generator.Element : Comparable","types":["Comparable","Element","Generator","Index","MutableCollectionType","RandomAccessIndexType"]},"params":[{"name":"collection","type":"C","note":"inout","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func sort<C : MutableCollectionType where C.Index : RandomAccessIndexType, C.Generator.Element : Comparable>(inout collection: C)","comment":"Sort `collection` in-place.\n\nThe sorting algorithm is not stable (can change the relative order of\nelements that compare equal).\n\nRequires: The less-than operator (`func <`) defined in the `Comparable`\nconformance is a `strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover `elements`."},{"kind":"func","name":"sort","slug":"sort","generic":{"line":"T","types":[]},"params":[{"name":"array","type":"ContiguousArray<T>","note":"inout","default":"","types":["ContiguousArray"]},{"name":"isOrderedBefore","type":"(T, T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{},"note":"","attr":"","line":"func sort<T>(inout array: ContiguousArray<T>, isOrderedBefore: (T, T) -> Bool)","comment":""},{"kind":"func","name":"sort","slug":"sort","generic":{"line":"T","types":[]},"params":[{"name":"array","type":"[T]","note":"inout","default":"","types":[]},{"name":"isOrderedBefore","type":"(T, T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{},"note":"","attr":"","line":"func sort<T>(inout array: [T], isOrderedBefore: (T, T) -> Bool)","comment":""},{"kind":"func","name":"sort","slug":"sort","generic":{"line":"C : MutableCollectionType where C.Index : RandomAccessIndexType","types":["Index","MutableCollectionType","RandomAccessIndexType"]},"params":[{"name":"collection","type":"C","note":"inout","default":"","types":[]},{"name":"isOrderedBefore","type":"(C.Generator.Element, C.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator"]}],"ret":{},"note":"","attr":"","line":"func sort<C : MutableCollectionType where C.Index : RandomAccessIndexType>(inout collection: C, isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool)","comment":"Sort `collection` in-place according to `isOrderedBefore`.\n\nThe sorting algorithm is not stable (can change the relative order of\nelements for which `isOrderedBefore` does not establish an order).\n\nRequires: `isOrderedBefore` is a `strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover `elements`."},{"kind":"func","name":"sorted","slug":"sorted","generic":{"line":"C : SequenceType where C.Generator.Element : Comparable","types":["Comparable","Element","Generator","SequenceType"]},"params":[{"name":"source","type":"C","note":"","default":"","types":[]}],"ret":{"line":"[C.Generator.Element]","types":["Element","Generator"]},"note":"","attr":"","line":"func sorted<C : SequenceType where C.Generator.Element : Comparable>(source: C) -> [C.Generator.Element]","comment":"Return an `Array` containing the sorted elements of `source`{according}.\n\nThe sorting algorithm is not stable (can change the relative order of\nelements that compare equal).\n\nRequires: The less-than operator (`func <`) defined in the `Comparable`\nconformance is a `strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover `elements`."},{"kind":"func","name":"sorted","slug":"sorted","generic":{"line":"C : SequenceType","types":["SequenceType"]},"params":[{"name":"source","type":"C","note":"","default":"","types":[]},{"name":"isOrderedBefore","type":"(C.Generator.Element, C.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator"]}],"ret":{"line":"[C.Generator.Element]","types":["Element","Generator"]},"note":"","attr":"","line":"func sorted<C : SequenceType>(source: C, isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool) -> [C.Generator.Element]","comment":"Return an `Array` containing the sorted elements of `source`{according}.\n\nThe sorting algorithm is not stable (can change the relative order of\nelements for which `isOrderedBefore` does not establish an order).\n\nRequires: `isOrderedBefore` is a `strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover `elements`."},{"kind":"func","name":"splice","slug":"splice","generic":{"line":"C : RangeReplaceableCollectionType, S : CollectionType where S.Generator.Element == S.Generator.Element","types":["CollectionType","Element","Generator","RangeReplaceableCollectionType"]},"params":[{"name":"x","type":"C","note":"inout","default":"","types":[]},{"name":"newElements","type":"S","note":"","default":"","types":[]},{"name":"i","type":"C.Index","note":"atIndex","default":"","types":["Index"]}],"ret":{},"note":"","attr":"","line":"func splice<C : RangeReplaceableCollectionType, S : CollectionType where S.Generator.Element == S.Generator.Element>(inout x: C, newElements: S, atIndex i: C.Index)","comment":"Insert `newElements` into `x` at index `i`\n\nInvalidates all indices with respect to `x`.\n\nComplexity: O(\\ `countElements(x) + countElements(newElements)`\\ )."},{"kind":"func","name":"split","slug":"split","generic":{"line":"S : Sliceable, R : BooleanType","types":["BooleanType","Sliceable"]},"params":[{"name":"elements","type":"S","note":"","default":"","types":[]},{"name":"isSeparator","type":"(S.Generator.Element) -> R","note":"","default":"","types":["Element","Generator"]},{"name":"maxSplit","type":"Int","note":"","default":"default","types":["Int"]},{"name":"allowEmptySlices","type":"Bool","note":"","default":"default","types":["Bool"]}],"ret":{"line":"[S.SubSlice]","types":["SubSlice"]},"note":"","attr":"","line":"func split<S : Sliceable, R : BooleanType>(elements: S, isSeparator: (S.Generator.Element) -> R, maxSplit: Int = default, allowEmptySlices: Bool = default) -> [S.SubSlice]","comment":"Return the result of slicing `elements` into sub-sequences that\ndon't contain elements satisfying the predicate `isSeparator`.\n\n:param: maxSplit the maximum number of slices to return, minus 1.\nIf `maxSplit + 1` slices would otherwise be returned, the\nalgorithm stops splitting and returns a suffix of `elements`\n\n:param: allowEmptySlices if true, an empty slice is produced in\nthe result for each pair of consecutive "},{"kind":"func","name":"startsWith","slug":"startsWith","generic":{"line":"S0 : SequenceType, S1 : SequenceType where S0.Generator.Element == S0.Generator.Element","types":["Element","Generator","S0","S1","SequenceType"]},"params":[{"name":"s","type":"S0","note":"","default":"","types":["S0"]},{"name":"prefix","type":"S1","note":"","default":"","types":["S1"]},{"name":"isEquivalent","type":"(S0.Generator.Element, S0.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator","S0"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func startsWith<S0 : SequenceType, S1 : SequenceType where S0.Generator.Element == S0.Generator.Element>(s: S0, prefix: S1, isEquivalent: (S0.Generator.Element, S0.Generator.Element) -> Bool) -> Bool","comment":"Return true iff `s` begins with elements equivalent to those of\n`prefix`, using `isEquivalent` as the equivalence test.  Requires:\n`isEquivalent` is an `equivalence relation\n<http://en.wikipedia.org/wiki/Equivalence_relation>`_"},{"kind":"func","name":"startsWith","slug":"startsWith","generic":{"line":"S0 : SequenceType, S1 : SequenceType where S0.Generator.Element == S0.Generator.Element, S0.Generator.Element : Equatable","types":["Element","Equatable","Generator","S0","S1","SequenceType"]},"params":[{"name":"s","type":"S0","note":"","default":"","types":["S0"]},{"name":"prefix","type":"S1","note":"","default":"","types":["S1"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func startsWith<S0 : SequenceType, S1 : SequenceType where S0.Generator.Element == S0.Generator.Element, S0.Generator.Element : Equatable>(s: S0, prefix: S1) -> Bool","comment":"Return true iff the the initial elements of `s` are equal to `prefix`."},{"kind":"func","name":"stride","slug":"stride","generic":{"line":"T : Strideable","types":["Strideable"]},"params":[{"name":"start","type":"T","note":"from","default":"","types":[]},{"name":"end","type":"T","note":"through","default":"","types":[]},{"name":"stride","type":"T.Stride","note":"by","default":"","types":["Stride"]}],"ret":{"line":"StrideThrough<T>","types":["StrideThrough"]},"note":"","attr":"","line":"func stride<T : Strideable>(from start: T, through end: T, by stride: T.Stride) -> StrideThrough<T>","comment":"Return the sequence of values (`start`, `start + stride`, `start +\nstride + stride`, ... *last*) where *last* is the last value in\nthe progression less than or equal to `end`.\n\n.. Note:: There is no guarantee that `end` is an element of the\n     sequence."},{"kind":"func","name":"stride","slug":"stride","generic":{"line":"T : Strideable","types":["Strideable"]},"params":[{"name":"start","type":"T","note":"from","default":"","types":[]},{"name":"end","type":"T","note":"to","default":"","types":[]},{"name":"stride","type":"T.Stride","note":"by","default":"","types":["Stride"]}],"ret":{"line":"StrideTo<T>","types":["StrideTo"]},"note":"","attr":"","line":"func stride<T : Strideable>(from start: T, to end: T, by stride: T.Stride) -> StrideTo<T>","comment":"Return the sequence of values (`start`, `start + stride`, `start +\nstride + stride`, ... *last*) where *last* is the last value in\nthe progression that is less than `end`."},{"kind":"func","name":"strideof","slug":"strideof","generic":{"line":"T","types":[]},"params":[{"name":"_","type":"T.Type","note":"","default":"","types":["Type"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func strideof<T>(_: T.Type) -> Int","comment":"Returns the least possible interval between distinct instances of\n`T` in memory.  The result is always positive."},{"kind":"func","name":"strideofValue","slug":"strideofValue","generic":{"line":"T","types":[]},"params":[{"name":"_","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func strideofValue<T>(_: T) -> Int","comment":"Returns the least possible interval between distinct instances of\n`T` in memory.  The result is always positive."},{"kind":"func","name":"suffix","slug":"suffix","generic":{"line":"S : Sliceable where S.Index : BidirectionalIndexType","types":["BidirectionalIndexType","Index","Sliceable"]},"params":[{"name":"s","type":"S","note":"","default":"","types":[]},{"name":"maxLength","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"S.SubSlice","types":["SubSlice"]},"note":"","attr":"","line":"func suffix<S : Sliceable where S.Index : BidirectionalIndexType>(s: S, maxLength: Int) -> S.SubSlice","comment":"Return a slice, up to `maxLength` in length, containing the\nfinal elements of `s`.\n\nIf `maxLength` exceeds `countElements(s)`, the result contains all\nthe elements of `s`.\n\nComplexity: O(1)+K when `S.Index` conforms to\n`RandomAccessIndexType` and O(N)+K otherwise, where K is the cost\nof slicing `s`."},{"kind":"func","name":"swap","slug":"swap","generic":{"line":"T","types":[]},"params":[{"name":"a","type":"T","note":"inout","default":"","types":[]},{"name":"b","type":"T","note":"inout","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func swap<T>(inout a: T, inout b: T)","comment":"Exchange the values of `a` and `b`"},{"kind":"func","name":"toDebugString","slug":"toDebugString","generic":{"line":"T","types":[]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func toDebugString<T>(x: T) -> String","comment":"Returns the result of `debugPrint`\\ 'ing `x` into a `String`"},{"kind":"func","name":"toString","slug":"toString","generic":{"line":"T","types":[]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func toString<T>(x: T) -> String","comment":"Returns the result of `print`\\ 'ing `x` into a `String`"},{"kind":"func","name":"transcode","slug":"transcode","generic":{"line":"Input : GeneratorType, Output : SinkType, InputEncoding : UnicodeCodecType, OutputEncoding : UnicodeCodecType where InputEncoding.CodeUnit == InputEncoding.CodeUnit, OutputEncoding.CodeUnit == OutputEncoding.CodeUnit","types":["CodeUnit","GeneratorType","Input","InputEncoding","Output","OutputEncoding","SinkType","UnicodeCodecType"]},"params":[{"name":"inputEncoding","type":"InputEncoding.Type","note":"","default":"","types":["InputEncoding","Type"]},{"name":"outputEncoding","type":"OutputEncoding.Type","note":"","default":"","types":["OutputEncoding","Type"]},{"name":"input","type":"Input","note":"","default":"","types":["Input"]},{"name":"output","type":"Output","note":"","default":"","types":["Output"]},{"name":"#stopOnError","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"(Bool)","types":["Bool"]},"note":"","attr":"","line":"func transcode<Input : GeneratorType, Output : SinkType, InputEncoding : UnicodeCodecType, OutputEncoding : UnicodeCodecType where InputEncoding.CodeUnit == InputEncoding.CodeUnit, OutputEncoding.CodeUnit == OutputEncoding.CodeUnit>(inputEncoding: InputEncoding.Type, outputEncoding: OutputEncoding.Type, input: Input, output: Output, #stopOnError: Bool) -> (Bool)","comment":"Translate `input`, in the given `InputEncoding`, into `output`, in\nthe given `OutputEncoding`.\n\n:param: `stopOnError` causes encoding to stop when an encoding\n  error is detected in `input`, if `true`.  Otherwise, U+FFFD\n  replacement characters are inserted for each detected error."},{"kind":"func","name":"underestimateCount","slug":"underestimateCount","generic":{"line":"T : SequenceType","types":["SequenceType"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func underestimateCount<T : SequenceType>(x: T) -> Int","comment":"Return an underestimate of the number of elements in the given\nsequence, without consuming the sequence.  For Sequences that are\nactually Collections, this will return countElements(x)"},{"kind":"func","name":"unsafeAddressOf","slug":"unsafeAddressOf","generic":{},"params":[{"name":"object","type":"AnyObject","note":"","default":"","types":["AnyObject"]}],"ret":{"line":"UnsafePointer<Void>","types":["UnsafePointer","Void"]},"note":"","attr":"","line":"func unsafeAddressOf(object: AnyObject) -> UnsafePointer<Void>","comment":"Return an UnsafePointer to the storage used for `object`.  There's\nnot much you can do with this other than use it to identify the\nobject"},{"kind":"func","name":"unsafeBitCast","slug":"unsafeBitCast","generic":{"line":"T, U","types":[]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"_","type":"U.Type","note":"","default":"","types":["Type"]}],"ret":{"line":"U","types":[]},"note":"","attr":"","line":"func unsafeBitCast<T, U>(x: T, _: U.Type) -> U","comment":"Returns the the bits of `x`, interpreted as having type `U`.\n\n.. Caution:: Breaks the guarantees of Swift's type system; use\n   with extreme care.  There's almost always a better way to do\n   anything.\n"},{"kind":"func","name":"unsafeDowncast","slug":"unsafeDowncast","generic":{"line":"T","types":[]},"params":[{"name":"x","type":"AnyObject","note":"","default":"","types":["AnyObject"]}],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func unsafeDowncast<T>(x: AnyObject) -> T","comment":"Returns: `x as T`\n\nRequires: `x is T`.  In particular, in -O builds, no test is\nperformed to ensure that `x` actually has dynamic type `T`.\n\n.. Danger:: trades safety for performance.  Use `unsafeDowncast`\nonly when `x as T` has proven to be a performance problem and you\nare confident that, always, `x is T`.  It is better than an\n`unsafeBitCast` because it's more restrictive, and because\nchecking is still performed in debug builds."},{"kind":"func","name":"withExtendedLifetime","slug":"withExtendedLifetime","generic":{"line":"T, Result","types":["Result"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"f","type":"() -> Result","note":"","default":"","types":["Result"]}],"ret":{"line":"Result","types":["Result"]},"note":"","attr":"","line":"func withExtendedLifetime<T, Result>(x: T, f: () -> Result) -> Result","comment":"Evaluate `f()` and return its result, ensuring that `x` is not\ndestroyed before f returns."},{"kind":"func","name":"withExtendedLifetime","slug":"withExtendedLifetime","generic":{"line":"T, Result","types":["Result"]},"params":[{"name":"x","type":"T","note":"","default":"","types":[]},{"name":"f","type":"(T) -> Result","note":"","default":"","types":["Result"]}],"ret":{"line":"Result","types":["Result"]},"note":"","attr":"","line":"func withExtendedLifetime<T, Result>(x: T, f: (T) -> Result) -> Result","comment":"Evaluate `f(x)` and return its result, ensuring that `x` is not\ndestroyed before f returns."},{"kind":"func","name":"withUnsafeMutablePointer","slug":"withUnsafeMutablePointer","generic":{"line":"T, Result","types":["Result"]},"params":[{"name":"arg","type":"T","note":"inout","default":"","types":[]},{"name":"body","type":"(UnsafeMutablePointer<T>) -> Result","note":"","default":"","types":["Result","UnsafeMutablePointer"]}],"ret":{"line":"Result","types":["Result"]},"note":"","attr":"","line":"func withUnsafeMutablePointer<T, Result>(inout arg: T, body: (UnsafeMutablePointer<T>) -> Result) -> Result","comment":"Invokes `body` with an `UnsafeMutablePointer` to `arg` and returns the\nresult. Useful for calling Objective-C APIs that take \"in/out\"\nparameters (and default-constructible \"out\" parameters) by pointer"},{"kind":"func","name":"withUnsafeMutablePointers","slug":"withUnsafeMutablePointers","generic":{"line":"A0, A1, A2, Result","types":["A0","A1","A2","Result"]},"params":[{"name":"arg0","type":"A0","note":"inout","default":"","types":["A0"]},{"name":"arg1","type":"A1","note":"inout","default":"","types":["A1"]},{"name":"arg2","type":"A2","note":"inout","default":"","types":["A2"]},{"name":"body","type":"(UnsafeMutablePointer<A0>, UnsafeMutablePointer<A1>, UnsafeMutablePointer<A2>) -> Result","note":"","default":"","types":["A0","A1","A2","Result","UnsafeMutablePointer"]}],"ret":{"line":"Result","types":["Result"]},"note":"","attr":"","line":"func withUnsafeMutablePointers<A0, A1, A2, Result>(inout arg0: A0, inout arg1: A1, inout arg2: A2, body: (UnsafeMutablePointer<A0>, UnsafeMutablePointer<A1>, UnsafeMutablePointer<A2>) -> Result) -> Result","comment":"Like `withUnsafeMutablePointer`, but passes pointers to `arg0`, `arg1`,\nand `arg2`."},{"kind":"func","name":"withUnsafeMutablePointers","slug":"withUnsafeMutablePointers","generic":{"line":"A0, A1, Result","types":["A0","A1","Result"]},"params":[{"name":"arg0","type":"A0","note":"inout","default":"","types":["A0"]},{"name":"arg1","type":"A1","note":"inout","default":"","types":["A1"]},{"name":"body","type":"(UnsafeMutablePointer<A0>, UnsafeMutablePointer<A1>) -> Result","note":"","default":"","types":["A0","A1","Result","UnsafeMutablePointer"]}],"ret":{"line":"Result","types":["Result"]},"note":"","attr":"","line":"func withUnsafeMutablePointers<A0, A1, Result>(inout arg0: A0, inout arg1: A1, body: (UnsafeMutablePointer<A0>, UnsafeMutablePointer<A1>) -> Result) -> Result","comment":"Like `withUnsafeMutablePointer`, but passes pointers to `arg0` and `arg1`."},{"kind":"func","name":"withUnsafePointer","slug":"withUnsafePointer","generic":{"line":"T, Result","types":["Result"]},"params":[{"name":"arg","type":"T","note":"inout","default":"","types":[]},{"name":"body","type":"(UnsafePointer<T>) -> Result","note":"","default":"","types":["Result","UnsafePointer"]}],"ret":{"line":"Result","types":["Result"]},"note":"","attr":"","line":"func withUnsafePointer<T, Result>(inout arg: T, body: (UnsafePointer<T>) -> Result) -> Result","comment":"Invokes `body` with an `UnsafePointer` to `arg` and returns the\nresult. Useful for calling Objective-C APIs that take \"in/out\"\nparameters (and default-constructible \"out\" parameters) by pointer"},{"kind":"func","name":"withUnsafePointers","slug":"withUnsafePointers","generic":{"line":"A0, A1, Result","types":["A0","A1","Result"]},"params":[{"name":"arg0","type":"A0","note":"inout","default":"","types":["A0"]},{"name":"arg1","type":"A1","note":"inout","default":"","types":["A1"]},{"name":"body","type":"(UnsafePointer<A0>, UnsafePointer<A1>) -> Result","note":"","default":"","types":["A0","A1","Result","UnsafePointer"]}],"ret":{"line":"Result","types":["Result"]},"note":"","attr":"","line":"func withUnsafePointers<A0, A1, Result>(inout arg0: A0, inout arg1: A1, body: (UnsafePointer<A0>, UnsafePointer<A1>) -> Result) -> Result","comment":"Like `withUnsafePointer`, but passes pointers to `arg0` and `arg1`."},{"kind":"func","name":"withUnsafePointers","slug":"withUnsafePointers","generic":{"line":"A0, A1, A2, Result","types":["A0","A1","A2","Result"]},"params":[{"name":"arg0","type":"A0","note":"inout","default":"","types":["A0"]},{"name":"arg1","type":"A1","note":"inout","default":"","types":["A1"]},{"name":"arg2","type":"A2","note":"inout","default":"","types":["A2"]},{"name":"body","type":"(UnsafePointer<A0>, UnsafePointer<A1>, UnsafePointer<A2>) -> Result","note":"","default":"","types":["A0","A1","A2","Result","UnsafePointer"]}],"ret":{"line":"Result","types":["Result"]},"note":"","attr":"","line":"func withUnsafePointers<A0, A1, A2, Result>(inout arg0: A0, inout arg1: A1, inout arg2: A2, body: (UnsafePointer<A0>, UnsafePointer<A1>, UnsafePointer<A2>) -> Result) -> Result","comment":"Like `withUnsafePointer`, but passes pointers to `arg0`, `arg1`,\nand `arg2`."},{"kind":"func","name":"withVaList","slug":"withVaList","generic":{"line":"R","types":[]},"params":[{"name":"builder","type":"VaListBuilder","note":"","default":"","types":["VaListBuilder"]},{"name":"f","type":"(CVaListPointer) -> R","note":"","default":"","types":["CVaListPointer"]}],"ret":{"line":"R","types":[]},"note":"","attr":"","line":"func withVaList<R>(builder: VaListBuilder, f: (CVaListPointer) -> R) -> R","comment":"Invoke `f` with a C `va_list` argument derived from `builder`."},{"kind":"func","name":"withVaList","slug":"withVaList","generic":{"line":"R","types":[]},"params":[{"name":"args","type":"[CVarArgType]","note":"","default":"","types":["CVarArgType"]},{"name":"f","type":"(CVaListPointer) -> R","note":"","default":"","types":["CVaListPointer"]}],"ret":{"line":"R","types":[]},"note":"","attr":"","line":"func withVaList<R>(args: [CVarArgType], f: (CVaListPointer) -> R) -> R","comment":"Invoke `f` with a C `va_list` argument derived from `args`."}],"properties":[{"kind":"var","name":"C_ARGC","type":"CInt","readonly":true,"stat":"","subtypes":["CInt"],"comment":"Access to the raw argc value from C."},{"kind":"var","name":"C_ARGV","type":"UnsafeMutablePointer<UnsafeMutablePointer<Int8>>","readonly":true,"stat":"","subtypes":["Int8","UnsafeMutablePointer"],"comment":"Access to the raw argv value from C. Accessing the argument vector\nthrough this pointer is unsafe."},{"kind":"var","name":"Process","type":"_Process","readonly":true,"stat":"","subtypes":["_Process"],"comment":"An instance that exposes API for interaction with processes"}],"aliases":[{"kind":"typealias","name":"Any","type":"protocol<>","proto":"","comment":"The protocol to which all types implicitly conform"},{"kind":"typealias","name":"AnyClass","type":"AnyObject.Type","proto":"","comment":"The protocol to which all class types implicitly conform.\n\nWhen used as a concrete type, all known `@objc` `class` methods and\nproperties are available, as implicitly-unwrapped-optional methods\nand properties respectively, on each instance of `AnyClass`. For\nexample:\n\n.. parsed-literal:\n\n  class C {\n    @objc class var cValue: Int { return 42 }\n  }\n\n  // If x has an @objc cValue: Int, return its value.  \n  // Otherwise, return nil.\n  func getCValue(x: AnyClass) -> Int? {\n    return **x.cValue**\n  }\n\nSee also: `AnyObject`"},{"kind":"typealias","name":"BooleanLiteralType","type":"Bool","proto":"","comment":"The default type for an otherwise-unconstrained boolean literal"},{"kind":"typealias","name":"CBool","type":"Bool","proto":"","comment":"The C '_Bool' and C++ 'bool' type."},{"kind":"typealias","name":"CChar","type":"Int8","proto":"","comment":"The C 'char' type.\n\nThis will be the same as either `CSignedChar` (in the common\ncase) or `CUnsignedChar`, depending on the platform."},{"kind":"typealias","name":"CChar16","type":"UInt16","proto":"","comment":"The C++11 'char16_t' type, which has UTF-16 encoding."},{"kind":"typealias","name":"CChar32","type":"UnicodeScalar","proto":"","comment":"The C++11 'char32_t' type, which has UTF-32 encoding."},{"kind":"typealias","name":"CDouble","type":"Double","proto":"","comment":"The C 'double' type."},{"kind":"typealias","name":"CFloat","type":"Float","proto":"","comment":"The C 'float' type."},{"kind":"typealias","name":"CInt","type":"Int32","proto":"","comment":"The C 'int' type."},{"kind":"typealias","name":"CLong","type":"Int","proto":"","comment":"The C 'long' type."},{"kind":"typealias","name":"CLongLong","type":"Int64","proto":"","comment":"The C 'long long' type."},{"kind":"typealias","name":"CShort","type":"Int16","proto":"","comment":"The C 'short' type."},{"kind":"typealias","name":"CSignedChar","type":"Int8","proto":"","comment":"The C 'signed char' type."},{"kind":"typealias","name":"CUnsignedChar","type":"UInt8","proto":"","comment":"The C 'unsigned char' type."},{"kind":"typealias","name":"CUnsignedInt","type":"UInt32","proto":"","comment":"The C 'unsigned int' type."},{"kind":"typealias","name":"CUnsignedLong","type":"UInt","proto":"","comment":"The C 'unsigned long' type."},{"kind":"typealias","name":"CUnsignedLongLong","type":"UInt64","proto":"","comment":"The C 'unsigned long long' type."},{"kind":"typealias","name":"CUnsignedShort","type":"UInt16","proto":"","comment":"The C 'unsigned short' type."},{"kind":"typealias","name":"CWideChar","type":"UnicodeScalar","proto":"","comment":"The C++ 'wchar_t' type."},{"kind":"typealias","name":"ExtendedGraphemeClusterType","type":"String","proto":"","comment":"The default type for an otherwise-unconstrained unicode extended\ngrapheme cluster literal"},{"kind":"typealias","name":"Float32","type":"Float","proto":"","comment":"A 32-bit floating point type"},{"kind":"typealias","name":"Float64","type":"Double","proto":"","comment":"A 64-bit floating point type"},{"kind":"typealias","name":"FloatLiteralType","type":"Double","proto":"","comment":"The default type for an otherwise-unconstrained floating point literal"},{"kind":"typealias","name":"IntMax","type":"Int64","proto":"","comment":"The largest native signed integer type"},{"kind":"typealias","name":"IntegerLiteralType","type":"Int","proto":"","comment":"The default type for an otherwise-unconstrained integer literal"},{"kind":"typealias","name":"StringLiteralType","type":"String","proto":"","comment":"The default type for an otherwise-unconstrained string literal"},{"kind":"typealias","name":"UIntMax","type":"UInt64","proto":"","comment":"The largest native unsigned integer type"},{"kind":"typealias","name":"UWord","type":"UInt","proto":"","comment":"An unsigned integer type that occupies one machine word"},{"kind":"typealias","name":"UnicodeScalarType","type":"String","proto":"","comment":"The default type for an otherwise-unconstrained unicode scalar literal"},{"kind":"typealias","name":"Void","type":"()","proto":"","comment":"The empty tuple type.\n\nThis is the default return type of functions for which no explicit\nreturn type is specified."},{"kind":"typealias","name":"Word","type":"Int","proto":"","comment":"A signed integer type that occupies one machine word"}],"types":{"AbsoluteValuable":{"kind":"protocol","name":"AbsoluteValuable","slug":"AbsoluteValuable","inherits":["SignedNumberType"],"inherited":["Double","Float","Float80"],"attr":"","operators":[],"functions":[{"kind":"func","name":"abs","slug":"abs","generic":{},"params":[{"name":"x","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"note":"class","attr":"","line":"class func abs(x: Self) -> Self","comment":"Returns the absolute value of `x`"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A type that supports an \"absolute value\" function."},"AnyObject":{"kind":"protocol","name":"AnyObject","slug":"AnyObject","inherits":[],"inherited":[],"attr":"@objc ","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"The protocol to which all classes implicitly conform.\n\nWhen used as a concrete type, all known `@objc` methods and\nproperties are available, as implicitly-unwrapped-optional methods\nand properties respectively, on each instance of `AnyObject`.  For\nexample:\n\n.. parsed-literal:\n\n  class C {\n    @objc func getCValue() -> Int { return 42 }\n  }\n\n  // If x has a method @objc getValue()->Int, call it and\n  // return the result.  Otherwise, return nil.\n  func getCValue1(x: AnyObject) -> Int? {\n    if let f: ()->Int = **x.getCValue** {\n      return f()\n    }\n    return nil\n  }\n\n  // A more idiomatic implementation using \"optional chaining\"\n  func getCValue2(x: AnyObject) -> Int? {\n    return **x.getCValue?()**\n  }\n\n  // An implementation that assumes the required method is present\n  func getCValue3(x: AnyObject) -> **Int** {\n    return **x.getCValue()** // x.getCValue is implicitly unwrapped.\n  }\n\nSee also: `AnyClass`"},"Array":{"kind":"struct","name":"Array","slug":"Array","inherits":["MutableCollectionType","Sliceable","ArrayLiteralConvertible","Reflectable","Printable","DebugPrintable","ArrayType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"IndexingGenerator<[T]>","types":["IndexingGenerator"]},"note":"","attr":"","line":"func generate() -> IndexingGenerator<[T]>","comment":"Return a *generator* over the elements.\n\nComplexity: O(1)"},{"kind":"func","name":"reserveCapacity","slug":"reserveCapacity","generic":{},"params":[{"name":"minimumCapacity","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func reserveCapacity(minimumCapacity: Int)","comment":"Reserve enough space to store minimumCapacity elements.\n\nPostCondition: `capacity >= minimumCapacity` and the array has\nmutable contiguous storage.\n\nComplexity: O(`count`)"},{"kind":"func","name":"append","slug":"append","generic":{},"params":[{"name":"newElement","type":"T","note":"","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func append(newElement: T)","comment":"Append newElement to the Array\n\nComplexity: amortized O(1) unless `self`'s storage is shared with another live array; O(`count`) if `self` does not wrap a bridged `NSArray`; otherwise the efficiency is unspecified."},{"kind":"func","name":"extend","slug":"extend","generic":{"line":"S : SequenceType where T == T","types":["SequenceType"]},"params":[{"name":"newElements","type":"S","note":"","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func extend<S : SequenceType where T == T>(newElements: S)","comment":"Append the elements of `newElements` to `self`.\n\nComplexity: O(*length of result*) \n"},{"kind":"func","name":"removeLast","slug":"removeLast","generic":{},"params":[],"ret":{"line":"T","types":[]},"note":"mutating","attr":"","line":"mutating func removeLast() -> T","comment":"Remove an element from the end of the Array in O(1).\nRequires: count > 0"},{"kind":"func","name":"insert","slug":"insert","generic":{},"params":[{"name":"newElement","type":"T","note":"","default":"","types":[]},{"name":"i","type":"Int","note":"atIndex","default":"","types":["Int"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func insert(newElement: T, atIndex i: Int)","comment":"Insert `newElement` at index `i`.\n\nRequires: `i <= count`\n\nComplexity: O(\\ `count`\\ )."},{"kind":"func","name":"removeAtIndex","slug":"removeAtIndex","generic":{},"params":[{"name":"index","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T","types":[]},"note":"mutating","attr":"","line":"mutating func removeAtIndex(index: Int) -> T","comment":"Remove and return the element at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `count`\\ )."},{"kind":"func","name":"removeAll","slug":"removeAll","generic":{},"params":[{"name":"keepCapacity","type":"Bool","note":"","default":"default","types":["Bool"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeAll(keepCapacity: Bool = default)","comment":"Remove all elements.\n\nPostcondition: `capacity == 0` iff `keepCapacity` is `false`.\n\nComplexity: O(\\ `countElements(self)`\\ )."},{"kind":"func","name":"join","slug":"join","generic":{"line":"S : SequenceType where [T] == [T]","types":["SequenceType"]},"params":[{"name":"elements","type":"S","note":"","default":"","types":[]}],"ret":{"line":"[T]","types":[]},"note":"","attr":"","line":"func join<S : SequenceType where [T] == [T]>(elements: S) -> [T]","comment":"Interpose `self` between each consecutive pair of `elements`,\nand concatenate the elements of the resulting sequence.  For\nexample, `[-1, -2].join([[1, 2, 3], [4, 5, 6], [7, 8, 9]])`\nyields `[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]`"},{"kind":"func","name":"reduce","slug":"reduce","generic":{"line":"U","types":[]},"params":[{"name":"initial","type":"U","note":"","default":"","types":[]},{"name":"combine","type":"(U, T) -> U","note":"","default":"","types":[]}],"ret":{"line":"U","types":[]},"note":"","attr":"","line":"func reduce<U>(initial: U, combine: (U, T) -> U) -> U","comment":"Return the result of repeatedly calling `combine` with an\naccumulated value initialized to `initial` and each element of\n`self`, in turn, i.e. return\n`combine(combine(...combine(combine(initial, self[0]),\nself[1]),...self[count-2]), self[count-1])`."},{"kind":"func","name":"sort","slug":"sort","generic":{},"params":[{"name":"isOrderedBefore","type":"(T, T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func sort(isOrderedBefore: (T, T) -> Bool)","comment":"Sort `self` in-place according to `isOrderedBefore`.  Requires:\n`isOrderedBefore` induces a `strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover the elements."},{"kind":"func","name":"sorted","slug":"sorted","generic":{},"params":[{"name":"isOrderedBefore","type":"(T, T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"[T]","types":[]},"note":"","attr":"","line":"func sorted(isOrderedBefore: (T, T) -> Bool) -> [T]","comment":"Return a copy of `self` that has been sorted according to\n`isOrderedBefore`.  Requires: `isOrderedBefore` induces a\n`strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover the elements."},{"kind":"func","name":"map","slug":"map","generic":{"line":"U","types":[]},"params":[{"name":"transform","type":"(T) -> U","note":"","default":"","types":[]}],"ret":{"line":"[U]","types":[]},"note":"","attr":"","line":"func map<U>(transform: (T) -> U) -> [U]","comment":"Return an `Array` containing the results of calling\n`transform(x)` on each element `x` of `self`"},{"kind":"func","name":"reverse","slug":"reverse","generic":{},"params":[],"ret":{"line":"[T]","types":[]},"note":"","attr":"","line":"func reverse() -> [T]","comment":"A Array containing the elements of `self` in reverse order"},{"kind":"func","name":"filter","slug":"filter","generic":{},"params":[{"name":"includeElement","type":"(T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"[T]","types":[]},"note":"","attr":"","line":"func filter(includeElement: (T) -> Bool) -> [T]","comment":"Return an `Array` containing the elements `x` of `self` for which\n`includeElement(x)` is `true`"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"withUnsafeBufferPointer","slug":"withUnsafeBufferPointer","generic":{"line":"R","types":[]},"params":[{"name":"body","type":"(UnsafeBufferPointer<T>) -> R","note":"","default":"","types":["UnsafeBufferPointer"]}],"ret":{"line":"R","types":[]},"note":"","attr":"","line":"func withUnsafeBufferPointer<R>(body: (UnsafeBufferPointer<T>) -> R) -> R","comment":"Call `body(p)`, where `p` is a pointer to the `Array`\\ 's\ncontiguous storage. If no such storage exists, it is first created.\n\nOften, the optimizer can eliminate bounds checks within an\narray algorithm, but when that fails, invoking the\nsame algorithm on `body`\\ 's argument lets you trade safety for\nspeed."},{"kind":"func","name":"withUnsafeMutableBufferPointer","slug":"withUnsafeMutableBufferPointer","generic":{"line":"R","types":[]},"params":[{"name":"body","type":"(inout UnsafeMutableBufferPointer<T>) -> R","note":"","default":"","types":["UnsafeMutableBufferPointer"]}],"ret":{"line":"R","types":[]},"note":"mutating","attr":"","line":"mutating func withUnsafeMutableBufferPointer<R>(body: (inout UnsafeMutableBufferPointer<T>) -> R) -> R","comment":"Call `body(p)`, where `p` is a pointer to the `Array`\\ 's\nmutable contiguous storage. If no such storage exists, it is first created.\n\nOften, the optimizer can eliminate bounds- and uniqueness-checks\nwithin an array algorithm, but when that fails, invoking the\nsame algorithm on `body`\\ 's argument lets you trade safety for\nspeed."},{"kind":"func","name":"convertFromHeapArray","slug":"convertFromHeapArray","generic":{},"params":[{"name":"base","type":"Builtin.RawPointer","note":"","default":"","types":["Builtin","RawPointer"]},{"name":"owner","type":"Builtin.NativeObject","note":"","default":"","types":["Builtin","NativeObject"]},{"name":"count","type":"Builtin.Word","note":"","default":"","types":["Builtin","Word"]}],"ret":{"line":"[T]","types":[]},"note":"static","attr":"","line":"static func convertFromHeapArray(base: Builtin.RawPointer, owner: Builtin.NativeObject, count: Builtin.Word) -> [T]","comment":"This function \"seeds\" the ArrayLiteralConvertible protocol"},{"kind":"func","name":"replaceRange","slug":"replaceRange","generic":{"line":"C : CollectionType where T == T","types":["CollectionType"]},"params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]},{"name":"newElements","type":"C","note":"with","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func replaceRange<C : CollectionType where T == T>(subRange: Range<Int>, with newElements: C)","comment":"Replace the given `subRange` of elements with `newElements`.\n\nComplexity: O(\\ `countElements(subRange)`\\ ) if `subRange.endIndex\n== self.endIndex` and `isEmpty(newElements)`\\ , O(N) otherwise."},{"kind":"func","name":"splice","slug":"splice","generic":{"line":"S : CollectionType where T == T","types":["CollectionType"]},"params":[{"name":"newElements","type":"S","note":"","default":"","types":[]},{"name":"i","type":"Int","note":"atIndex","default":"","types":["Int"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func splice<S : CollectionType where T == T>(newElements: S, atIndex i: Int)","comment":"Insert `newElements` at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `count + countElements(newElements)`\\ )."},{"kind":"func","name":"removeRange","slug":"removeRange","generic":{},"params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeRange(subRange: Range<Int>)","comment":"Remove the indicated `subRange` of elements\n\nComplexity: O(\\ `count`\\ )."}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"Always zero, which is the index of the first element when non-empty."},{"kind":"var","name":"endIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"A \"past-the-end\" element index; the successor of the last valid\nsubscript argument."},{"kind":"var","name":"count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"How many elements the Array stores"},{"kind":"var","name":"capacity","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"How many elements the `Array` can store without reallocation"},{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` if and only if the `Array` is empty"},{"kind":"var","name":"first","type":"T?","readonly":true,"stat":"","subtypes":[],"comment":"The first element, or `nil` if the array is empty"},{"kind":"var","name":"last","type":"T?","readonly":true,"stat":"","subtypes":[],"comment":"The last element, or `nil` if the array is empty"},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[{"kind":"typealias","name":"Element","type":"T","proto":"","comment":"The type of element stored by this `Array`"},{"kind":"typealias","name":"SubSlice","type":"Slice<T>","proto":"","comment":"A type that can represent a sub-range of an `Array` "}],"inits":[{"kind":"init","generic":{},"params":[{"name":"buffer","type":"_ArrayBuffer<T>","note":"_","default":"","types":["_ArrayBuffer"]}],"init":"init","note":"","comment":"Initialization from an existing buffer does not have \"array.init\"\nsemantics because the caller may retain an alias to buffer."},{"kind":"init","generic":{},"params":[{"name":"elements","type":"T...","note":"arrayLiteral","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance containing `elements`."},{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Construct an empty Array"},{"kind":"init","generic":{"line":"S : SequenceType where T == T","types":["SequenceType"]},"params":[{"name":"s","type":"S","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct from an arbitrary sequence with elements of type `T`"},{"kind":"init","generic":{},"params":[{"name":"count","type":"Int","note":"","default":"","types":["Int"]},{"name":"repeatedValue","type":"T","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Construct a Array of `count` elements, each initialized to\n`repeatedValue`."},{"kind":"init","generic":{},"params":[{"name":"source","type":"_SwiftNSArrayRequiredOverridesType","note":"_fromCocoaArray","default":"","types":["_SwiftNSArrayRequiredOverridesType"]},{"name":"noCopy","type":"Bool","note":"","default":"default","types":["Bool"]}],"init":"init","note":"","comment":"Construct from the given `_SwiftNSArrayRequiredOverridesType`.\n\nIf `noCopy` is `true`, either `source` must be known to be immutable,\nor the resulting / `Array` must not survive across code that could mutate\n`source`."}],"subscripts":[{"kind":"subscript","params":[{"name":"index","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T","types":[]},"comment":""},{"kind":"subscript","params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]}],"ret":{"line":"Slice<T>","types":["Slice"]},"comment":""}],"comment":"Conceptually_, `Array` is an efficient, tail-growable random-access\ncollection of arbitrary elements.\n\nCommon Properties of Array Types\n================================\n\nThe information in this section applies to all three of Swift's\narray types, `Array<T>`, `ContiguousArray<T>`, and `Slice<T>`.\nWhen you read the word \"array\" here in a normal typeface, it\napplies to all three of them.\n\nValue Semantics\n---------------\n\nEach array variable, `let` binding, or stored property has an\nindependent value that includes the values of all of its elements.\nTherefore, mutations to the array are not observable through its\ncopies::\n\n  var a = [1, 2, 3]\n  var b = a\n  b[0] = 4\n  println(\"a=\\(a), b=\\(b)\")     // a=[1, 2, 3], b=[4, 2, 3]\n\n(Of course, if the array stores `class` references, the objects\nare shared; only the values of the references are independent)\n\nArrays use Copy-on-Write so that their storage and elements are\nonly copied lazily, upon mutation, when more than one array\ninstance is using the same buffer.  Therefore, the first in any\nsequence of mutating operations may cost `O(N)` time and space,\nwhere `N` is the length of the array.\n\nGrowth and Capacity\n-------------------\n\nWhen an array's contiguous storage fills up, new storage must be\nallocated and elements must be moved to the new storage.  `Array`,\n`ContiguousArray`, and `Slice` share an exponential growth\nstrategy that makes `append` a constant time operation *when\namortized over many invocations*.  In addition to a `count`\nproperty, these array types have a `capacity` that reflects their\npotential to store elements without reallocation, and when you\nknow how many elements you'll store, you can call\n`reserveCapacity` to pre-emptively reallocate and prevent\nintermediate reallocations.\n\n.. _Conceptually:\n\nObjective-C Bridge\n==================\n\nThe main distinction between `Array` and the other array types is\nthat it interoperates seamlessly and efficiently with Objective-C.\n\n`Array<T>` is considered bridged to Objective-C iff `T` is bridged\nto Objective-C.\n\nWhen `T` is a `class` or `@objc` protocol type, `Array` may store\nits elements in an `NSArray`.  Since any arbitrary subclass of\n`NSArray` can become an `Array`, there are no guarantees about\nrepresentation or efficiency in this case (see also\n`ContiguousArray`).  Since `NSArray` is immutable, it is just as\nthough the storage was shared by some copy: the first in any\nsequence of mutating operations causes elements to be copied into\nunique, contiguous storage which may cost `O(N)` time and space,\nwhere `N` is the length of the array (or more, if the underlying\n`NSArray` is has unusual performance characteristics).\n\nBridging to Objective-C\n-----------------------\n\nAny bridged `Array` can be implicitly converted to an `NSArray`.\nWhen `T` is a `class` or `@objc` protocol, bridging takes O(1)\ntime and O(1) space.  Other `Array`\\ s must be bridged\nelement-by-element, allocating a new object for each element, at a\ncost of at least O(`count`) time and space.\n\nBridging from Objective-C\n-------------------------\n\nAn `NSArray` can be implicitly or explicitly converted to any\nbridged `Array<T>`.  This conversion calls `copyWithZone` on the\n`NSArray`, to ensure it won't be modified, and stores the result\nin the `Array`.  Type-checking, to ensure the `NSArray`\\ 's\nelements match or can be bridged to `T`, is deferred until the\nfirst element access."},"ArrayLiteralConvertible":{"kind":"protocol","name":"ArrayLiteralConvertible","slug":"ArrayLiteralConvertible","inherits":[],"inherited":["Array","ContiguousArray","Slice","ArrayType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Element","type":"","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"elements","type":"Element...","note":"arrayLiteral","default":"","types":["Element"]}],"init":"init","note":"","comment":"Create an instance initialized with `elements`."}],"subscripts":[],"comment":"Conforming types can be initialized with array literals"},"AutoreleasingUnsafeMutablePointer":{"kind":"struct","name":"AutoreleasingUnsafeMutablePointer","slug":"AutoreleasingUnsafeMutablePointer","inherits":["Equatable","NilLiteralConvertible","DebugPrintable"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"null","slug":"null","generic":{},"params":[],"ret":{"line":"AutoreleasingUnsafeMutablePointer<T>","types":["AutoreleasingUnsafeMutablePointer"]},"note":"static","attr":"","line":"static func null() -> AutoreleasingUnsafeMutablePointer<T>","comment":"Returns `nil`"}],"types":[],"properties":[{"kind":"var","name":"memory","type":"T","readonly":false,"stat":"","subtypes":[],"comment":"Access the underlying raw memory, getting and\nsetting values."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"nilLiteral","type":"()","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance initialized with `nil`."},{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Initialize to a null pointer."},{"kind":"init","generic":{"line":"U","types":[]},"params":[{"name":"ptr","type":"UnsafeMutablePointer<U>","note":"_","default":"","types":["UnsafeMutablePointer"]}],"init":"init","note":"","comment":"Explicit construction from an UnsafeMutablePointer.\n\nThis is inherently unsafe; UnsafeMutablePointer assumes the\nreferenced memory has +1 strong ownership semantics, whereas\nAutoreleasingUnsafeMutablePointer implies +0 semantics."}],"subscripts":[{"kind":"subscript","params":[{"name":"i","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T { get }","types":[]},"comment":""}],"comment":"A mutable pointer-to-ObjC-pointer argument.\n\nThis type has implicit conversions to allow passing any of the following\nto a C or ObjC API:\n\n- 'nil', which gets passed as a null pointer,\n- an inout argument of the referenced type, which gets passed as a pointer\n  to a writeback temporary with autoreleasing ownership semantics,\n- an UnsafeMutablePointer<T>, which is passed as-is.\n\nPassing pointers to mutable arrays of ObjC class pointers is not\ndirectly supported. Unlike UnsafeMutablePointer<T>,\nAutoreleasingUnsafeMutablePointer must reference storage that does\nnot own a reference count to the referenced\nvalue. UnsafeMutablePointer's operations, by contrast, assume that\nthe referenced storage owns values loaded from or stored to it.\n\nThis type does not carry an owner pointer unlike the other C*Pointer types\nbecause it only needs to reference the results of inout conversions, which\nalready have writeback-scoped lifetime."},"BidirectionalIndexType":{"kind":"protocol","name":"BidirectionalIndexType","slug":"BidirectionalIndexType","inherits":["ForwardIndexType","_BidirectionalIndexType"],"inherited":["DictionaryIndex","RandomAccessIndexType","ReverseBidirectionalIndex","String.Index","String.UnicodeScalarView.Index"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"An *index* that can step backwards via application of its\n`predecessor()` method."},"BidirectionalReverseView":{"kind":"struct","name":"BidirectionalReverseView","slug":"BidirectionalReverseView","inherits":["CollectionType"],"inherited":[],"generic":{"line":"T : CollectionType where T.Index : BidirectionalIndexType","types":["BidirectionalIndexType","CollectionType","Index"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"IndexingGenerator<BidirectionalReverseView<T>>","types":["BidirectionalReverseView","IndexingGenerator"]},"note":"","attr":"","line":"func generate() -> IndexingGenerator<BidirectionalReverseView<T>>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The position of the first element in a non-empty collection.\n\nIdentical to `endIndex` in an empty collection."},{"kind":"var","name":"endIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The collection's \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."}],"aliases":[{"kind":"typealias","name":"Index","type":"ReverseBidirectionalIndex<T.Index>","proto":"","comment":"A type that represents a valid position in the collection.\n\nValid indices consist of the position of every element and a\n\"past the end\" position that's not valid for use as a subscript."},{"kind":"typealias","name":"Generator","type":"IndexingGenerator<BidirectionalReverseView<T>>","proto":"","comment":"A type whose instances can produce the elements of this\nsequence, in order."}],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"Index","note":"","default":"","types":["Index"]}],"ret":{"line":"T.Generator.Element { get }","types":["Element","Generator"]},"comment":""}],"comment":"The lazy `CollectionType` returned by `reverse(c)` where `c` is a\n`CollectionType` with an `Index` conforming to `BidirectionalIndexType`"},"Bit":{"kind":"enum","name":"Bit","slug":"Bit","inherits":["Int","RandomAccessIndexType","Reflectable","IntegerArithmeticType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"Bit","types":["Bit"]},"note":"","attr":"","line":"func successor() -> Bit","comment":"Returns the next consecutive value after `self`.\n\nRequires: `self == .Zero`."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"Bit","types":["Bit"]},"note":"","attr":"","line":"func predecessor() -> Bit","comment":"Returns the previous consecutive value before `self`.\n\nRequires: `self != .Zero`."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Bit","note":"","default":"","types":["Bit"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func distanceTo(other: Bit) -> Int","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"distance","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Bit","types":["Bit"]},"note":"","attr":"","line":"func advancedBy(distance: Int) -> Bit","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"Bit","note":"","default":"","types":["Bit"]},{"name":"rhs","type":"Bit","note":"_","default":"","types":["Bit"]}],"ret":{"line":"(Bit, overflow: Bool)","types":["Bit","Bool"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: Bit, _ rhs: Bit) -> (Bit, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a `Bool` that is\ntrue iff the operation caused an arithmetic overflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"Bit","note":"","default":"","types":["Bit"]},{"name":"rhs","type":"Bit","note":"_","default":"","types":["Bit"]}],"ret":{"line":"(Bit, overflow: Bool)","types":["Bit","Bool"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: Bit, _ rhs: Bit) -> (Bit, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a `Bool` that is\ntrue iff the operation caused an arithmetic overflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"Bit","note":"","default":"","types":["Bit"]},{"name":"rhs","type":"Bit","note":"_","default":"","types":["Bit"]}],"ret":{"line":"(Bit, overflow: Bool)","types":["Bit","Bool"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: Bit, _ rhs: Bit) -> (Bit, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a `Bool` that is\ntrue iff the operation caused an arithmetic overflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"Bit","note":"","default":"","types":["Bit"]},{"name":"rhs","type":"Bit","note":"_","default":"","types":["Bit"]}],"ret":{"line":"(Bit, overflow: Bool)","types":["Bit","Bool"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: Bit, _ rhs: Bit) -> (Bit, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning a result and a `Bool` that is\ntrue iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"Bit","note":"","default":"","types":["Bit"]},{"name":"rhs","type":"Bit","note":"_","default":"","types":["Bit"]}],"ret":{"line":"(Bit, overflow: Bool)","types":["Bit","Bool"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: Bit, _ rhs: Bit) -> (Bit, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning the remainder and a `Bool` that is\ntrue iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Represent this number using Swift's widest native signed integer\ntype."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A `RandomAccessIndexType` that has two possible values.  Used as\nthe `Index` type for `SequenceOfOne<T>`.","cases":[{"kind":"case","name":"Zero","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"One","associated":"","subtypes":[],"comment":""}]},"BitwiseOperationsType":{"kind":"protocol","name":"BitwiseOperationsType","slug":"BitwiseOperationsType","inherits":[],"inherited":["Int","Int16","Int32","Int64","Int8","RawOptionSetType","UInt","UInt16","UInt32","UInt64","UInt8","_IntegerType"],"attr":"","operators":[],"functions":[{"kind":"operator func","name":"&","slug":"amp","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"func &(lhs: Self, rhs: Self) -> Self","comment":"Returns the intersection of bits set in `lhs` and `rhs`.\n\nComplexity: O(1)"},{"kind":"operator func","name":"|","slug":"bar","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"func |(lhs: Self, rhs: Self) -> Self","comment":"Returns the union of bits set in `lhs` and `rhs`\n\nComplexity: O(1)"},{"kind":"operator func","name":"^","slug":"crt","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"func ^(lhs: Self, rhs: Self) -> Self","comment":"Returns the bits that are set in exactly one of `lhs` and `rhs`\n\nComplexity: O(1)"},{"kind":"operator func","name":"~","slug":"tilde","generic":{},"place":"prefix","params":[{"name":"x","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"prefix func ~(x: Self) -> Self","comment":"Returns `x ^ ~Self.allZeros`\n\nComplexity: O(1)"}],"types":[],"properties":[{"kind":"var","name":"allZeros","type":"Self","readonly":true,"stat":"class","subtypes":["Self"],"comment":"The empty bitset.\n\nAlso the `identity element\n<http://en.wikipedia.org/wiki/Identity_element>`_ for `|` and\n`^`, and the `fixed point\n<http://en.wikipedia.org/wiki/Fixed_point_(mathematics)>`_ for\n`&`."}],"aliases":[],"inits":[],"subscripts":[],"comment":"A set type with O(1) standard bitwise operators.\n\nEach instance is a subset of `~Self.allZeros`\n\nAxioms, where `x` is an instance of `Self`::\n\n  x | Self.allZeros == x\n  x ^ Self.allZeros == x\n  x & Self.allZeros == .allZeros\n  x & ~Self.allZeros == x\n  ~x == x ^ ~Self.allZeros"},"Bool":{"kind":"struct","name":"Bool","slug":"Bool","inherits":["BooleanLiteralConvertible","BooleanType","Printable","Equatable","Hashable","Reflectable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"boolValue","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"Identical to `self`."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Default-initialize Boolean value to `false`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int1","note":"_builtinBooleanLiteral","default":"","types":["Builtin","Int1"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Bool","note":"booleanLiteral","default":"","types":["Bool"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{"line":"T : BooleanType","types":["BooleanType"]},"params":[{"name":"value","type":"T","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance representing the same logical value as\n`value`"}],"subscripts":[],"comment":"A value type whose instances are either `true` or `false`."},"BooleanLiteralConvertible":{"kind":"protocol","name":"BooleanLiteralConvertible","slug":"BooleanLiteralConvertible","inherits":[],"inherited":["Bool"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"BooleanLiteralType","type":"","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"value","type":"BooleanLiteralType","note":"booleanLiteral","default":"","types":["BooleanLiteralType"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."}],"subscripts":[],"comment":"Conforming types can be initialized with the boolean literals\n`true` and `false`."},"BooleanType":{"kind":"protocol","name":"BooleanType","slug":"BooleanType","inherits":[],"inherited":["Bool"],"attr":"","operators":[],"functions":[],"types":[],"properties":[{"kind":"var","name":"boolValue","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"The value of `self`, expressed as a `Bool`."}],"aliases":[],"inits":[],"subscripts":[],"comment":"A type that represents a boolean value.\n\nTypes that conform to the `BooleanType` protocol can be used as\nthe condition in control statements (`if`, `while`, C-style `for`)\nand other logical value contexts (e.g., `case` statement guards).\n\nOnly two types provided by Swift, `Bool` and `ObjCBool`, conform\nto `BooleanType`. Expanding this set to include types that\nrepresent more than simple boolean values is discouraged."},"CFunctionPointer":{"kind":"struct","name":"CFunctionPointer","slug":"CFunctionPointer","inherits":["Equatable","Hashable","NilLiteralConvertible","DebugPrintable"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"null","slug":"null","generic":{},"params":[],"ret":{"line":"CFunctionPointer<T>","types":["CFunctionPointer"]},"note":"static","attr":"","line":"static func null() -> CFunctionPointer<T>","comment":"Returns `nil`"}],"types":[],"properties":[{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create a `nil` instance."},{"kind":"init","generic":{},"params":[{"name":"value","type":"COpaquePointer","note":"_","default":"","types":["COpaquePointer"]}],"init":"init","note":"","comment":"Reinterpret the bits of `value` as `CFunctionPointer<T>`.\n\n.. Warning:: This is a fundamentally unsafe operation, equivalent to\n     `unsafeBitCast(value, CFunctionPointer<T>.self)`"},{"kind":"init","generic":{},"params":[{"name":"nilLiteral","type":"()","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance initialized with `nil`."}],"subscripts":[],"comment":"The family of C function pointer types.\n\nIn imported APIs, `T` is a Swift function type such as\n`(Int)->String`.\n\nThough not directly useful in Swift, `CFunctionPointer<T>` can be\nused to safely pass a C function pointer, received from one C or\nObjective-C API, to another C or Objective-C API."},"COpaquePointer":{"kind":"struct","name":"COpaquePointer","slug":"COpaquePointer","inherits":["Equatable","Hashable","NilLiteralConvertible","DebugPrintable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"null","slug":"null","generic":{},"params":[],"ret":{"line":"COpaquePointer","types":["COpaquePointer"]},"note":"static","attr":"","line":"static func null() -> COpaquePointer","comment":"Returns `nil`"},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Construct a `nil` instance."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"Word","note":"","default":"","types":["Word"]}],"init":"init","note":"","comment":"Construct a `COpaquePointer` from a given address in memory.\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"UWord","note":"","default":"","types":["UWord"]}],"init":"init","note":"","comment":"Construct a `COpaquePointer` from a given address in memory.\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{"line":"T","types":[]},"params":[{"name":"value","type":"UnsafePointer<T>","note":"_","default":"","types":["UnsafePointer"]}],"init":"init","note":"","comment":"Convert a typed `UnsafePointer` to an opaque C pointer."},{"kind":"init","generic":{"line":"T","types":[]},"params":[{"name":"value","type":"UnsafeMutablePointer<T>","note":"_","default":"","types":["UnsafeMutablePointer"]}],"init":"init","note":"","comment":"Convert a typed `UnsafeMutablePointer` to an opaque C pointer."},{"kind":"init","generic":{},"params":[{"name":"nilLiteral","type":"()","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance initialized with `nil`."},{"kind":"init","generic":{"line":"T","types":[]},"params":[{"name":"value","type":"CFunctionPointer<T>","note":"_","default":"","types":["CFunctionPointer"]}],"init":"init","note":"","comment":"Reinterpret the bits of `value` as `COpaquePointer`.\n\n.. Warning:: This is a fundamentally unsafe operation, equivalent to\n     `unsafeBitCast(value, COpaquePointer.self)`"}],"subscripts":[],"comment":"A wrapper around an opaque C pointer.\n\nOpaque pointers are used to represent C pointers to types that\ncannot be represented in Swift, such as incomplete struct types."},"CVaListPointer":{"kind":"struct","name":"CVaListPointer","slug":"CVaListPointer","inherits":["DebugPrintable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[],"types":[],"properties":[{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[],"subscripts":[],"comment":"The corresponding Swift type to `va_list` in imported C APIs."},"CVarArgType":{"kind":"protocol","name":"CVarArgType","slug":"CVarArgType","inherits":[],"inherited":["COpaquePointer","Double","Float","Int","Int16","Int32","Int64","Int8","UInt","UInt16","UInt32","UInt64","UInt8"],"attr":"","operators":[],"functions":[{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"Instances of conforming types can be encoded, and appropriately\npassed, as elements of a C `va_list`.\n\nThis protocol is useful in presenting C \"varargs\" APIs natively in\nSwift.  It only works for APIs that have a `va_list` variant, so\nfor example, it isn't much use if all you have is::\n\n  int f(int n, ...)\n\nGiven a version like this, though, ::\n\n  int f(int, va_list arguments)\n\nyou can write::\n\n  func swiftF(x: Int, arguments: CVarArgType...) -> Int {\n    return withVaList(arguments) { f(x, $0) }\n  }"},"Character":{"kind":"enum","name":"Character","slug":"Character","inherits":["ExtendedGraphemeClusterLiteralConvertible","Equatable","Hashable","Comparable","Reflectable","Streamable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"writeTo","slug":"writeTo","generic":{"line":"Target : OutputStreamType","types":["OutputStreamType","Target"]},"params":[{"name":"target","type":"Target","note":"inout","default":"","types":["Target"]}],"ret":{},"note":"","attr":"","line":"func writeTo<Target : OutputStreamType>(inout target: Target)","comment":"Write a textual representation of `self` into `target`"}],"types":[],"properties":[{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"scalar","type":"UnicodeScalar","note":"_","default":"","types":["UnicodeScalar"]}],"init":"init","note":"","comment":"Construct a `Character` containing just the given `scalar`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int32","note":"_builtinUnicodeScalarLiteral","default":"","types":["Builtin","Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Character","note":"unicodeScalarLiteral","default":"","types":["Character"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"start","type":"Builtin.RawPointer","note":"_builtinExtendedGraphemeClusterLiteral","default":"","types":["Builtin","RawPointer"]},{"name":"byteSize","type":"Builtin.Word","note":"","default":"","types":["Builtin","Word"]},{"name":"isASCII","type":"Builtin.Int1","note":"","default":"","types":["Builtin","Int1"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Character","note":"extendedGraphemeClusterLiteral","default":"","types":["Character"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"s","type":"String","note":"_","default":"","types":["String"]}],"init":"init","note":"","comment":"Create an instance from a single-character `String`.\n\nRequires: `s` contains exactly one extended grapheme cluster."}],"subscripts":[],"comment":"`Character` represents some Unicode grapheme cluster as\ndefined by a canonical, localized, or otherwise tailored\nsegmentation algorithm.","cases":[{"kind":"case","name":"LargeRepresentation","associated":"(OnHeap<String>)","subtypes":["OnHeap","String"],"comment":""},{"kind":"case","name":"SmallRepresentation","associated":"","subtypes":[],"comment":""}]},"ClosedInterval":{"kind":"struct","name":"ClosedInterval","slug":"ClosedInterval","inherits":["IntervalType","Equatable","Printable","DebugPrintable","Reflectable"],"inherited":[],"generic":{"line":"T : Comparable","types":["Comparable"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"contains","slug":"contains","generic":{},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func contains(x: T) -> Bool","comment":"Returns `true` iff the `Interval` contains `x`"},{"kind":"func","name":"clamp","slug":"clamp","generic":{},"params":[{"name":"intervalToClamp","type":"ClosedInterval<T>","note":"","default":"","types":["ClosedInterval"]}],"ret":{"line":"ClosedInterval<T>","types":["ClosedInterval"]},"note":"","attr":"","line":"func clamp(intervalToClamp: ClosedInterval<T>) -> ClosedInterval<T>","comment":"Return `intervalToClamp` clamped to `self`.  The bounds of the\nresult, even if it is empty, are always limited to the bounds of\n`self`"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"start","type":"T","readonly":true,"stat":"","subtypes":[],"comment":"The `Interval`\\ 's lower bound. Invariant: `start` <= `end`"},{"kind":"var","name":"end","type":"T","readonly":true,"stat":"","subtypes":[],"comment":"The `Interval`\\ 's upper bound. Invariant: `start` <= `end`"},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."},{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff the `Interval` is empty.  In the case of\n`ClosedInterval`, always returns `false`"}],"aliases":[{"kind":"typealias","name":"Bound","type":"T","proto":"","comment":"The type of the `Interval`\\ 's endpoints"}],"inits":[{"kind":"init","generic":{},"params":[{"name":"x","type":"ClosedInterval<T>","note":"_","default":"","types":["ClosedInterval"]}],"init":"init","note":"","comment":"Construct a copy of `x`"},{"kind":"init","generic":{},"params":[{"name":"start","type":"T","note":"_","default":"","types":[]},{"name":"end","type":"T","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an interval with the given bounds.  Requires: `start`\n<= `end`."}],"subscripts":[],"comment":""},"CollectionOfOne":{"kind":"struct","name":"CollectionOfOne","slug":"CollectionOfOne","inherits":["CollectionType","Reflectable"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"GeneratorOfOne<T>","types":["GeneratorOfOne"]},"note":"","attr":"","line":"func generate() -> GeneratorOfOne<T>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The position of the first element."},{"kind":"var","name":"endIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The \"past the end\" position; always identical to\n`startIndex.successor()`.\n\nNote: `endIndex` is not a valid argument to `subscript`."}],"aliases":[{"kind":"typealias","name":"Index","type":"Bit","proto":"","comment":"A type that represents a valid position in the collection.\n\nValid indices consist of the position of every element and a\n\"past the end\" position that's not valid for use as a subscript."}],"inits":[{"kind":"init","generic":{},"params":[{"name":"element","type":"T","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance containing just `element`."}],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"Index","note":"","default":"","types":["Index"]}],"ret":{"line":"T { get }","types":[]},"comment":""}],"comment":"A collection containing a single element of type `T`."},"CollectionType":{"kind":"protocol","name":"CollectionType","slug":"CollectionType","inherits":["_CollectionType","SequenceType"],"inherited":["BidirectionalReverseView","CollectionOfOne","Dictionary","EmptyCollection","FilterCollectionView","LazyBidirectionalCollection","LazyForwardCollection","LazyRandomAccessCollection","MapCollectionView","MutableCollectionType","RandomAccessReverseView","Range","Repeat","String","UnsafeBufferPointer","_ExtensibleCollectionType","_Sliceable","_ArrayType","String.UTF8View"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"Self.Index","note":"","default":"","types":["Index","Self"]}],"ret":{"line":"Self.Generator.Element { get }","types":["Element","Generator","Self"]},"comment":""}],"comment":"A multi-pass *sequence* with addressable positions.\n\nPositions are represented by an associated `Index` type.  Whereas\nan arbitrary *sequence* may be consumed as it is traversed, a\n*collection* is multi-pass: any element may be revisited merely by\nsaving its index.\n\nThe sequence view of the elements is identical to the collection\nview.  In other words, the following code binds the same series of\nvalues to `x` as does `for x in self {}`::\n\n  for i in startIndex..<endIndex {\n    let x = self[i]\n  }"},"Comparable":{"kind":"protocol","name":"Comparable","slug":"Comparable","inherits":["_Comparable","Equatable"],"inherited":["Character","DictionaryIndex","Double","Float","Float80","IntegerArithmeticType","Strideable","String","UnicodeScalar","_SignedNumberType","String.Index","String.UnicodeScalarView.Index"],"attr":"","operators":[],"functions":[{"kind":"operator func","name":"<=","slug":"lteq","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <=(lhs: Self, rhs: Self) -> Bool","comment":""},{"kind":"operator func","name":">=","slug":"gteq","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >=(lhs: Self, rhs: Self) -> Bool","comment":""},{"kind":"operator func","name":">","slug":"gt","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func >(lhs: Self, rhs: Self) -> Bool","comment":""}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"Instances of conforming types can be compared using relational\noperators, which define a `strict total order\n<http://en.wikipedia.org/wiki/Total_order#Strict_total_order>`_.\n\nA type conforming to `Comparable` need only supply the `<` and\n`==` operators; default implementations of `<=`, `>`, `>=`, and\n`!=` are supplied by the standard library::\n\n  struct Singular : Comparable {}\n  func ==(x: Singular, y: Singular) -> Bool { return true }\n  func <(x: Singular, y: Singular) -> Bool { return false }\n\n**Axioms**, in addition to those of `Equatable`:\n\n- `x == y` implies `x <= y`, `x >= y`, `!(x < y)`, and `!(x > y)`\n- `x < y` implies `x <= y` and `y > x`\n- `x > y` implies `x >= y` and `y < x`\n- `x <= y` implies `y >= x`\n- `x >= y` implies `y <= x`"},"ContiguousArray":{"kind":"struct","name":"ContiguousArray","slug":"ContiguousArray","inherits":["MutableCollectionType","Sliceable","ArrayLiteralConvertible","Reflectable","Printable","DebugPrintable","ArrayType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"IndexingGenerator<ContiguousArray<T>>","types":["ContiguousArray","IndexingGenerator"]},"note":"","attr":"","line":"func generate() -> IndexingGenerator<ContiguousArray<T>>","comment":"Return a *generator* over the elements.\n\nComplexity: O(1)"},{"kind":"func","name":"reserveCapacity","slug":"reserveCapacity","generic":{},"params":[{"name":"minimumCapacity","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func reserveCapacity(minimumCapacity: Int)","comment":"Reserve enough space to store minimumCapacity elements.\n\nPostCondition: `capacity >= minimumCapacity` and the array has\nmutable contiguous storage.\n\nComplexity: O(`count`)"},{"kind":"func","name":"append","slug":"append","generic":{},"params":[{"name":"newElement","type":"T","note":"","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func append(newElement: T)","comment":"Append newElement to the ContiguousArray\n\nComplexity: amortized O(1) unless `self`'s storage is shared with another live array; O(`count`) otherwise."},{"kind":"func","name":"extend","slug":"extend","generic":{"line":"S : SequenceType where T == T","types":["SequenceType"]},"params":[{"name":"newElements","type":"S","note":"","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func extend<S : SequenceType where T == T>(newElements: S)","comment":"Append the elements of `newElements` to `self`.\n\nComplexity: O(*length of result*) \n"},{"kind":"func","name":"removeLast","slug":"removeLast","generic":{},"params":[],"ret":{"line":"T","types":[]},"note":"mutating","attr":"","line":"mutating func removeLast() -> T","comment":"Remove an element from the end of the ContiguousArray in O(1).\nRequires: count > 0"},{"kind":"func","name":"insert","slug":"insert","generic":{},"params":[{"name":"newElement","type":"T","note":"","default":"","types":[]},{"name":"i","type":"Int","note":"atIndex","default":"","types":["Int"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func insert(newElement: T, atIndex i: Int)","comment":"Insert `newElement` at index `i`.\n\nRequires: `i <= count`\n\nComplexity: O(\\ `count`\\ )."},{"kind":"func","name":"removeAtIndex","slug":"removeAtIndex","generic":{},"params":[{"name":"index","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T","types":[]},"note":"mutating","attr":"","line":"mutating func removeAtIndex(index: Int) -> T","comment":"Remove and return the element at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `count`\\ )."},{"kind":"func","name":"removeAll","slug":"removeAll","generic":{},"params":[{"name":"keepCapacity","type":"Bool","note":"","default":"default","types":["Bool"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeAll(keepCapacity: Bool = default)","comment":"Remove all elements.\n\nPostcondition: `capacity == 0` iff `keepCapacity` is `false`.\n\nComplexity: O(\\ `countElements(self)`\\ )."},{"kind":"func","name":"join","slug":"join","generic":{"line":"S : SequenceType where ContiguousArray<T> == ContiguousArray<T>","types":["ContiguousArray","SequenceType"]},"params":[{"name":"elements","type":"S","note":"","default":"","types":[]}],"ret":{"line":"ContiguousArray<T>","types":["ContiguousArray"]},"note":"","attr":"","line":"func join<S : SequenceType where ContiguousArray<T> == ContiguousArray<T>>(elements: S) -> ContiguousArray<T>","comment":"Interpose `self` between each consecutive pair of `elements`,\nand concatenate the elements of the resulting sequence.  For\nexample, `[-1, -2].join([[1, 2, 3], [4, 5, 6], [7, 8, 9]])`\nyields `[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]`"},{"kind":"func","name":"reduce","slug":"reduce","generic":{"line":"U","types":[]},"params":[{"name":"initial","type":"U","note":"","default":"","types":[]},{"name":"combine","type":"(U, T) -> U","note":"","default":"","types":[]}],"ret":{"line":"U","types":[]},"note":"","attr":"","line":"func reduce<U>(initial: U, combine: (U, T) -> U) -> U","comment":"Return the result of repeatedly calling `combine` with an\naccumulated value initialized to `initial` and each element of\n`self`, in turn, i.e. return\n`combine(combine(...combine(combine(initial, self[0]),\nself[1]),...self[count-2]), self[count-1])`."},{"kind":"func","name":"sort","slug":"sort","generic":{},"params":[{"name":"isOrderedBefore","type":"(T, T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func sort(isOrderedBefore: (T, T) -> Bool)","comment":"Sort `self` in-place according to `isOrderedBefore`.  Requires:\n`isOrderedBefore` induces a `strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover the elements."},{"kind":"func","name":"sorted","slug":"sorted","generic":{},"params":[{"name":"isOrderedBefore","type":"(T, T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"ContiguousArray<T>","types":["ContiguousArray"]},"note":"","attr":"","line":"func sorted(isOrderedBefore: (T, T) -> Bool) -> ContiguousArray<T>","comment":"Return a copy of `self` that has been sorted according to\n`isOrderedBefore`.  Requires: `isOrderedBefore` induces a\n`strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover the elements."},{"kind":"func","name":"map","slug":"map","generic":{"line":"U","types":[]},"params":[{"name":"transform","type":"(T) -> U","note":"","default":"","types":[]}],"ret":{"line":"ContiguousArray<U>","types":["ContiguousArray"]},"note":"","attr":"","line":"func map<U>(transform: (T) -> U) -> ContiguousArray<U>","comment":"Return a ContiguousArray containing the results of calling\n`transform(x)` on each element `x` of `self`"},{"kind":"func","name":"reverse","slug":"reverse","generic":{},"params":[],"ret":{"line":"ContiguousArray<T>","types":["ContiguousArray"]},"note":"","attr":"","line":"func reverse() -> ContiguousArray<T>","comment":"A ContiguousArray containing the elements of `self` in reverse order"},{"kind":"func","name":"filter","slug":"filter","generic":{},"params":[{"name":"includeElement","type":"(T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"ContiguousArray<T>","types":["ContiguousArray"]},"note":"","attr":"","line":"func filter(includeElement: (T) -> Bool) -> ContiguousArray<T>","comment":"Return a ContiguousArray containing the elements `x` of `self` for which\n`includeElement(x)` is `true`"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"withUnsafeBufferPointer","slug":"withUnsafeBufferPointer","generic":{"line":"R","types":[]},"params":[{"name":"body","type":"(UnsafeBufferPointer<T>) -> R","note":"","default":"","types":["UnsafeBufferPointer"]}],"ret":{"line":"R","types":[]},"note":"","attr":"","line":"func withUnsafeBufferPointer<R>(body: (UnsafeBufferPointer<T>) -> R) -> R","comment":"Call `body(p)`, where `p` is a pointer to the `ContiguousArray`\\ 's\ncontiguous storage.\n\nOften, the optimizer can eliminate bounds checks within an\narray algorithm, but when that fails, invoking the\nsame algorithm on `body`\\ 's argument lets you trade safety for\nspeed."},{"kind":"func","name":"withUnsafeMutableBufferPointer","slug":"withUnsafeMutableBufferPointer","generic":{"line":"R","types":[]},"params":[{"name":"body","type":"(inout UnsafeMutableBufferPointer<T>) -> R","note":"","default":"","types":["UnsafeMutableBufferPointer"]}],"ret":{"line":"R","types":[]},"note":"mutating","attr":"","line":"mutating func withUnsafeMutableBufferPointer<R>(body: (inout UnsafeMutableBufferPointer<T>) -> R) -> R","comment":"Call `body(p)`, where `p` is a pointer to the `ContiguousArray`\\ 's\nmutable contiguous storage.\n\nOften, the optimizer can eliminate bounds- and uniqueness-checks\nwithin an array algorithm, but when that fails, invoking the\nsame algorithm on `body`\\ 's argument lets you trade safety for\nspeed."},{"kind":"func","name":"replaceRange","slug":"replaceRange","generic":{"line":"C : CollectionType where T == T","types":["CollectionType"]},"params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]},{"name":"newElements","type":"C","note":"with","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func replaceRange<C : CollectionType where T == T>(subRange: Range<Int>, with newElements: C)","comment":"Replace the given `subRange` of elements with `newElements`.\n\nComplexity: O(\\ `countElements(subRange)`\\ ) if `subRange.endIndex\n== self.endIndex` and `isEmpty(newElements)`\\ , O(N) otherwise."},{"kind":"func","name":"splice","slug":"splice","generic":{"line":"S : CollectionType where T == T","types":["CollectionType"]},"params":[{"name":"newElements","type":"S","note":"","default":"","types":[]},{"name":"i","type":"Int","note":"atIndex","default":"","types":["Int"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func splice<S : CollectionType where T == T>(newElements: S, atIndex i: Int)","comment":"Insert `newElements` at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `count + countElements(newElements)`\\ )."},{"kind":"func","name":"removeRange","slug":"removeRange","generic":{},"params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeRange(subRange: Range<Int>)","comment":"Remove the indicated `subRange` of elements\n\nComplexity: O(\\ `count`\\ )."}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"Always zero, which is the index of the first element when non-empty."},{"kind":"var","name":"endIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"A \"past-the-end\" element index; the successor of the last valid\nsubscript argument."},{"kind":"var","name":"count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"How many elements the ContiguousArray stores"},{"kind":"var","name":"capacity","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"How many elements the `ContiguousArray` can store without reallocation"},{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` if and only if the `ContiguousArray` is empty"},{"kind":"var","name":"first","type":"T?","readonly":true,"stat":"","subtypes":[],"comment":"The first element, or `nil` if the array is empty"},{"kind":"var","name":"last","type":"T?","readonly":true,"stat":"","subtypes":[],"comment":"The last element, or `nil` if the array is empty"},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[{"kind":"typealias","name":"Element","type":"T","proto":"","comment":"The type of element stored by this `ContiguousArray`"},{"kind":"typealias","name":"SubSlice","type":"Slice<T>","proto":"","comment":"A type that can represent a sub-range of a ContiguousArray "}],"inits":[{"kind":"init","generic":{},"params":[{"name":"buffer","type":"_ContiguousArrayBuffer<T>","note":"_","default":"","types":["_ContiguousArrayBuffer"]}],"init":"init","note":"","comment":"Initialization from an existing buffer does not have \"array.init\"\nsemantics because the caller may retain an alias to buffer."},{"kind":"init","generic":{},"params":[{"name":"elements","type":"T...","note":"arrayLiteral","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance containing `elements`."},{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Construct an empty ContiguousArray"},{"kind":"init","generic":{"line":"S : SequenceType where T == T","types":["SequenceType"]},"params":[{"name":"s","type":"S","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct from an arbitrary sequence with elements of type `T`"},{"kind":"init","generic":{},"params":[{"name":"count","type":"Int","note":"","default":"","types":["Int"]},{"name":"repeatedValue","type":"T","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Construct a ContiguousArray of `count` elements, each initialized to\n`repeatedValue`."}],"subscripts":[{"kind":"subscript","params":[{"name":"index","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T","types":[]},"comment":""},{"kind":"subscript","params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]}],"ret":{"line":"Slice<T>","types":["Slice"]},"comment":""}],"comment":"A fast, contiguously-stored array of `T`.\n\nEfficiency is equivalent to that of `Array`, unless `T` is a\n`class` or `@objc` `protocol` type, in which case using\n`ContiguousArray` may be more efficient.  Note, however, that\n`ContiguousArray` does not bridge to Objective-C.  See `Array`,\nwith which `ContiguousArray` shares most properties, for more\ndetail."},"DebugPrintable":{"kind":"protocol","name":"DebugPrintable","slug":"DebugPrintable","inherits":[],"inherited":["Array","AutoreleasingUnsafeMutablePointer","CFunctionPointer","COpaquePointer","CVaListPointer","ClosedInterval","ContiguousArray","Dictionary","HalfOpenInterval","Optional","Range","Slice","StaticString","String","UnicodeScalar","UnsafeBufferPointer","UnsafeMutableBufferPointer","UnsafeMutablePointer","UnsafePointer"],"attr":"","operators":[],"functions":[],"types":[],"properties":[{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[],"subscripts":[],"comment":"A type with a customized textual representation for debugging\npurposes.\n\nThis textual representation is used when objects are written to an\n*output stream* by `debugPrint` and `debugPrintln`, and is\ntypically more verbose than the text provided by a `Printable`\\ 's\n`description` property."},"Dictionary":{"kind":"struct","name":"Dictionary","slug":"Dictionary","inherits":["CollectionType","DictionaryLiteralConvertible","Printable","DebugPrintable","Reflectable"],"inherited":[],"generic":{"line":"Key : Hashable, Value","types":["Hashable","Key","Value"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"indexForKey","slug":"indexForKey","generic":{},"params":[{"name":"key","type":"Key","note":"","default":"","types":["Key"]}],"ret":{"line":"DictionaryIndex<Key, Value>?","types":["DictionaryIndex","Key","Value"]},"note":"","attr":"","line":"func indexForKey(key: Key) -> DictionaryIndex<Key, Value>?","comment":"Returns the `Index` for the given key, or `nil` if the key is not\npresent in the dictionary."},{"kind":"func","name":"updateValue","slug":"updateValue","generic":{},"params":[{"name":"value","type":"Value","note":"","default":"","types":["Value"]},{"name":"key","type":"Key","note":"forKey","default":"","types":["Key"]}],"ret":{"line":"Value?","types":["Value"]},"note":"mutating","attr":"","line":"mutating func updateValue(value: Value, forKey key: Key) -> Value?","comment":"Update the value stored in the dictionary for the given key, or, if they\nkey does not exist, add a new key-value pair to the dictionary.\n\nReturns the value that was replaced, or `nil` if a new key-value pair\nwas added."},{"kind":"func","name":"removeAtIndex","slug":"removeAtIndex","generic":{},"params":[{"name":"index","type":"DictionaryIndex<Key, Value>","note":"","default":"","types":["DictionaryIndex","Key","Value"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeAtIndex(index: DictionaryIndex<Key, Value>)","comment":"Remove the key-value pair at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `count`\\ )."},{"kind":"func","name":"removeValueForKey","slug":"removeValueForKey","generic":{},"params":[{"name":"key","type":"Key","note":"","default":"","types":["Key"]}],"ret":{"line":"Value?","types":["Value"]},"note":"mutating","attr":"","line":"mutating func removeValueForKey(key: Key) -> Value?","comment":"Remove a given key and the associated value from the dictionary.\nReturns the value that was removed, or `nil` if the key was not present\nin the dictionary."},{"kind":"func","name":"removeAll","slug":"removeAll","generic":{},"params":[{"name":"keepCapacity","type":"Bool","note":"","default":"default","types":["Bool"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeAll(keepCapacity: Bool = default)","comment":"Remove all elements.\n\nPostcondition: `capacity == 0` iff `keepCapacity` is `false`.\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `count`\\ )."},{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"DictionaryGenerator<Key, Value>","types":["DictionaryGenerator","Key","Value"]},"note":"","attr":"","line":"func generate() -> DictionaryGenerator<Key, Value>","comment":"Return a *generator* over the (key, value) pairs.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"DictionaryIndex<Key, Value>","readonly":true,"stat":"","subtypes":["DictionaryIndex","Key","Value"],"comment":"The position of the first element in a non-empty dictionary.\n\nIdentical to `endIndex` in an empty dictionary\n\nComplexity: amortized O(1) if `self` does not wrap a bridged\n`NSDictionary`, O(N) otherwise."},{"kind":"var","name":"endIndex","type":"DictionaryIndex<Key, Value>","readonly":true,"stat":"","subtypes":["DictionaryIndex","Key","Value"],"comment":"The collection's \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`.\n\nComplexity: amortized O(1) if `self` does not wrap a bridged\n`NSDictionary`, O(N) otherwise."},{"kind":"var","name":"count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The number of entries in the dictionary.\n\nComplexity: O(1)"},{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"True iff `count == 0`"},{"kind":"var","name":"keys","type":"LazyBidirectionalCollection<MapCollectionView<[Key : Value], Key>>","readonly":true,"stat":"","subtypes":["Key","LazyBidirectionalCollection","MapCollectionView","Value"],"comment":"A collection containing just the keys of `self`\n\nKeys appear in the same order as they occur as the `.0` member\nof key-value pairs in `self`.  Each key in the result has a\nunique value."},{"kind":"var","name":"values","type":"LazyBidirectionalCollection<MapCollectionView<[Key : Value], Value>>","readonly":true,"stat":"","subtypes":["Key","LazyBidirectionalCollection","MapCollectionView","Value"],"comment":"A collection containing just the values of `self`\n\nValues appear in the same order as they occur as the `.1` member\nof key-value pairs in `self`."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[{"kind":"typealias","name":"Element","type":"(Key, Value)","proto":"","comment":""},{"kind":"typealias","name":"Index","type":"DictionaryIndex<Key, Value>","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create a dictionary with at least the given number of\nelements worth of storage.  The actual capacity will be the\nsmallest power of 2 that's >= `minimumCapacity`."},{"kind":"init","generic":{},"params":[{"name":"minimumCapacity","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"Create a dictionary with at least the given number of\nelements worth of storage.  The actual capacity will be the\nsmallest power of 2 that's >= `minimumCapacity`."},{"kind":"init","generic":{},"params":[{"name":"elements","type":"(Key, Value)...","note":"dictionaryLiteral","default":"","types":["Key","Value"]}],"init":"init","note":"","comment":"Create an instance initialized with `elements`."}],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"DictionaryIndex<Key, Value>","note":"","default":"","types":["DictionaryIndex","Key","Value"]}],"ret":{"line":"(Key, Value) { get }","types":["Key","Value"]},"comment":""},{"kind":"subscript","params":[{"name":"key","type":"Key","note":"","default":"","types":["Key"]}],"ret":{"line":"Value?","types":["Value"]},"comment":""}],"comment":"A hash-based mapping from `Key` to `Value` instances.  Also a\ncollection of key-value pairs with no defined ordering."},"DictionaryGenerator":{"kind":"struct","name":"DictionaryGenerator","slug":"DictionaryGenerator","inherits":["GeneratorType"],"inherited":[],"generic":{"line":"Key : Hashable, Value","types":["Hashable","Key","Value"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"(Key, Value)?","types":["Key","Value"]},"note":"mutating","attr":"","line":"mutating func next() -> (Key, Value)?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: no preceding call to `self.next()` has returned `nil`."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A generator over the key-value pairs of a `Dictionary<Key, Value>`"},"DictionaryIndex":{"kind":"struct","name":"DictionaryIndex","slug":"DictionaryIndex","inherits":["BidirectionalIndexType","Comparable"],"inherited":[],"generic":{"line":"Key : Hashable, Value","types":["Hashable","Key","Value"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"DictionaryIndex<Key, Value>","types":["DictionaryIndex","Key","Value"]},"note":"","attr":"","line":"func predecessor() -> DictionaryIndex<Key, Value>","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"DictionaryIndex<Key, Value>","types":["DictionaryIndex","Key","Value"]},"note":"","attr":"","line":"func successor() -> DictionaryIndex<Key, Value>","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Index","type":"DictionaryIndex<Key, Value>","proto":"","comment":"Identical to `self.dynamicType`"}],"inits":[],"subscripts":[],"comment":"Used to access the key-value pairs in an instance of\n`Dictionary<Key,Value>`.\n\nRemember that Dictionary has two subscripting interfaces:\n\n1. Subscripting with a key, yielding an optional value::\n\n     v = d[k]!\n\n2. Subscripting with an index, yielding a key-value pair:\n\n     (k,v) = d[i]"},"DictionaryLiteralConvertible":{"kind":"protocol","name":"DictionaryLiteralConvertible","slug":"DictionaryLiteralConvertible","inherits":[],"inherited":["Dictionary"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Key","type":"","proto":"","comment":""},{"kind":"typealias","name":"Value","type":"","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"elements","type":"(Key, Value)...","note":"dictionaryLiteral","default":"","types":["Key","Value"]}],"init":"init","note":"","comment":"Create an instance initialized with `elements`."}],"subscripts":[],"comment":"Conforming types can be initialized with dictionary literals"},"Double":{"kind":"struct","name":"Double","slug":"Double","inherits":["Printable","FloatingPointType","IntegerLiteralConvertible","FloatLiteralConvertible","Comparable","Hashable","AbsoluteValuable","Strideable","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"abs","slug":"abs","generic":{},"params":[{"name":"x","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"note":"static","attr":"","line":"static func abs(x: Double) -> Double","comment":"Returns the absolute value of `x`"},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"note":"","attr":"","line":"func distanceTo(other: Double) -> Double","comment":"Returns a stride `x` such that `self.advancedBy(x)` approximates\n`other`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Double","note":"","default":"","types":["Double"]}],"ret":{"line":"Double","types":["Double"]},"note":"","attr":"","line":"func advancedBy(amount: Double) -> Double","comment":"Returns a `Self` `x` such that `self.distanceTo(x)` approximates\n`n`.\n\nComplexity: O(1)."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"infinity","type":"Double","readonly":true,"stat":"static","subtypes":["Double"],"comment":"The positive infinity."},{"kind":"var","name":"NaN","type":"Double","readonly":true,"stat":"static","subtypes":["Double"],"comment":"A quiet NaN."},{"kind":"var","name":"quietNaN","type":"Double","readonly":true,"stat":"static","subtypes":["Double"],"comment":"A quiet NaN."},{"kind":"var","name":"isSignMinus","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is negative"},{"kind":"var","name":"isNormal","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is normal (not zero, subnormal, infinity, or\nNaN)."},{"kind":"var","name":"isFinite","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is zero, subnormal, or normal (not infinity\nor NaN)."},{"kind":"var","name":"isZero","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is +0.0 or -0.0."},{"kind":"var","name":"isSubnormal","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is subnormal."},{"kind":"var","name":"isInfinite","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is infinity."},{"kind":"var","name":"isNaN","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is NaN."},{"kind":"var","name":"isSignaling","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is a signaling NaN."},{"kind":"var","name":"floatingPointClass","type":"FloatingPointClassification","readonly":true,"stat":"","subtypes":["FloatingPointClassification"],"comment":"The IEEE 754 \"class\" of this type."},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int64","note":"integerLiteral","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.FPIEEE80","note":"_builtinFloatLiteral","default":"","types":["Builtin","FPIEEE80"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Double","note":"floatLiteral","default":"","types":["Double"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."}],"subscripts":[],"comment":""},"EmptyCollection":{"kind":"struct","name":"EmptyCollection","slug":"EmptyCollection","inherits":["CollectionType","Reflectable"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"EmptyGenerator<T>","types":["EmptyGenerator"]},"note":"","attr":"","line":"func generate() -> EmptyGenerator<T>","comment":"Returns an empty *generator*.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"Always zero, just like `endIndex`."},{"kind":"var","name":"endIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"Always zero, just like `startIndex`."}],"aliases":[{"kind":"typealias","name":"Index","type":"Int","proto":"","comment":"A type that represents a valid position in the collection.\n\nValid indices consist of the position of every element and a\n\"past the end\" position that's not valid for use as a subscript."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Construct an instance."}],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"Index","note":"","default":"","types":["Index"]}],"ret":{"line":"T { get }","types":[]},"comment":""}],"comment":"A collection whose element type is `T` but that is always empty."},"EmptyGenerator":{"kind":"struct","name":"EmptyGenerator","slug":"EmptyGenerator","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"EmptyGenerator<T>","types":["EmptyGenerator"]},"note":"","attr":"","line":"func generate() -> EmptyGenerator<T>","comment":"`EmptyGenerator` is also a `SequenceType`, so it `generate`\\ 's\na copy of itself"},{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"T?","types":[]},"note":"mutating","attr":"","line":"mutating func next() -> T?","comment":"Return `nil`, indicating that there are no more elements."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A generator that never produces an element.\n\nSee also: `EmptyCollection<T>`."},"EnumerateGenerator":{"kind":"struct","name":"EnumerateGenerator","slug":"EnumerateGenerator","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"Base : GeneratorType","types":["Base","GeneratorType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"Element?","types":["Element"]},"note":"mutating","attr":"","line":"mutating func next() -> Element?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: no preceding call to `self.next()` has returned `nil`."},{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"EnumerateGenerator<Base>","types":["Base","EnumerateGenerator"]},"note":"","attr":"","line":"func generate() -> EnumerateGenerator<Base>","comment":"`EnumerateGenerator` is also a `SequenceType`, so it `generate`\\\n's a copy of itself"}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Element","type":"(index: Int, element: Base.Element)","proto":"","comment":"The type of element returned by `next()`."},{"kind":"typealias","name":"Generator","type":"EnumerateGenerator<Base>","proto":"","comment":"A type whose instances can produce the elements of this\nsequence, in order."}],"inits":[{"kind":"init","generic":{},"params":[{"name":"base","type":"Base","note":"_","default":"","types":["Base"]}],"init":"init","note":"","comment":"Construct from a `Base` generator"}],"subscripts":[],"comment":"The `GeneratorType` for `EnumerateSequence`.  `EnumerateGenerator`\nwraps a `Base` `GeneratorType` and yields successive `Int` values,\nstarting at zero, along with the elements of the underlying\n`Base`::\n\n  var g = EnumerateGenerator([\"foo\", \"bar\"].generate())\n  g.next() // (0, \"foo\")\n  g.next() // (1, \"bar\")\n  g.next() // nil\n\nNote:: idiomatic usage is to call `enumerate` instead of\nconstructing an `EnumerateGenerator` directly."},"EnumerateSequence":{"kind":"struct","name":"EnumerateSequence","slug":"EnumerateSequence","inherits":["SequenceType"],"inherited":[],"generic":{"line":"Base : SequenceType","types":["Base","SequenceType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"EnumerateGenerator<Base.Generator>","types":["Base","EnumerateGenerator","Generator"]},"note":"","attr":"","line":"func generate() -> EnumerateGenerator<Base.Generator>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"base","type":"Base","note":"_","default":"","types":["Base"]}],"init":"init","note":"","comment":"Construct from a `Base` sequence"}],"subscripts":[],"comment":"The `SequenceType` returned by `enumerate()`.  `EnumerateSequence`\nis a sequence of pairs (*n*, *x*), where *n*\\ s are consecutive\n`Int`\\ s starting at zero, and *x*\\ s are the elements of a `Base`\n`SequenceType`::\n\n  var s = EnumerateSequence([\"foo\", \"bar\"])\n  Array(s) // [(0, \"foo\"), (1, \"bar\")]\n\nNote:: idiomatic usage is to call `enumerate` instead of\nconstructing an `EnumerateSequence` directly."},"Equatable":{"kind":"protocol","name":"Equatable","slug":"Equatable","inherits":[],"inherited":["AutoreleasingUnsafeMutablePointer","Bool","CFunctionPointer","COpaquePointer","Character","ClosedInterval","Comparable","FloatingPointClassification","HalfOpenInterval","Hashable","HeapBuffer","Range","String","_Incrementable","_RawOptionSetType"],"attr":"","operators":[],"functions":[{"kind":"operator func","name":"==","slug":"eqeq","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func ==(lhs: Self, rhs: Self) -> Bool","comment":"Return true if `lhs` is equal to `rhs`.\n\n**Equality implies substitutability**.  When `x == y`, `x` and\n`y` are interchangeable in any code that only depends on their\nvalues.\n\nClass instance identity as distinguished by triple-equals `===`\nis notably not part of an instance's value.  Exposing other\nnon-value aspects of `Equatable` types is discouraged, and any\nthat *are* exposed should be explicitly pointed out in\ndocumentation.\n\n**Equality is an equivalence relation**\n\n- `x == x` is `true`\n- `x == y` implies `y == x`\n- `x == y` and `y == z` implies `x == z`\n\n**Inequality is the inverse of equality**, i.e. `!(x == y)` iff\n`x != y`"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"Instances of conforming types can be compared for value equality\nusing operators `==` and `!=`.\n\nWhen adopting `Equatable`, only the `==` operator is required to be\nimplemented.  The standard library provides an implementation for `!=`."},"ExtendedGraphemeClusterLiteralConvertible":{"kind":"protocol","name":"ExtendedGraphemeClusterLiteralConvertible","slug":"ExtendedGraphemeClusterLiteralConvertible","inherits":["UnicodeScalarLiteralConvertible"],"inherited":["Character","StaticString","String","StringLiteralConvertible"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"ExtendedGraphemeClusterLiteralType","type":"","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"value","type":"ExtendedGraphemeClusterLiteralType","note":"extendedGraphemeClusterLiteral","default":"","types":["ExtendedGraphemeClusterLiteralType"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."}],"subscripts":[],"comment":"Conforming types can be initialized with string literals\ncontaining a single Unicode extended grapheme cluster."},"ExtensibleCollectionType":{"kind":"protocol","name":"ExtensibleCollectionType","slug":"ExtensibleCollectionType","inherits":["_ExtensibleCollectionType"],"inherited":["RangeReplaceableCollectionType","String"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A collection type that can be efficiently appended-to."},"FilterCollectionView":{"kind":"struct","name":"FilterCollectionView","slug":"FilterCollectionView","inherits":["CollectionType"],"inherited":[],"generic":{"line":"Base : CollectionType","types":["Base","CollectionType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"FilterGenerator<Base.Generator>","types":["Base","FilterGenerator","Generator"]},"note":"","attr":"","line":"func generate() -> FilterGenerator<Base.Generator>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"FilterCollectionViewIndex<Base>","readonly":true,"stat":"","subtypes":["Base","FilterCollectionViewIndex"],"comment":"The position of the first element in a non-empty collection.\n\nIdentical to `endIndex` in an empty collection.\n\nComplexity: O(N), where N is the ratio between unfiltered and\nfiltered collection counts."},{"kind":"var","name":"endIndex","type":"FilterCollectionViewIndex<Base>","readonly":true,"stat":"","subtypes":["Base","FilterCollectionViewIndex"],"comment":"The collection's \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`.\n\nComplexity: O(1)"}],"aliases":[{"kind":"typealias","name":"Index","type":"FilterCollectionViewIndex<Base>","proto":"","comment":"A type that represents a valid position in the collection.\n\nValid indices consist of the position of every element and a\n\"past the end\" position that's not valid for use as a subscript."}],"inits":[{"kind":"init","generic":{},"params":[{"name":"base","type":"Base","note":"_","default":"","types":["Base"]},{"name":"predicate","type":"(Base.Generator.Element) -> Bool","note":"includeElement","default":"","types":["Base","Bool","Element","Generator"]}],"init":"init","note":"","comment":"Construct an instance containing the elements of `base` that\nsatisfy `predicate`."}],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"FilterCollectionViewIndex<Base>","note":"","default":"","types":["Base","FilterCollectionViewIndex"]}],"ret":{"line":"Base.Generator.Element { get }","types":["Base","Element","Generator"]},"comment":""}],"comment":"A lazy `CollectionType` wrapper that includes the elements of an\nunderlying collection that satisfy a predicate.  Not\nautomatically returned by `filter(x)` for two reasons:\n\n* The O(1) guarantee of our `Index` would be iffy at best, since\n  it advances an underlying `Index` until the predicate is\n  satisfied.  Be aware that a `FilterCollectionView` may not offer\n  the expected efficiency for this reason.\n\n* Constructing an `Array` from a `CollectionType` measures the length\n  of the collection before traversing it to read the elements.\n  This causes the filter predicate to be called twice for each\n  element of the underlying collection, which is surprising."},"FilterCollectionViewIndex":{"kind":"struct","name":"FilterCollectionViewIndex","slug":"FilterCollectionViewIndex","inherits":["ForwardIndexType"],"inherited":[],"generic":{"line":"Base : CollectionType","types":["Base","CollectionType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"FilterCollectionViewIndex<Base>","types":["Base","FilterCollectionViewIndex"]},"note":"","attr":"","line":"func successor() -> FilterCollectionViewIndex<Base>","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"The `Index` used for subscripting a `FilterCollectionView`"},"FilterGenerator":{"kind":"struct","name":"FilterGenerator","slug":"FilterGenerator","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"Base : GeneratorType","types":["Base","GeneratorType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"Base.Element?","types":["Base","Element"]},"note":"mutating","attr":"","line":"mutating func next() -> Base.Element?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: `next()` has not been applied to a copy of `self`\nsince the copy was made, and no preceding call to `self.next()`\nhas returned `nil`."},{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"FilterGenerator<Base>","types":["Base","FilterGenerator"]},"note":"","attr":"","line":"func generate() -> FilterGenerator<Base>","comment":"`FilterGenerator` is also a `SequenceType`, so it `generate`\\ 's\na copy of itself"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"The `GeneratorType` used by `FilterSequenceView` and\n`FilterCollectionView`"},"FilterSequenceView":{"kind":"struct","name":"FilterSequenceView","slug":"FilterSequenceView","inherits":["SequenceType"],"inherited":[],"generic":{"line":"Base : SequenceType","types":["Base","SequenceType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"FilterGenerator<Base.Generator>","types":["Base","FilterGenerator","Generator"]},"note":"","attr":"","line":"func generate() -> FilterGenerator<Base.Generator>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"The lazy `SequenceType` returned by `filter(c)` where `c` is a\n`SequenceType`"},"Float":{"kind":"struct","name":"Float","slug":"Float","inherits":["Printable","FloatingPointType","IntegerLiteralConvertible","FloatLiteralConvertible","Comparable","Hashable","AbsoluteValuable","Strideable","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"abs","slug":"abs","generic":{},"params":[{"name":"x","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"note":"static","attr":"","line":"static func abs(x: Float) -> Float","comment":"Returns the absolute value of `x`"},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"note":"","attr":"","line":"func distanceTo(other: Float) -> Float","comment":"Returns a stride `x` such that `self.advancedBy(x)` approximates\n`other`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Float","note":"","default":"","types":["Float"]}],"ret":{"line":"Float","types":["Float"]},"note":"","attr":"","line":"func advancedBy(amount: Float) -> Float","comment":"Returns a `Self` `x` such that `self.distanceTo(x)` approximates\n`n`.\n\nComplexity: O(1)."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"infinity","type":"Float","readonly":true,"stat":"static","subtypes":["Float"],"comment":"The positive infinity."},{"kind":"var","name":"NaN","type":"Float","readonly":true,"stat":"static","subtypes":["Float"],"comment":"A quiet NaN."},{"kind":"var","name":"quietNaN","type":"Float","readonly":true,"stat":"static","subtypes":["Float"],"comment":"A quiet NaN."},{"kind":"var","name":"isSignMinus","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is negative"},{"kind":"var","name":"isNormal","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is normal (not zero, subnormal, infinity, or\nNaN)."},{"kind":"var","name":"isFinite","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is zero, subnormal, or normal (not infinity\nor NaN)."},{"kind":"var","name":"isZero","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is +0.0 or -0.0."},{"kind":"var","name":"isSubnormal","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is subnormal."},{"kind":"var","name":"isInfinite","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is infinity."},{"kind":"var","name":"isNaN","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is NaN."},{"kind":"var","name":"isSignaling","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is a signaling NaN."},{"kind":"var","name":"floatingPointClass","type":"FloatingPointClassification","readonly":true,"stat":"","subtypes":["FloatingPointClassification"],"comment":"The IEEE 754 \"class\" of this type."},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int64","note":"integerLiteral","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.FPIEEE80","note":"_builtinFloatLiteral","default":"","types":["Builtin","FPIEEE80"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Float","note":"floatLiteral","default":"","types":["Float"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."}],"subscripts":[],"comment":""},"Float80":{"kind":"struct","name":"Float80","slug":"Float80","inherits":["Printable","IntegerLiteralConvertible","FloatLiteralConvertible","Comparable","Hashable","AbsoluteValuable","Strideable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"abs","slug":"abs","generic":{},"params":[{"name":"x","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"note":"static","attr":"","line":"static func abs(x: Float80) -> Float80","comment":"Returns the absolute value of `x`"},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"note":"","attr":"","line":"func distanceTo(other: Float80) -> Float80","comment":"Returns a stride `x` such that `self.advancedBy(x)` approximates\n`other`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Float80","note":"","default":"","types":["Float80"]}],"ret":{"line":"Float80","types":["Float80"]},"note":"","attr":"","line":"func advancedBy(amount: Float80) -> Float80","comment":"Returns a `Self` `x` such that `self.distanceTo(x)` approximates\n`n`.\n\nComplexity: O(1)."}],"types":[],"properties":[{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int64","note":"integerLiteral","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.FPIEEE80","note":"_builtinFloatLiteral","default":"","types":["Builtin","FPIEEE80"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Float80","note":"floatLiteral","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."}],"subscripts":[],"comment":""},"FloatLiteralConvertible":{"kind":"protocol","name":"FloatLiteralConvertible","slug":"FloatLiteralConvertible","inherits":[],"inherited":["Double","Float","Float80"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"FloatLiteralType","type":"","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"value","type":"FloatLiteralType","note":"floatLiteral","default":"","types":["FloatLiteralType"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."}],"subscripts":[],"comment":"Conforming types can be initialized with floating point literals"},"FloatingPointClassification":{"kind":"enum","name":"FloatingPointClassification","slug":"FloatingPointClassification","inherits":["Equatable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"The set of possible IEEE 754 \"classes\"","cases":[{"kind":"case","name":"SignalingNaN","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"QuietNaN","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"NegativeInfinity","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"NegativeNormal","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"NegativeSubnormal","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"NegativeZero","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"PositiveZero","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"PositiveSubnormal","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"PositiveNormal","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"PositiveInfinity","associated":"","subtypes":[],"comment":""}]},"FloatingPointType":{"kind":"protocol","name":"FloatingPointType","slug":"FloatingPointType","inherits":["Strideable"],"inherited":["Double","Float"],"attr":"","operators":[],"functions":[{"kind":"func","name":"_fromBitPattern","slug":"_fromBitPattern","generic":{},"params":[{"name":"bits","type":"_BitsType","note":"","default":"","types":["_BitsType"]}],"ret":{"line":"Self","types":["Self"]},"note":"class","attr":"","line":"class func _fromBitPattern(bits: _BitsType) -> Self","comment":""},{"kind":"func","name":"_toBitPattern","slug":"_toBitPattern","generic":{},"params":[],"ret":{"line":"_BitsType","types":["_BitsType"]},"note":"","attr":"","line":"func _toBitPattern() -> _BitsType","comment":""}],"types":[],"properties":[{"kind":"var","name":"infinity","type":"Self","readonly":true,"stat":"class","subtypes":["Self"],"comment":"The positive infinity."},{"kind":"var","name":"NaN","type":"Self","readonly":true,"stat":"class","subtypes":["Self"],"comment":"A quiet NaN."},{"kind":"var","name":"quietNaN","type":"Self","readonly":true,"stat":"class","subtypes":["Self"],"comment":"A quiet NaN."},{"kind":"var","name":"floatingPointClass","type":"FloatingPointClassification","readonly":true,"stat":"","subtypes":["FloatingPointClassification"],"comment":"@{\nIEEE 754-2008 Non-computational operations.\nThe IEEE 754 \"class\" of this type."},{"kind":"var","name":"isSignMinus","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is negative"},{"kind":"var","name":"isNormal","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is normal (not zero, subnormal, infinity, or\nNaN)."},{"kind":"var","name":"isFinite","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is zero, subnormal, or normal (not infinity\nor NaN)."},{"kind":"var","name":"isZero","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is +0.0 or -0.0."},{"kind":"var","name":"isSubnormal","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is subnormal."},{"kind":"var","name":"isInfinite","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is infinity."},{"kind":"var","name":"isNaN","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is NaN."},{"kind":"var","name":"isSignaling","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` is a signaling NaN."}],"aliases":[{"kind":"typealias","name":"_BitsType","type":"","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."}],"subscripts":[],"comment":"A set of common requirements for Swift's floating point types."},"ForwardIndexType":{"kind":"protocol","name":"ForwardIndexType","slug":"ForwardIndexType","inherits":["_ForwardIndexType"],"inherited":["BidirectionalIndexType","FilterCollectionViewIndex","String.UTF8View.Index"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"Represents a discrete value in a series, where a value's\nsuccessor, if any, is reachable by applying the value's\n`successor()` method."},"GeneratorOf":{"kind":"struct","name":"GeneratorOf","slug":"GeneratorOf","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"T?","types":[]},"note":"mutating","attr":"","line":"mutating func next() -> T?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: `next()` has not been applied to a copy of `self`\nsince the copy was made, and no preceding call to `self.next()`\nhas returned `nil`."},{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"GeneratorOf<T>","types":["GeneratorOf"]},"note":"","attr":"","line":"func generate() -> GeneratorOf<T>","comment":"`GeneratorOf<T>` is also a `SequenceType`, so it `generate`\\\n's a copy of itself"}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"nextElement","type":"() -> T?","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance whose `next()` method calls `nextElement`."},{"kind":"init","generic":{"line":"G : GeneratorType where T == T","types":["GeneratorType"]},"params":[{"name":"base","type":"G","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance whose `next()` method pulls its results\nfrom `base`."}],"subscripts":[],"comment":"A type-erased generator.\n\nThe generator for `SequenceOf<T>`.  Forwards operations to an\narbitrary underlying generator with the same `Element` type,\nhiding the specifics of the underlying generator type.\n\nSee also: `SequenceOf<T>`."},"GeneratorOfOne":{"kind":"struct","name":"GeneratorOfOne","slug":"GeneratorOfOne","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"GeneratorOfOne<T>","types":["GeneratorOfOne"]},"note":"","attr":"","line":"func generate() -> GeneratorOfOne<T>","comment":"`GeneratorOfOne` is also a `SequenceType`, so it `generate`\\\n's a copy of itself"},{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"T?","types":[]},"note":"mutating","attr":"","line":"mutating func next() -> T?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: `next()` has not been applied to a copy of `self`\nsince the copy was made, and no preceding call to `self.next()`\nhas returned `nil`."}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"element","type":"T?","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance that generates `element!`, or an empty\nsequence if `element == nil`."}],"subscripts":[],"comment":"A generator that produces one or fewer instances of `T`."},"GeneratorSequence":{"kind":"struct","name":"GeneratorSequence","slug":"GeneratorSequence","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"G : GeneratorType","types":["GeneratorType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"G.Element?","types":["Element"]},"note":"mutating","attr":"","line":"mutating func next() -> G.Element?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: `next()` has not been applied to a copy of `self`\nsince the copy was made, and no preceding call to `self.next()`\nhas returned `nil`."},{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"GeneratorSequence<G>","types":["GeneratorSequence"]},"note":"","attr":"","line":"func generate() -> GeneratorSequence<G>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"base","type":"G","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance whose generator is a copy of `base`."}],"subscripts":[],"comment":"A sequence built around a generator of type `G`.\n\nUseful mostly to recover the ability to use `for`\\ ...\\ `in`,\ngiven just a generator `g`::\n\n  for x in GeneratorSequence(g) { ... }"},"GeneratorType":{"kind":"protocol","name":"GeneratorType","slug":"GeneratorType","inherits":[],"inherited":["DictionaryGenerator","EmptyGenerator","EnumerateGenerator","FilterGenerator","GeneratorOf","GeneratorOfOne","GeneratorSequence","IndexingGenerator","MapSequenceGenerator","PermutationGenerator","RangeGenerator","StrideThroughGenerator","StrideToGenerator","UnsafeBufferPointerGenerator","ZipGenerator2","String.UnicodeScalarView.Generator"],"attr":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"Element?","types":["Element"]},"note":"mutating","attr":"","line":"mutating func next() -> Element?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: `next()` has not been applied to a copy of `self`\nsince the copy was made, and no preceding call to `self.next()`\nhas returned `nil`.  Specific implementations of this protocol\nare encouraged to respond to violations of this requirement by\ncalling `preconditionFailure(\"...\")`."}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Element","type":"","proto":"","comment":"The type of element generated by `self`."}],"inits":[],"subscripts":[],"comment":"Encapsulates iteration state and interface for iteration over a\n*sequence*.\n\n**Note:** While it is safe to copy a *generator*, advancing one\ncopy may invalidate the others.\n\nAny code that uses multiple generators (or `for`\\ ...\\ `in` loops)\nover a single *sequence* should have static knowledge that the\nspecific *sequence* is multi-pass, either because its concrete\ntype is known or because it is constrained to `CollectionType`.\nAlso, the generators must be obtained by distinct calls to the\n*sequence's* `generate()` method, rather than by copying."},"HalfOpenInterval":{"kind":"struct","name":"HalfOpenInterval","slug":"HalfOpenInterval","inherits":["IntervalType","Equatable","Printable","DebugPrintable","Reflectable"],"inherited":[],"generic":{"line":"T : Comparable","types":["Comparable"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"contains","slug":"contains","generic":{},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func contains(x: T) -> Bool","comment":"Returns `true` iff the `Interval` contains `x`"},{"kind":"func","name":"clamp","slug":"clamp","generic":{},"params":[{"name":"intervalToClamp","type":"HalfOpenInterval<T>","note":"","default":"","types":["HalfOpenInterval"]}],"ret":{"line":"HalfOpenInterval<T>","types":["HalfOpenInterval"]},"note":"","attr":"","line":"func clamp(intervalToClamp: HalfOpenInterval<T>) -> HalfOpenInterval<T>","comment":"Return `intervalToClamp` clamped to `self`.  The bounds of the\nresult, even if it is empty, are always limited to the bounds of\n`self`"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"start","type":"T","readonly":true,"stat":"","subtypes":[],"comment":"The `Interval`\\ 's lower bound. Invariant: `start` <= `end`"},{"kind":"var","name":"end","type":"T","readonly":true,"stat":"","subtypes":[],"comment":"The `Interval`\\ 's upper bound. Invariant: `start` <= `end`"},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."},{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff the `Interval` is empty."}],"aliases":[{"kind":"typealias","name":"Bound","type":"T","proto":"","comment":"The type of the `Interval`\\ 's endpoints"}],"inits":[{"kind":"init","generic":{},"params":[{"name":"x","type":"HalfOpenInterval<T>","note":"_","default":"","types":["HalfOpenInterval"]}],"init":"init","note":"","comment":"Construct a copy of `x`"},{"kind":"init","generic":{},"params":[{"name":"start","type":"T","note":"_","default":"","types":[]},{"name":"end","type":"T","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an interval with the given bounds.  Requires: `start`\n<= `end`."}],"subscripts":[],"comment":""},"Hashable":{"kind":"protocol","name":"Hashable","slug":"Hashable","inherits":["Equatable"],"inherited":["Bool","CFunctionPointer","COpaquePointer","Character","Double","Float","Float80","Int","Int16","Int32","Int64","Int8","ObjectIdentifier","String","UInt","UInt16","UInt32","UInt64","UInt8","UnicodeScalar","UnsafeMutablePointer","UnsafePointer","_IntegerType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."}],"aliases":[],"inits":[],"subscripts":[],"comment":"Instances of conforming types provide an integer `hashValue` and\ncan be used as `Dictionary` keys."},"HeapBuffer":{"kind":"struct","name":"HeapBuffer","slug":"HeapBuffer","inherits":["Equatable"],"inherited":[],"generic":{"line":"Value, Element","types":["Element","Value"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"isUniquelyReferenced","slug":"isUniquelyReferenced","generic":{},"params":[],"ret":{"line":"Bool","types":["Bool"]},"note":"mutating","attr":"","line":"mutating func isUniquelyReferenced() -> Bool","comment":""}],"types":[],"properties":[{"kind":"var","name":"hasStorage","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"True if storage is non-\\ `nil`"}],"aliases":[{"kind":"typealias","name":"Storage","type":"HeapBufferStorage<Value, Element>","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"storageClass","type":"AnyClass","note":"_","default":"","types":["AnyClass"]},{"name":"initializer","type":"Value","note":"_","default":"","types":["Value"]},{"name":"capacity","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":"Create a `HeapBuffer` with `self.value = initializer` and\n`self._capacity() >= capacity`."}],"subscripts":[],"comment":"Management API for `HeapBufferStorage<Value, Element>`"},"HeapBufferStorage":{"kind":"class","name":"HeapBufferStorage","slug":"HeapBufferStorage","inherits":[],"inherited":[],"generic":{"line":"Value, Element","types":["Element","Value"]},"attr":"","note":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Buffer","type":"HeapBuffer<Value, Element>","proto":"","comment":"The type used to actually manage instances of\n`HeapBufferStorage<Value,Element>`"}],"inits":[],"subscripts":[],"comment":"A class containing an ivar \"value\" of type Value, and\ncontaining storage for an array of Element whose size is\ndetermined at create time.\n\nThe analogous C++-ish class template would be::\n\n  template <class Value, class Element>\n  struct HeapBuffer {\n    Value value;\n    Element baseAddress[];        // length determined at creation time\n\n    HeapBuffer() = delete\n    static shared_ptr<HeapBuffer> create(Value init, int capacity);\n  }\n\nNote that the Element array is RAW MEMORY.  You are expected to\nconstruct and---if necessary---destroy Elements there yourself,\neither in a derived class, or it can be in some manager object\nthat owns the HeapBuffer."},"ImplicitlyUnwrappedOptional":{"kind":"enum","name":"ImplicitlyUnwrappedOptional","slug":"ImplicitlyUnwrappedOptional","inherits":["Reflectable","NilLiteralConvertible","Printable","_ObjectiveCBridgeable"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"map","slug":"map","generic":{"line":"U","types":[]},"params":[{"name":"f","type":"(T) -> U","note":"","default":"","types":[]}],"ret":{"line":"U!","types":[]},"note":"","attr":"","line":"func map<U>(f: (T) -> U) -> U!","comment":"If `self == nil`, returns `nil`.  Otherwise, returns `f(self!)`."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Construct a `nil` instance."},{"kind":"init","generic":{},"params":[{"name":"some","type":"T","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct a non-\\ `nil` instance that stores `some`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"T?","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance from an explicitly unwrapped optional\n(`T?`)."},{"kind":"init","generic":{},"params":[{"name":"nilLiteral","type":"()","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance initialized with `nil`."}],"subscripts":[],"comment":"An optional type that allows implicit member access (via compiler\nmagic).\n\nThe compiler has special knowledge of the existence of\nImplicitlyUnwrappedOptional<T>, but always interacts with it using the\nlibrary intrinsics below.","cases":[{"kind":"case","name":"None","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"Some","associated":"(T)","subtypes":[],"comment":""}]},"IndexingGenerator":{"kind":"struct","name":"IndexingGenerator","slug":"IndexingGenerator","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"C : _CollectionType","types":["_CollectionType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"IndexingGenerator<C>","types":["IndexingGenerator"]},"note":"","attr":"","line":"func generate() -> IndexingGenerator<C>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"C._Element?","types":["_Element"]},"note":"mutating","attr":"","line":"mutating func next() -> C._Element?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: no preceding call to `self.next()` has returned `nil`."}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"seq","type":"C","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Create a *generator* over the given collection"}],"subscripts":[],"comment":"A *generator* for an arbitrary *collection*.  Provided `C`\nconforms to the other requirements of *CollectionType*,\n`IndexingGenerator<C>` can be used as the result of `C`\\ 's\n`generate()` method.  For example:\n\n.. parsed-literal::\n\n   struct MyCollection : CollectionType {\n     struct Index : ForwardIndexType { *implementation hidden* }\n     subscript(i: Index) -> MyElement { *implementation hidden* }\n     func generate() -> **IndexingGenerator<MyCollection>** {\n       return IndexingGenerator(self)\n     }\n   }"},"Int":{"kind":"struct","name":"Int","slug":"Int","inherits":["SignedIntegerType","Hashable","Printable","RandomAccessIndexType","SignedNumberType","BitwiseOperationsType","Reflectable","CVarArgType"],"inherited":["Bit"],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func successor() -> Int","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func predecessor() -> Int","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: Int) -> Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func advancedBy(amount: Distance) -> Int","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"_","default":"","types":["Int"]}],"ret":{"line":"(Int, overflow: Bool)","types":["Bool","Int"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: Int, _ rhs: Int) -> (Int, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"_","default":"","types":["Int"]}],"ret":{"line":"(Int, overflow: Bool)","types":["Bool","Int"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: Int, _ rhs: Int) -> (Int, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"_","default":"","types":["Int"]}],"ret":{"line":"(Int, overflow: Bool)","types":["Bool","Int"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: Int, _ rhs: Int) -> (Int, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"_","default":"","types":["Int"]}],"ret":{"line":"(Int, overflow: Bool)","types":["Bool","Int"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: Int, _ rhs: Int) -> (Int, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\na result and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int","note":"","default":"","types":["Int"]},{"name":"rhs","type":"Int","note":"_","default":"","types":["Int"]}],"ret":{"line":"(Int, overflow: Bool)","types":["Bool","Int"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: Int, _ rhs: Int) -> (Int, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\nthe remainder and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Represent this number using Swift's widest native signed\ninteger type."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"value","type":"Builtin.Word","readonly":true,"stat":"","subtypes":["Builtin","Word"],"comment":""},{"kind":"var","name":"bigEndian","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"Returns the big-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"littleEndian","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"Returns the little-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"byteSwapped","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"Returns the current integer with the byte order swapped."},{"kind":"var","name":"max","type":"Int","readonly":true,"stat":"static","subtypes":["Int"],"comment":""},{"kind":"var","name":"min","type":"Int","readonly":true,"stat":"static","subtypes":["Int"],"comment":""},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"allZeros","type":"Int","readonly":true,"stat":"static","subtypes":["Int"],"comment":"The empty bitset of type Int."}],"aliases":[{"kind":"typealias","name":"Distance","type":"Int","proto":"","comment":"A type that can represent the number of steps between pairs of\nvalues."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int","note":"bigEndian","default":"","types":["Int"]}],"init":"init","note":"","comment":"Creates an integer from its big-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int","note":"littleEndian","default":"","types":["Int"]}],"init":"init","note":"","comment":"Creates an integer from its little-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int","note":"integerLiteral","default":"","types":["Int"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt64","note":"","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Construct a `Int` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int64","note":"","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Construct a `Int` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"UInt","note":"","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Construct a `Int` having the same memory representation as\nthe `UInt` `bitPattern`.  No range or overflow checking\noccurs, and the resulting `Int` may not have the same numeric\nvalue as `bitPattern`--it is only guaranteed to use the same\npattern of bits."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."}],"subscripts":[],"comment":"A 64-bit signed integer value\ntype."},"Int16":{"kind":"struct","name":"Int16","slug":"Int16","inherits":["SignedIntegerType","Hashable","Printable","RandomAccessIndexType","SignedNumberType","BitwiseOperationsType","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"Int16","types":["Int16"]},"note":"","attr":"","line":"func successor() -> Int16","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"Int16","types":["Int16"]},"note":"","attr":"","line":"func predecessor() -> Int16","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: Int16) -> Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"Int16","types":["Int16"]},"note":"","attr":"","line":"func advancedBy(amount: Distance) -> Int16","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"_","default":"","types":["Int16"]}],"ret":{"line":"(Int16, overflow: Bool)","types":["Bool","Int16"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: Int16, _ rhs: Int16) -> (Int16, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"_","default":"","types":["Int16"]}],"ret":{"line":"(Int16, overflow: Bool)","types":["Bool","Int16"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: Int16, _ rhs: Int16) -> (Int16, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"_","default":"","types":["Int16"]}],"ret":{"line":"(Int16, overflow: Bool)","types":["Bool","Int16"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: Int16, _ rhs: Int16) -> (Int16, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"_","default":"","types":["Int16"]}],"ret":{"line":"(Int16, overflow: Bool)","types":["Bool","Int16"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: Int16, _ rhs: Int16) -> (Int16, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\na result and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int16","note":"","default":"","types":["Int16"]},{"name":"rhs","type":"Int16","note":"_","default":"","types":["Int16"]}],"ret":{"line":"(Int16, overflow: Bool)","types":["Bool","Int16"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: Int16, _ rhs: Int16) -> (Int16, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\nthe remainder and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Represent this number using Swift's widest native signed\ninteger type."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"value","type":"Builtin.Int16","readonly":true,"stat":"","subtypes":["Builtin","Int16"],"comment":""},{"kind":"var","name":"bigEndian","type":"Int16","readonly":true,"stat":"","subtypes":["Int16"],"comment":"Returns the big-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"littleEndian","type":"Int16","readonly":true,"stat":"","subtypes":["Int16"],"comment":"Returns the little-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"byteSwapped","type":"Int16","readonly":true,"stat":"","subtypes":["Int16"],"comment":"Returns the current integer with the byte order swapped."},{"kind":"var","name":"max","type":"Int16","readonly":true,"stat":"static","subtypes":["Int16"],"comment":""},{"kind":"var","name":"min","type":"Int16","readonly":true,"stat":"static","subtypes":["Int16"],"comment":""},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"allZeros","type":"Int16","readonly":true,"stat":"static","subtypes":["Int16"],"comment":"The empty bitset of type Int16."}],"aliases":[{"kind":"typealias","name":"Distance","type":"Int","proto":"","comment":"A type that can represent the number of steps between pairs of\nvalues."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int16","note":"bigEndian","default":"","types":["Int16"]}],"init":"init","note":"","comment":"Creates an integer from its big-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int16","note":"littleEndian","default":"","types":["Int16"]}],"init":"init","note":"","comment":"Creates an integer from its little-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int16","note":"integerLiteral","default":"","types":["Int16"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt32","note":"","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Construct a `Int16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int32","note":"","default":"","types":["Int32"]}],"init":"init","note":"","comment":"Construct a `Int16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt64","note":"","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Construct a `Int16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int64","note":"","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Construct a `Int16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt","note":"","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Construct a `Int16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"Construct a `Int16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"UInt16","note":"","default":"","types":["UInt16"]}],"init":"init","note":"","comment":"Construct a `Int16` having the same memory representation as\nthe `UInt16` `bitPattern`.  No range or overflow checking\noccurs, and the resulting `Int16` may not have the same numeric\nvalue as `bitPattern`--it is only guaranteed to use the same\npattern of bits."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."}],"subscripts":[],"comment":"A 16-bit signed integer value\ntype."},"Int32":{"kind":"struct","name":"Int32","slug":"Int32","inherits":["SignedIntegerType","Hashable","Printable","RandomAccessIndexType","SignedNumberType","BitwiseOperationsType","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"Int32","types":["Int32"]},"note":"","attr":"","line":"func successor() -> Int32","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"Int32","types":["Int32"]},"note":"","attr":"","line":"func predecessor() -> Int32","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: Int32) -> Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"Int32","types":["Int32"]},"note":"","attr":"","line":"func advancedBy(amount: Distance) -> Int32","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"_","default":"","types":["Int32"]}],"ret":{"line":"(Int32, overflow: Bool)","types":["Bool","Int32"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: Int32, _ rhs: Int32) -> (Int32, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"_","default":"","types":["Int32"]}],"ret":{"line":"(Int32, overflow: Bool)","types":["Bool","Int32"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: Int32, _ rhs: Int32) -> (Int32, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"_","default":"","types":["Int32"]}],"ret":{"line":"(Int32, overflow: Bool)","types":["Bool","Int32"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: Int32, _ rhs: Int32) -> (Int32, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"_","default":"","types":["Int32"]}],"ret":{"line":"(Int32, overflow: Bool)","types":["Bool","Int32"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: Int32, _ rhs: Int32) -> (Int32, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\na result and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int32","note":"","default":"","types":["Int32"]},{"name":"rhs","type":"Int32","note":"_","default":"","types":["Int32"]}],"ret":{"line":"(Int32, overflow: Bool)","types":["Bool","Int32"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: Int32, _ rhs: Int32) -> (Int32, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\nthe remainder and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Represent this number using Swift's widest native signed\ninteger type."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"value","type":"Builtin.Int32","readonly":true,"stat":"","subtypes":["Builtin","Int32"],"comment":""},{"kind":"var","name":"bigEndian","type":"Int32","readonly":true,"stat":"","subtypes":["Int32"],"comment":"Returns the big-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"littleEndian","type":"Int32","readonly":true,"stat":"","subtypes":["Int32"],"comment":"Returns the little-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"byteSwapped","type":"Int32","readonly":true,"stat":"","subtypes":["Int32"],"comment":"Returns the current integer with the byte order swapped."},{"kind":"var","name":"max","type":"Int32","readonly":true,"stat":"static","subtypes":["Int32"],"comment":""},{"kind":"var","name":"min","type":"Int32","readonly":true,"stat":"static","subtypes":["Int32"],"comment":""},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"allZeros","type":"Int32","readonly":true,"stat":"static","subtypes":["Int32"],"comment":"The empty bitset of type Int32."}],"aliases":[{"kind":"typealias","name":"Distance","type":"Int","proto":"","comment":"A type that can represent the number of steps between pairs of\nvalues."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int32","note":"bigEndian","default":"","types":["Int32"]}],"init":"init","note":"","comment":"Creates an integer from its big-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int32","note":"littleEndian","default":"","types":["Int32"]}],"init":"init","note":"","comment":"Creates an integer from its little-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int32","note":"integerLiteral","default":"","types":["Int32"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt64","note":"","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Construct a `Int32` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int64","note":"","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Construct a `Int32` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt","note":"","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Construct a `Int32` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"Construct a `Int32` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"UInt32","note":"","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Construct a `Int32` having the same memory representation as\nthe `UInt32` `bitPattern`.  No range or overflow checking\noccurs, and the resulting `Int32` may not have the same numeric\nvalue as `bitPattern`--it is only guaranteed to use the same\npattern of bits."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."}],"subscripts":[],"comment":"A 32-bit signed integer value\ntype."},"Int64":{"kind":"struct","name":"Int64","slug":"Int64","inherits":["SignedIntegerType","Hashable","Printable","RandomAccessIndexType","SignedNumberType","BitwiseOperationsType","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"Int64","types":["Int64"]},"note":"","attr":"","line":"func successor() -> Int64","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"Int64","types":["Int64"]},"note":"","attr":"","line":"func predecessor() -> Int64","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: Int64) -> Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"Int64","types":["Int64"]},"note":"","attr":"","line":"func advancedBy(amount: Distance) -> Int64","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"_","default":"","types":["Int64"]}],"ret":{"line":"(Int64, overflow: Bool)","types":["Bool","Int64"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: Int64, _ rhs: Int64) -> (Int64, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"_","default":"","types":["Int64"]}],"ret":{"line":"(Int64, overflow: Bool)","types":["Bool","Int64"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: Int64, _ rhs: Int64) -> (Int64, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"_","default":"","types":["Int64"]}],"ret":{"line":"(Int64, overflow: Bool)","types":["Bool","Int64"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: Int64, _ rhs: Int64) -> (Int64, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"_","default":"","types":["Int64"]}],"ret":{"line":"(Int64, overflow: Bool)","types":["Bool","Int64"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: Int64, _ rhs: Int64) -> (Int64, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\na result and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int64","note":"","default":"","types":["Int64"]},{"name":"rhs","type":"Int64","note":"_","default":"","types":["Int64"]}],"ret":{"line":"(Int64, overflow: Bool)","types":["Bool","Int64"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: Int64, _ rhs: Int64) -> (Int64, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\nthe remainder and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Represent this number using Swift's widest native signed\ninteger type."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"value","type":"Builtin.Int64","readonly":true,"stat":"","subtypes":["Builtin","Int64"],"comment":""},{"kind":"var","name":"bigEndian","type":"Int64","readonly":true,"stat":"","subtypes":["Int64"],"comment":"Returns the big-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"littleEndian","type":"Int64","readonly":true,"stat":"","subtypes":["Int64"],"comment":"Returns the little-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"byteSwapped","type":"Int64","readonly":true,"stat":"","subtypes":["Int64"],"comment":"Returns the current integer with the byte order swapped."},{"kind":"var","name":"max","type":"Int64","readonly":true,"stat":"static","subtypes":["Int64"],"comment":""},{"kind":"var","name":"min","type":"Int64","readonly":true,"stat":"static","subtypes":["Int64"],"comment":""},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"allZeros","type":"Int64","readonly":true,"stat":"static","subtypes":["Int64"],"comment":"The empty bitset of type Int64."}],"aliases":[{"kind":"typealias","name":"Distance","type":"Int","proto":"","comment":"A type that can represent the number of steps between pairs of\nvalues."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int64","note":"bigEndian","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Creates an integer from its big-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int64","note":"littleEndian","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Creates an integer from its little-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int64","note":"integerLiteral","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"UInt64","note":"","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Construct a `Int64` having the same memory representation as\nthe `UInt64` `bitPattern`.  No range or overflow checking\noccurs, and the resulting `Int64` may not have the same numeric\nvalue as `bitPattern`--it is only guaranteed to use the same\npattern of bits."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."}],"subscripts":[],"comment":"A 64-bit signed integer value\ntype."},"Int8":{"kind":"struct","name":"Int8","slug":"Int8","inherits":["SignedIntegerType","Hashable","Printable","RandomAccessIndexType","SignedNumberType","BitwiseOperationsType","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"Int8","types":["Int8"]},"note":"","attr":"","line":"func successor() -> Int8","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"Int8","types":["Int8"]},"note":"","attr":"","line":"func predecessor() -> Int8","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: Int8) -> Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"Int8","types":["Int8"]},"note":"","attr":"","line":"func advancedBy(amount: Distance) -> Int8","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"_","default":"","types":["Int8"]}],"ret":{"line":"(Int8, overflow: Bool)","types":["Bool","Int8"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: Int8, _ rhs: Int8) -> (Int8, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"_","default":"","types":["Int8"]}],"ret":{"line":"(Int8, overflow: Bool)","types":["Bool","Int8"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: Int8, _ rhs: Int8) -> (Int8, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"_","default":"","types":["Int8"]}],"ret":{"line":"(Int8, overflow: Bool)","types":["Bool","Int8"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: Int8, _ rhs: Int8) -> (Int8, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"_","default":"","types":["Int8"]}],"ret":{"line":"(Int8, overflow: Bool)","types":["Bool","Int8"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: Int8, _ rhs: Int8) -> (Int8, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\na result and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"Int8","note":"","default":"","types":["Int8"]},{"name":"rhs","type":"Int8","note":"_","default":"","types":["Int8"]}],"ret":{"line":"(Int8, overflow: Bool)","types":["Bool","Int8"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: Int8, _ rhs: Int8) -> (Int8, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\nthe remainder and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Represent this number using Swift's widest native signed\ninteger type."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"value","type":"Builtin.Int8","readonly":true,"stat":"","subtypes":["Builtin","Int8"],"comment":""},{"kind":"var","name":"max","type":"Int8","readonly":true,"stat":"static","subtypes":["Int8"],"comment":""},{"kind":"var","name":"min","type":"Int8","readonly":true,"stat":"static","subtypes":["Int8"],"comment":""},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"allZeros","type":"Int8","readonly":true,"stat":"static","subtypes":["Int8"],"comment":"The empty bitset of type Int8."}],"aliases":[{"kind":"typealias","name":"Distance","type":"Int","proto":"","comment":"A type that can represent the number of steps between pairs of\nvalues."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"Int8","note":"integerLiteral","default":"","types":["Int8"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt16","note":"","default":"","types":["UInt16"]}],"init":"init","note":"","comment":"Construct a `Int8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int16","note":"","default":"","types":["Int16"]}],"init":"init","note":"","comment":"Construct a `Int8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt32","note":"","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Construct a `Int8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int32","note":"","default":"","types":["Int32"]}],"init":"init","note":"","comment":"Construct a `Int8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt64","note":"","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Construct a `Int8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int64","note":"","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Construct a `Int8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt","note":"","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Construct a `Int8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"Construct a `Int8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"UInt8","note":"","default":"","types":["UInt8"]}],"init":"init","note":"","comment":"Construct a `Int8` having the same memory representation as\nthe `UInt8` `bitPattern`.  No range or overflow checking\noccurs, and the resulting `Int8` may not have the same numeric\nvalue as `bitPattern`--it is only guaranteed to use the same\npattern of bits."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."}],"subscripts":[],"comment":"A 8-bit signed integer value\ntype."},"IntegerArithmeticType":{"kind":"protocol","name":"IntegerArithmeticType","slug":"IntegerArithmeticType","inherits":["_IntegerArithmeticType","Comparable"],"inherited":["Bit","_IntegerType"],"attr":"","operators":[],"functions":[{"kind":"operator func","name":"+","slug":"pls","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"func +(lhs: Self, rhs: Self) -> Self","comment":"Add `lhs` and `rhs`, returning a result and trapping in case of\narithmetic overflow (except in -Ounchecked builds)."},{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"func -(lhs: Self, rhs: Self) -> Self","comment":"Subtract `lhs` and `rhs`, returning a result and trapping in case of\narithmetic overflow (except in -Ounchecked builds)."},{"kind":"operator func","name":"*","slug":"star","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"func *(lhs: Self, rhs: Self) -> Self","comment":"Multiply `lhs` and `rhs`, returning a result and trapping in case of\narithmetic overflow (except in -Ounchecked builds)."},{"kind":"operator func","name":"/","slug":"slash","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"func /(lhs: Self, rhs: Self) -> Self","comment":"Divide `lhs` and `rhs`, returning a result and trapping in case of\narithmetic overflow (except in -Ounchecked builds)."},{"kind":"operator func","name":"%","slug":"pct","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"func %(lhs: Self, rhs: Self) -> Self","comment":"Divide `lhs` and `rhs`, returning the remainder and trapping in case of\narithmetic overflow (except in -Ounchecked builds)."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Explicitly convert to `IntMax`, trapping on overflow (except in\n-Ounchecked builds)."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"The common requirements for types that support integer arithmetic."},"IntegerLiteralConvertible":{"kind":"protocol","name":"IntegerLiteralConvertible","slug":"IntegerLiteralConvertible","inherits":[],"inherited":["Double","Float","Float80","_IntegerType","_SignedNumberType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"IntegerLiteralType","type":"","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"value","type":"IntegerLiteralType","note":"integerLiteral","default":"","types":["IntegerLiteralType"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."}],"subscripts":[],"comment":"Conforming types can be initialized with integer literals"},"IntegerType":{"kind":"protocol","name":"IntegerType","slug":"IntegerType","inherits":["_IntegerType","RandomAccessIndexType"],"inherited":["SignedIntegerType","UnsignedIntegerType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A set of common requirements for Swift's integer types."},"IntervalType":{"kind":"protocol","name":"IntervalType","slug":"IntervalType","inherits":[],"inherited":["ClosedInterval","HalfOpenInterval"],"attr":"","operators":[],"functions":[{"kind":"func","name":"contains","slug":"contains","generic":{},"params":[{"name":"value","type":"Bound","note":"","default":"","types":["Bound"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func contains(value: Bound) -> Bool","comment":"Returns `true` iff the interval contains `value`"},{"kind":"func","name":"clamp","slug":"clamp","generic":{},"params":[{"name":"intervalToClamp","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"note":"","attr":"","line":"func clamp(intervalToClamp: Self) -> Self","comment":"Return `rhs` clamped to `self`.  The bounds of the result, even\nif it is empty, are always within the bounds of `self`"}],"types":[],"properties":[{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"True iff `self` is empty"},{"kind":"var","name":"start","type":"Bound","readonly":true,"stat":"","subtypes":["Bound"],"comment":"The `Interval`\\ 's lower bound. Invariant: `start` <= `end`"},{"kind":"var","name":"end","type":"Bound","readonly":true,"stat":"","subtypes":["Bound"],"comment":"The `Interval`\\ 's upper bound. Invariant: `start` <= `end`"}],"aliases":[{"kind":"typealias","name":"Bound","type":"","proto":"Comparable","comment":"The type of the `Interval`\\ 's endpoints"}],"inits":[],"subscripts":[],"comment":"An interval over a `Comparable` type."},"LazyBidirectionalCollection":{"kind":"struct","name":"LazyBidirectionalCollection","slug":"LazyBidirectionalCollection","inherits":["CollectionType"],"inherited":[],"generic":{"line":"S : CollectionType where S.Index : BidirectionalIndexType","types":["BidirectionalIndexType","CollectionType","Index"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"S.Generator","types":["Generator"]},"note":"","attr":"","line":"func generate() -> S.Generator","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"filter","slug":"filter","generic":{},"params":[{"name":"includeElement","type":"(S.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator"]}],"ret":{"line":"LazySequence<FilterSequenceView<S>>","types":["FilterSequenceView","LazySequence"]},"note":"","attr":"","line":"func filter(includeElement: (S.Generator.Element) -> Bool) -> LazySequence<FilterSequenceView<S>>","comment":"Return a lazy SequenceType containing the elements `x` of `source` for\nwhich `includeElement(x)` is `true`"},{"kind":"func","name":"map","slug":"map","generic":{"line":"U","types":[]},"params":[{"name":"transform","type":"(S.Generator.Element) -> U","note":"","default":"","types":["Element","Generator"]}],"ret":{"line":"LazyBidirectionalCollection<MapCollectionView<S, U>>","types":["LazyBidirectionalCollection","MapCollectionView"]},"note":"","attr":"","line":"func map<U>(transform: (S.Generator.Element) -> U) -> LazyBidirectionalCollection<MapCollectionView<S, U>>","comment":"Return a `MapCollectionView` over this `LazyBidirectionalCollection`.  The elements of\nthe result are computed lazily, each time they are read, by\ncalling `transform` function on a base element."},{"kind":"func","name":"reverse","slug":"reverse","generic":{},"params":[],"ret":{"line":"LazyBidirectionalCollection<BidirectionalReverseView<S>>","types":["BidirectionalReverseView","LazyBidirectionalCollection"]},"note":"","attr":"","line":"func reverse() -> LazyBidirectionalCollection<BidirectionalReverseView<S>>","comment":"Return a `BidirectionalReverseView` over this `LazyBidirectionalCollection`.  The elements of\nthe result are computed lazily, each time they are read, by\ncalling `transform` function on a base element."}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"S.Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The position of the first element in a non-empty collection.\n\nIdentical to `endIndex` in an empty collection."},{"kind":"var","name":"endIndex","type":"S.Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The collection's \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."},{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"True if and only if the collection is empty"},{"kind":"var","name":"first","type":"S.Generator.Element?","readonly":true,"stat":"","subtypes":["Element","Generator"],"comment":"The first element, or `nil` if `self` is empty"},{"kind":"var","name":"last","type":"S.Generator.Element?","readonly":true,"stat":"","subtypes":["Element","Generator"],"comment":"The last element, or `nil` if `self` is empty"},{"kind":"var","name":"array","type":"[S.Generator.Element]","readonly":true,"stat":"","subtypes":["Element","Generator"],"comment":"an Array, created on-demand, containing the elements of this\nlazy CollectionType."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"base","type":"S","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance with `base` as its underlying collection\ninstance."}],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"S.Index","note":"","default":"","types":["Index"]}],"ret":{"line":"S.Generator.Element { get }","types":["Element","Generator"]},"comment":""}],"comment":"A collection that forwards its implementation to an underlying\ncollection instance while exposing lazy computations as methods."},"LazyForwardCollection":{"kind":"struct","name":"LazyForwardCollection","slug":"LazyForwardCollection","inherits":["CollectionType"],"inherited":[],"generic":{"line":"S : CollectionType where S.Index : ForwardIndexType","types":["CollectionType","ForwardIndexType","Index"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"S.Generator","types":["Generator"]},"note":"","attr":"","line":"func generate() -> S.Generator","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"filter","slug":"filter","generic":{},"params":[{"name":"includeElement","type":"(S.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator"]}],"ret":{"line":"LazySequence<FilterSequenceView<S>>","types":["FilterSequenceView","LazySequence"]},"note":"","attr":"","line":"func filter(includeElement: (S.Generator.Element) -> Bool) -> LazySequence<FilterSequenceView<S>>","comment":"Return a lazy SequenceType containing the elements `x` of `source` for\nwhich `includeElement(x)` is `true`"},{"kind":"func","name":"map","slug":"map","generic":{"line":"U","types":[]},"params":[{"name":"transform","type":"(S.Generator.Element) -> U","note":"","default":"","types":["Element","Generator"]}],"ret":{"line":"LazyForwardCollection<MapCollectionView<S, U>>","types":["LazyForwardCollection","MapCollectionView"]},"note":"","attr":"","line":"func map<U>(transform: (S.Generator.Element) -> U) -> LazyForwardCollection<MapCollectionView<S, U>>","comment":"Return a `MapCollectionView` over this `LazyForwardCollection`.  The elements of\nthe result are computed lazily, each time they are read, by\ncalling `transform` function on a base element."}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"S.Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The position of the first element in a non-empty collection.\n\nIdentical to `endIndex` in an empty collection."},{"kind":"var","name":"endIndex","type":"S.Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The collection's \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."},{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"True if and only if the collection is empty"},{"kind":"var","name":"first","type":"S.Generator.Element?","readonly":true,"stat":"","subtypes":["Element","Generator"],"comment":"The first element, or `nil` if `self` is empty"},{"kind":"var","name":"array","type":"[S.Generator.Element]","readonly":true,"stat":"","subtypes":["Element","Generator"],"comment":"an Array, created on-demand, containing the elements of this\nlazy CollectionType."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"base","type":"S","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance with `base` as its underlying collection\ninstance."}],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"S.Index","note":"","default":"","types":["Index"]}],"ret":{"line":"S.Generator.Element { get }","types":["Element","Generator"]},"comment":""}],"comment":"A collection that forwards its implementation to an underlying\ncollection instance while exposing lazy computations as methods."},"LazyRandomAccessCollection":{"kind":"struct","name":"LazyRandomAccessCollection","slug":"LazyRandomAccessCollection","inherits":["CollectionType"],"inherited":[],"generic":{"line":"S : CollectionType where S.Index : RandomAccessIndexType","types":["CollectionType","Index","RandomAccessIndexType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"S.Generator","types":["Generator"]},"note":"","attr":"","line":"func generate() -> S.Generator","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"filter","slug":"filter","generic":{},"params":[{"name":"includeElement","type":"(S.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator"]}],"ret":{"line":"LazySequence<FilterSequenceView<S>>","types":["FilterSequenceView","LazySequence"]},"note":"","attr":"","line":"func filter(includeElement: (S.Generator.Element) -> Bool) -> LazySequence<FilterSequenceView<S>>","comment":"Return a lazy SequenceType containing the elements `x` of `source` for\nwhich `includeElement(x)` is `true`"},{"kind":"func","name":"map","slug":"map","generic":{"line":"U","types":[]},"params":[{"name":"transform","type":"(S.Generator.Element) -> U","note":"","default":"","types":["Element","Generator"]}],"ret":{"line":"LazyRandomAccessCollection<MapCollectionView<S, U>>","types":["LazyRandomAccessCollection","MapCollectionView"]},"note":"","attr":"","line":"func map<U>(transform: (S.Generator.Element) -> U) -> LazyRandomAccessCollection<MapCollectionView<S, U>>","comment":"Return a `MapCollectionView` over this `LazyRandomAccessCollection`.  The elements of\nthe result are computed lazily, each time they are read, by\ncalling `transform` function on a base element."},{"kind":"func","name":"reverse","slug":"reverse","generic":{},"params":[],"ret":{"line":"LazyBidirectionalCollection<RandomAccessReverseView<S>>","types":["LazyBidirectionalCollection","RandomAccessReverseView"]},"note":"","attr":"","line":"func reverse() -> LazyBidirectionalCollection<RandomAccessReverseView<S>>","comment":"Return a `RandomAccessReverseView` over this `LazyRandomAccessCollection`.  The elements of\nthe result are computed lazily, each time they are read, by\ncalling `transform` function on a base element."}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"S.Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The position of the first element in a non-empty collection.\n\nIdentical to `endIndex` in an empty collection."},{"kind":"var","name":"endIndex","type":"S.Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The collection's \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."},{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"True if and only if the collection is empty"},{"kind":"var","name":"first","type":"S.Generator.Element?","readonly":true,"stat":"","subtypes":["Element","Generator"],"comment":"The first element, or `nil` if `self` is empty"},{"kind":"var","name":"last","type":"S.Generator.Element?","readonly":true,"stat":"","subtypes":["Element","Generator"],"comment":"The last element, or `nil` if `self` is empty"},{"kind":"var","name":"array","type":"[S.Generator.Element]","readonly":true,"stat":"","subtypes":["Element","Generator"],"comment":"an Array, created on-demand, containing the elements of this\nlazy CollectionType."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"base","type":"S","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance with `base` as its underlying collection\ninstance."}],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"S.Index","note":"","default":"","types":["Index"]}],"ret":{"line":"S.Generator.Element { get }","types":["Element","Generator"]},"comment":""}],"comment":"A collection that forwards its implementation to an underlying\ncollection instance while exposing lazy computations as methods."},"LazySequence":{"kind":"struct","name":"LazySequence","slug":"LazySequence","inherits":["SequenceType"],"inherited":[],"generic":{"line":"S : SequenceType","types":["SequenceType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"S.Generator","types":["Generator"]},"note":"","attr":"","line":"func generate() -> S.Generator","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"filter","slug":"filter","generic":{},"params":[{"name":"includeElement","type":"(S.Generator.Element) -> Bool","note":"","default":"","types":["Bool","Element","Generator"]}],"ret":{"line":"LazySequence<FilterSequenceView<S>>","types":["FilterSequenceView","LazySequence"]},"note":"","attr":"","line":"func filter(includeElement: (S.Generator.Element) -> Bool) -> LazySequence<FilterSequenceView<S>>","comment":"Return a lazy SequenceType containing the elements `x` of `source` for\nwhich `includeElement(x)` is `true`"},{"kind":"func","name":"map","slug":"map","generic":{"line":"U","types":[]},"params":[{"name":"transform","type":"(S.Generator.Element) -> U","note":"","default":"","types":["Element","Generator"]}],"ret":{"line":"LazySequence<MapSequenceView<S, U>>","types":["LazySequence","MapSequenceView"]},"note":"","attr":"","line":"func map<U>(transform: (S.Generator.Element) -> U) -> LazySequence<MapSequenceView<S, U>>","comment":"Return a `MapSequenceView` over this `LazySequence`.  The elements of\nthe result are computed lazily, each time they are read, by\ncalling `transform` function on a base element."}],"types":[],"properties":[{"kind":"var","name":"array","type":"[S.Generator.Element]","readonly":true,"stat":"","subtypes":["Element","Generator"],"comment":"an Array, created on-demand, containing the elements of this\nlazy SequenceType."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"base","type":"S","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance with `base` as its underlying sequence\ninstance."}],"subscripts":[],"comment":"A sequence that forwards its implementation to an underlying\nsequence instance while exposing lazy computations as methods."},"MapCollectionView":{"kind":"struct","name":"MapCollectionView","slug":"MapCollectionView","inherits":["CollectionType"],"inherited":[],"generic":{"line":"Base : CollectionType, T","types":["Base","CollectionType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"MapSequenceGenerator<Base.Generator, T>","types":["Base","Generator","MapSequenceGenerator"]},"note":"","attr":"","line":"func generate() -> MapSequenceGenerator<Base.Generator, T>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Base.Index","readonly":true,"stat":"","subtypes":["Base","Index"],"comment":"The position of the first element in a non-empty collection.\n\nIdentical to `endIndex` in an empty collection."},{"kind":"var","name":"endIndex","type":"Base.Index","readonly":true,"stat":"","subtypes":["Base","Index"],"comment":"The collection's \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."}],"aliases":[],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"Base.Index","note":"","default":"","types":["Base","Index"]}],"ret":{"line":"T { get }","types":[]},"comment":""}],"comment":"A `CollectionType` whose elements consist of those in a `Base`\n`CollectionType` passed through a transform function returning `T`.\nThese elements are computed lazily, each time they're read, by\ncalling the transform function on a base element."},"MapSequenceGenerator":{"kind":"struct","name":"MapSequenceGenerator","slug":"MapSequenceGenerator","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"Base : GeneratorType, T","types":["Base","GeneratorType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"T?","types":[]},"note":"mutating","attr":"","line":"mutating func next() -> T?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: `next()` has not been applied to a copy of `self`\nsince the copy was made, and no preceding call to `self.next()`\nhas returned `nil`."},{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"MapSequenceGenerator<Base, T>","types":["Base","MapSequenceGenerator"]},"note":"","attr":"","line":"func generate() -> MapSequenceGenerator<Base, T>","comment":"`MapSequenceGenerator` is also a `SequenceType`, so it\n`generate`\\ 's a copy of itself"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"The `GeneratorType` used by `MapSequenceView` and `MapCollectionView`.\nProduces each element by passing the output of the `Base`\n`GeneratorType` through a transform function returning `T`"},"MapSequenceView":{"kind":"struct","name":"MapSequenceView","slug":"MapSequenceView","inherits":["SequenceType"],"inherited":[],"generic":{"line":"Base : SequenceType, T","types":["Base","SequenceType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"MapSequenceGenerator<Base.Generator, T>","types":["Base","Generator","MapSequenceGenerator"]},"note":"","attr":"","line":"func generate() -> MapSequenceGenerator<Base.Generator, T>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A `SequenceType` whose elements consist of those in a `Base`\n`SequenceType` passed through a transform function returning `T`.\nThese elements are computed lazily, each time they're read, by\ncalling the transform function on a base element."},"MirrorDisposition":{"kind":"enum","name":"MirrorDisposition","slug":"MirrorDisposition","inherits":[],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"How children of this value should be presented in the IDE.","cases":[{"kind":"case","name":"Struct","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"Class","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"Enum","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"Tuple","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"Aggregate","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"IndexContainer","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"KeyContainer","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"MembershipContainer","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"Container","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"Optional","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"ObjCObject","associated":"","subtypes":[],"comment":""}]},"MirrorType":{"kind":"protocol","name":"MirrorType","slug":"MirrorType","inherits":[],"inherited":[],"attr":"","operators":[],"functions":[],"types":[],"properties":[{"kind":"var","name":"value","type":"Any","readonly":true,"stat":"","subtypes":["Any"],"comment":"The instance being reflected"},{"kind":"var","name":"valueType","type":"Any.Type","readonly":true,"stat":"","subtypes":["Any","Type"],"comment":"Identical to `value.dynamicType`"},{"kind":"var","name":"objectIdentifier","type":"ObjectIdentifier?","readonly":true,"stat":"","subtypes":["ObjectIdentifier"],"comment":"A unique identifier for `value` if it is a class instance; `nil`\notherwise."},{"kind":"var","name":"count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The count of `value`\\ 's logical children "},{"kind":"var","name":"summary","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A string description of `value`."},{"kind":"var","name":"quickLookObject","type":"QuickLookObject?","readonly":true,"stat":"","subtypes":["QuickLookObject"],"comment":"A rich representation of `value` for an IDE, or `nil` if none is supplied."},{"kind":"var","name":"disposition","type":"MirrorDisposition","readonly":true,"stat":"","subtypes":["MirrorDisposition"],"comment":"How `value` should be presented in an IDE."}],"aliases":[],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"i","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"(String, MirrorType) { get }","types":["MirrorType","String"]},"comment":""}],"comment":"The type returned by `reflect(x)`; supplies an API for runtime\nreflection on `x`"},"MutableCollectionType":{"kind":"protocol","name":"MutableCollectionType","slug":"MutableCollectionType","inherits":["CollectionType"],"inherited":["Array","ContiguousArray","MutableSliceable","Slice","UnsafeMutableBufferPointer","_ArrayBufferType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"Self.Index","note":"","default":"","types":["Index","Self"]}],"ret":{"line":"Self.Generator.Element { get set }","types":["Element","Generator","Self"]},"comment":""}],"comment":"A *collection* that supports subscript assignment.\n\nFor any instance `a` of a type conforming to\n`MutableCollectionType`, ::\n\n  a[i] = x\n  let y = a[i]\n\nis equivalent to ::\n\n  a[i] = x\n  let y = x\n"},"MutableSliceable":{"kind":"protocol","name":"MutableSliceable","slug":"MutableSliceable","inherits":["Sliceable","MutableCollectionType"],"inherited":["ArrayType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"_","type":"Range<Self.Index>","note":"","default":"","types":["Index","Range","Self"]}],"ret":{"line":"Self.SubSlice { get set }","types":["Self","SubSlice"]},"comment":""}],"comment":"A *collection* with mutable slices.\n\nFor example,\n\n.. parsed-literal:\n\n     x[i..<j] = *someExpression*\n     x[i..<j].\\ *mutatingMethod*\\ ()"},"NilLiteralConvertible":{"kind":"protocol","name":"NilLiteralConvertible","slug":"NilLiteralConvertible","inherits":[],"inherited":["AutoreleasingUnsafeMutablePointer","CFunctionPointer","COpaquePointer","ImplicitlyUnwrappedOptional","Optional","RawOptionSetType","UnsafeMutablePointer","UnsafePointer"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"nilLiteral","type":"()","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance initialized with `nil`."}],"subscripts":[],"comment":"Conforming types can be initialized with `nil`."},"ObjectIdentifier":{"kind":"struct","name":"ObjectIdentifier","slug":"ObjectIdentifier","inherits":["Hashable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"uintValue","slug":"uintValue","generic":{},"params":[],"ret":{"line":"UInt","types":["UInt"]},"note":"","attr":"","line":"func uintValue() -> UInt","comment":"Convert to a `UInt` that captures the full value of `self`.\n\nAxiom: `a.uintValue() == b.uintValue()` iff `a == b`"}],"types":[],"properties":[{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"x","type":"AnyObject","note":"_","default":"","types":["AnyObject"]}],"init":"init","note":"","comment":"Construct an instance that uniquely identifies `x`."}],"subscripts":[],"comment":"A unique identifier for a class instance. This can be used by reflection\nclients to recognize cycles in the object graph.\n\nIn Swift, only class instances have unique identities. There is no notion\nof identity for structs, enums, or tuples."},"OnHeap":{"kind":"struct","name":"OnHeap","slug":"OnHeap","inherits":[],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":""},"Optional":{"kind":"enum","name":"Optional","slug":"Optional","inherits":["Reflectable","NilLiteralConvertible","DebugPrintable"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"map","slug":"map","generic":{"line":"U","types":[]},"params":[{"name":"f","type":"(T) -> U","note":"","default":"","types":[]}],"ret":{"line":"U?","types":[]},"note":"","attr":"","line":"func map<U>(f: (T) -> U) -> U?","comment":"If `self == nil`, returns `nil`.  Otherwise, returns `f(self!)`."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Construct a `nil` instance."},{"kind":"init","generic":{},"params":[{"name":"some","type":"T","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct a non-\\ `nil` instance that stores `some`."},{"kind":"init","generic":{},"params":[{"name":"nilLiteral","type":"()","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance initialized with `nil`."}],"subscripts":[],"comment":"","cases":[{"kind":"case","name":"None","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"Some","associated":"(T)","subtypes":[],"comment":""}]},"OutputStreamType":{"kind":"protocol","name":"OutputStreamType","slug":"OutputStreamType","inherits":[],"inherited":["String"],"attr":"","operators":[],"functions":[{"kind":"func","name":"write","slug":"write","generic":{},"params":[{"name":"string","type":"String","note":"","default":"","types":["String"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func write(string: String)","comment":"Append the given `string` to this stream."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A target of text streaming operations."},"PermutationGenerator":{"kind":"struct","name":"PermutationGenerator","slug":"PermutationGenerator","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"C : CollectionType, Indices : SequenceType where C.Index == C.Index","types":["CollectionType","Index","Indices","SequenceType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"Element?","types":["Element"]},"note":"mutating","attr":"","line":"mutating func next() -> Element?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: no preceding call to `self.next()` has returned `nil`."},{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"PermutationGenerator<C, Indices>","types":["Indices","PermutationGenerator"]},"note":"","attr":"","line":"func generate() -> PermutationGenerator<C, Indices>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Element","type":"C.Generator.Element","proto":"","comment":"The type of element returned by `next()`."},{"kind":"typealias","name":"Generator","type":"PermutationGenerator<C, Indices>","proto":"","comment":"A type whose instances can produce the elements of this\nsequence, in order."}],"inits":[{"kind":"init","generic":{},"params":[{"name":"elements","type":"C","note":"","default":"","types":[]},{"name":"indices","type":"Indices","note":"","default":"","types":["Indices"]}],"init":"init","note":"","comment":"Construct a *generator* over a permutation of `elements` given\nby `indices`.\n\nRequires: `elements[i]` is valid for every `i` in `indices`."}],"subscripts":[],"comment":"A *generator* that adapts a *collection* `C` and any *sequence* of\nits `Index` type to present the collection's elements in a\npermuted order."},"Printable":{"kind":"protocol","name":"Printable","slug":"Printable","inherits":[],"inherited":["Array","Bool","ClosedInterval","ContiguousArray","Dictionary","Double","Float","Float80","HalfOpenInterval","ImplicitlyUnwrappedOptional","Int","Int16","Int32","Int64","Int8","Range","Slice","StaticString","UInt","UInt16","UInt32","UInt64","UInt8","UnicodeScalar","_IntegerType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."}],"aliases":[],"inits":[],"subscripts":[],"comment":"A type with a customized textual representation.\n\nThis textual representation is used when objects are written to an\n*output stream*, for example, by `print` and `println`."},"QuickLookObject":{"kind":"enum","name":"QuickLookObject","slug":"QuickLookObject","inherits":[],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"The sum of types that can be used as a quick look representation.\n\nThis type must be binary-compatible with the 'QuickLookObject' struct in\nstdlib/Runtime/Reflection.mm, and 'QuickLookObject?' must be binary\ncompatible with 'OptionalQuickLookObject' from the same.\n\nNB: This type is somewhat carefully laid out to *suppress* enum layout\noptimization so that it is easier to manufacture in the C++ runtime\nimplementation.","cases":[{"kind":"case","name":"Text","associated":"(String)","subtypes":["String"],"comment":""},{"kind":"case","name":"Int","associated":"(Int64)","subtypes":["Int64"],"comment":""},{"kind":"case","name":"UInt","associated":"(UInt64)","subtypes":["UInt64"],"comment":""},{"kind":"case","name":"Float","associated":"(Double)","subtypes":["Double"],"comment":""},{"kind":"case","name":"Image","associated":"(Any)","subtypes":["Any"],"comment":""},{"kind":"case","name":"Sound","associated":"(Any)","subtypes":["Any"],"comment":""},{"kind":"case","name":"Color","associated":"(Any)","subtypes":["Any"],"comment":""},{"kind":"case","name":"BezierPath","associated":"(Any)","subtypes":["Any"],"comment":""},{"kind":"case","name":"AttributedString","associated":"(Any)","subtypes":["Any"],"comment":""},{"kind":"case","name":"Rectangle","associated":"(Double, Double, Double, Double)","subtypes":["Double"],"comment":""},{"kind":"case","name":"Point","associated":"(Double, Double)","subtypes":["Double"],"comment":""},{"kind":"case","name":"Size","associated":"(Double, Double)","subtypes":["Double"],"comment":""},{"kind":"case","name":"Logical","associated":"(Bool)","subtypes":["Bool"],"comment":""},{"kind":"case","name":"Range","associated":"(UInt64, UInt64)","subtypes":["UInt64"],"comment":""},{"kind":"case","name":"View","associated":"(Any)","subtypes":["Any"],"comment":""},{"kind":"case","name":"Sprite","associated":"(Any)","subtypes":["Any"],"comment":""},{"kind":"case","name":"URL","associated":"(String)","subtypes":["String"],"comment":""}]},"RandomAccessIndexType":{"kind":"protocol","name":"RandomAccessIndexType","slug":"RandomAccessIndexType","inherits":["BidirectionalIndexType","_RandomAccessIndexType"],"inherited":["Bit","Int","Int16","Int32","Int64","Int8","IntegerType","ReverseRandomAccessIndex","UInt","UInt16","UInt32","UInt64","UInt8","UnsafeMutablePointer","UnsafePointer"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"An *index* that can be offset by an arbitrary number of positions,\nand can measure the distance to any reachable value, in O(1)."},"RandomAccessReverseView":{"kind":"struct","name":"RandomAccessReverseView","slug":"RandomAccessReverseView","inherits":["CollectionType"],"inherited":[],"generic":{"line":"T : CollectionType where T.Index : RandomAccessIndexType","types":["CollectionType","Index","RandomAccessIndexType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"IndexingGenerator<RandomAccessReverseView<T>>","types":["IndexingGenerator","RandomAccessReverseView"]},"note":"","attr":"","line":"func generate() -> IndexingGenerator<RandomAccessReverseView<T>>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The position of the first element in a non-empty collection.\n\nIdentical to `endIndex` in an empty collection."},{"kind":"var","name":"endIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The collection's \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."}],"aliases":[{"kind":"typealias","name":"Index","type":"ReverseRandomAccessIndex<T.Index>","proto":"","comment":"A type that represents a valid position in the collection.\n\nValid indices consist of the position of every element and a\n\"past the end\" position that's not valid for use as a subscript."},{"kind":"typealias","name":"Generator","type":"IndexingGenerator<RandomAccessReverseView<T>>","proto":"","comment":"A type whose instances can produce the elements of this\nsequence, in order."}],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"Index","note":"","default":"","types":["Index"]}],"ret":{"line":"T.Generator.Element { get }","types":["Element","Generator"]},"comment":""}],"comment":"The lazy `CollectionType` returned by `reverse(c)` where `c` is a\n`CollectionType` with an `Index` conforming to `RandomAccessIndexType`"},"Range":{"kind":"struct","name":"Range","slug":"Range","inherits":["Equatable","CollectionType","Printable","DebugPrintable","Reflectable"],"inherited":[],"generic":{"line":"T : ForwardIndexType","types":["ForwardIndexType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"RangeGenerator<T>","types":["RangeGenerator"]},"note":"","attr":"","line":"func generate() -> RangeGenerator<T>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"map","slug":"map","generic":{"line":"U","types":[]},"params":[{"name":"transform","type":"(T) -> U","note":"","default":"","types":[]}],"ret":{"line":"[U]","types":[]},"note":"","attr":"","line":"func map<U>(transform: (T) -> U) -> [U]","comment":"Return an array containing the results of calling\n`transform(x)` on each element `x` of `self`."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff the range is empty, i.e. `startIndex == endIndex`"},{"kind":"var","name":"startIndex","type":"T","readonly":true,"stat":"","subtypes":[],"comment":"The range's lower bound\n\nIdentical to `endIndex` in an empty range."},{"kind":"var","name":"endIndex","type":"T","readonly":true,"stat":"","subtypes":[],"comment":"The range's upper bound\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[{"kind":"typealias","name":"Index","type":"T","proto":"","comment":"A type that represents a valid position in the collection.\n\nValid indices consist of the position of every element and a\n\"past the end\" position that's not valid for use as a subscript."},{"kind":"typealias","name":"Slice","type":"Range<T>","proto":"","comment":""},{"kind":"typealias","name":"Generator","type":"RangeGenerator<T>","proto":"","comment":"A type whose instances can produce the elements of this\nsequence, in order."}],"inits":[{"kind":"init","generic":{},"params":[{"name":"x","type":"Range<T>","note":"_","default":"","types":["Range"]}],"init":"init","note":"","comment":"Construct a copy of `x`"},{"kind":"init","generic":{},"params":[{"name":"start","type":"T","note":"","default":"","types":[]},{"name":"end","type":"T","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Construct a range with `startIndex == start` and `endIndex ==\nend`."}],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"T","note":"","default":"","types":[]}],"ret":{"line":"T { get }","types":[]},"comment":""},{"kind":"subscript","params":[{"name":"_","type":"T._DisabledRangeIndex","note":"","default":"","types":["_DisabledRangeIndex"]}],"ret":{"line":"T { get }","types":[]},"comment":""}],"comment":"A collection of consecutive discrete index values.\n\n:param: `T` is both the element type and the index type of the\n  collection.\n\nLike other collections, a range containing one element has an\n`endIndex` that is the successor of its `startIndex`; and an empty\nrange has `startIndex == endIndex`.\n\nAxiom: for any `Range` `r`, `r[i] == i`.\n\nTherefore, if `T` has a maximal value, it can serve as an\n`endIndex`, but can never be contained in a `Range<T>`.\n\nIt also follows from the axiom above that `(-99..<100)[0] == 0`.\nTo prevent confusion (because some expect the result to be `-99`),\nin a context where `T` is known to be an integer type,\nsubscripting with `T` is a compile-time error::\n\n  // error: could not find an overload for 'subscript'...\n  println( Range<Int>(start:-99, end:100)[0] )\n\nHowever, subscripting that range still works in a generic context::\n\n  func brackets<T:ForwardIndexType>(x: Range<T>, i: T) -> T {\n    return x[i] // Just forward to subscript\n  }\n  println(brackets(Range<Int>(start:-99, end:100), 0)) // prints 0"},"RangeGenerator":{"kind":"struct","name":"RangeGenerator","slug":"RangeGenerator","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"T : ForwardIndexType","types":["ForwardIndexType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"T?","types":[]},"note":"mutating","attr":"","line":"mutating func next() -> T?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists."},{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"RangeGenerator<T>","types":["RangeGenerator"]},"note":"","attr":"","line":"func generate() -> RangeGenerator<T>","comment":"`RangeGenerator` is also a `SequenceType`, so it\n`generate`\\ 's a copy of itself"}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"T","readonly":true,"stat":"","subtypes":[],"comment":"The lower bound of the remaining range."},{"kind":"var","name":"endIndex","type":"T","readonly":true,"stat":"","subtypes":[],"comment":"The upper bound of the remaining range; not included in the\ngenerated sequence."}],"aliases":[{"kind":"typealias","name":"Element","type":"T","proto":"","comment":"The type of element returned by `next()`."},{"kind":"typealias","name":"Generator","type":"RangeGenerator<T>","proto":"","comment":"A type whose instances can produce the elements of this\nsequence, in order."}],"inits":[{"kind":"init","generic":{},"params":[{"name":"bounds","type":"Range<T>","note":"_","default":"","types":["Range"]}],"init":"init","note":"","comment":"Construct an instance that traverses the elements of `bounds`"}],"subscripts":[],"comment":"A generator over the elements of `Range<T>`"},"RangeReplaceableCollectionType":{"kind":"protocol","name":"RangeReplaceableCollectionType","slug":"RangeReplaceableCollectionType","inherits":["ExtensibleCollectionType"],"inherited":["String","ArrayType"],"attr":"","operators":[],"functions":[{"kind":"func","name":"replaceRange","slug":"replaceRange","generic":{"line":"C : CollectionType where `Self`.Generator.Element == Self.Generator.Element","types":["CollectionType","Element","Generator","Self"]},"params":[{"name":"subRange","type":"Range<Self.Index>","note":"","default":"","types":["Index","Range","Self"]},{"name":"newElements","type":"C","note":"with","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func replaceRange<C : CollectionType where `Self`.Generator.Element == Self.Generator.Element>(subRange: Range<Self.Index>, with newElements: C)","comment":"Replace the given `subRange` of elements with `newElements`.\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `countElements(subRange)`\\ ) if\n`subRange.endIndex == self.endIndex` and `isEmpty(newElements)`\\ ,\nO(\\ `countElements(self)`\\ + \\`countElements(newElements)`\\ ) otherwise."},{"kind":"func","name":"insert","slug":"insert","generic":{},"params":[{"name":"newElement","type":"Self.Generator.Element","note":"","default":"","types":["Element","Generator","Self"]},{"name":"i","type":"Self.Index","note":"atIndex","default":"","types":["Index","Self"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func insert(newElement: Self.Generator.Element, atIndex i: Self.Index)","comment":"Insert `newElement` at index `i`.\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `countElements(self)`\\ ).\n\nCan be implemented as::\n\n  Swift.insert(&self, newElement, atIndex: i)"},{"kind":"func","name":"splice","slug":"splice","generic":{"line":"S : CollectionType where `Self`.Generator.Element == Self.Generator.Element","types":["CollectionType","Element","Generator","Self"]},"params":[{"name":"newElements","type":"S","note":"","default":"","types":[]},{"name":"i","type":"Self.Index","note":"atIndex","default":"","types":["Index","Self"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func splice<S : CollectionType where `Self`.Generator.Element == Self.Generator.Element>(newElements: S, atIndex i: Self.Index)","comment":"Insert `newElements` at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `countElements(self) + countElements(newElements)`\\ ).\n\nCan be implemented as::\n\n  Swift.splice(&self, newElements, atIndex: i)"},{"kind":"func","name":"removeAtIndex","slug":"removeAtIndex","generic":{},"params":[{"name":"i","type":"Self.Index","note":"","default":"","types":["Index","Self"]}],"ret":{"line":"Self.Generator.Element","types":["Element","Generator","Self"]},"note":"mutating","attr":"","line":"mutating func removeAtIndex(i: Self.Index) -> Self.Generator.Element","comment":"Remove the element at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `countElements(self)`\\ ).\n\nCan be implemented as::\n\n  Swift.removeAtIndex(&self, i)"},{"kind":"func","name":"removeRange","slug":"removeRange","generic":{},"params":[{"name":"subRange","type":"Range<Self.Index>","note":"","default":"","types":["Index","Range","Self"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeRange(subRange: Range<Self.Index>)","comment":"Remove the indicated `subRange` of elements\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `countElements(self)`\\ ).\n\nCan be implemented as::\n\n  Swift.removeRange(&self, subRange)"},{"kind":"func","name":"removeAll","slug":"removeAll","generic":{},"params":[{"name":"#keepCapacity","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeAll(#keepCapacity: Bool)","comment":"Remove all elements\n\nInvalidates all indices with respect to `self`.\n\n:param: `keepCapacity`, if `true`, is a non-binding request to\n   avoid releasing storage, which can be a useful optimization\n   when `self` is going to be grown again.\n\nComplexity: O(\\ `countElements(self)`\\ ).\n\nCan be implemented as::\n\n  Swift.removeAll(&self, keepCapacity: keepCapacity)"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A *collection* that supports replacement of an arbitrary subRange\nof elements with the elements of another collection."},"RawByte":{"kind":"struct","name":"RawByte","slug":"RawByte","inherits":[],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A byte-sized thing that isn't designed to interoperate with\nany other types; it makes a decent parameter to UnsafeMutablePointer when\nyou just want to do bytewise pointer arithmetic."},"RawOptionSetType":{"kind":"protocol","name":"RawOptionSetType","slug":"RawOptionSetType","inherits":["_RawOptionSetType","BitwiseOperationsType","NilLiteralConvertible"],"inherited":[],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"Protocol for `NS_OPTIONS` imported from Objective-C"},"RawRepresentable":{"kind":"protocol","name":"RawRepresentable","slug":"RawRepresentable","inherits":[],"inherited":["_RawOptionSetType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[{"kind":"var","name":"rawValue","type":"RawValue","readonly":true,"stat":"","subtypes":["RawValue"],"comment":"The corresponding value of the \"raw\" type.\n\n`Self(rawValue: self.rawValue)!` is equivalent to `self`."}],"aliases":[{"kind":"typealias","name":"RawValue","type":"","proto":"","comment":"The \"raw\" type that can be used to represent all values of `Self`.\n\nEvery distinct value of `self` has a corresponding unique\nvalue of `RawValue`, but `RawValue` may have representations\nthat do not correspond to an value of `Self`."}],"inits":[{"kind":"init","generic":{},"params":[{"name":"rawValue","type":"RawValue","note":"","default":"","types":["RawValue"]}],"init":"init?","note":"","comment":"Convert from a value of `RawValue`, yielding `nil` iff\n`rawValue` does not correspond to a value of `Self`."}],"subscripts":[],"comment":"A type that can be converted to an associated \"raw\" type, then\nconverted back to produce an instance equivalent to the original."},"Reflectable":{"kind":"protocol","name":"Reflectable","slug":"Reflectable","inherits":[],"inherited":["Array","Bit","Bool","Character","ClosedInterval","CollectionOfOne","ContiguousArray","Dictionary","Double","EmptyCollection","Float","HalfOpenInterval","ImplicitlyUnwrappedOptional","Int","Int16","Int32","Int64","Int8","Optional","Range","Slice","StrideThrough","StrideTo","String","UInt","UInt16","UInt32","UInt64","UInt8","UnicodeScalar","UnsafeMutablePointer","UnsafePointer","String.Index","String.UTF8View","String.UnicodeScalarView","String.UTF16View"],"attr":"","operators":[],"functions":[{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"Customizes the result of `reflect(x)`, where `x` is a conforming\ntype."},"Repeat":{"kind":"struct","name":"Repeat","slug":"Repeat","inherits":["CollectionType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"IndexingGenerator<Repeat<T>>","types":["IndexingGenerator","Repeat"]},"note":"","attr":"","line":"func generate() -> IndexingGenerator<Repeat<T>>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"Always zero, which is the index of the first element in a\nnon-empty instance."},{"kind":"var","name":"endIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"Always equal to `count`, which is one greater than the index of\nthe last element in a non-empty instance."},{"kind":"var","name":"count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The number of elements in this collection."},{"kind":"var","name":"repeatedValue","type":"T","readonly":true,"stat":"","subtypes":[],"comment":"The value of every element in this collection."}],"aliases":[{"kind":"typealias","name":"Index","type":"Int","proto":"","comment":"A type that represents a valid position in the collection.\n\nValid indices consist of the position of every element and a\n\"past the end\" position that's not valid for use as a subscript."}],"inits":[{"kind":"init","generic":{},"params":[{"name":"count","type":"Int","note":"","default":"","types":["Int"]},{"name":"repeatedValue","type":"T","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance that contains `count` elements having the\nvalue `repeatedValue`."}],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T { get }","types":[]},"comment":""}],"comment":"A collection whose elements are all identical `T`\\ s."},"ReverseBidirectionalIndex":{"kind":"struct","name":"ReverseBidirectionalIndex","slug":"ReverseBidirectionalIndex","inherits":["BidirectionalIndexType"],"inherited":[],"generic":{"line":"I : BidirectionalIndexType","types":["BidirectionalIndexType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"ReverseBidirectionalIndex<I>","types":["ReverseBidirectionalIndex"]},"note":"","attr":"","line":"func successor() -> ReverseBidirectionalIndex<I>","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"ReverseBidirectionalIndex<I>","types":["ReverseBidirectionalIndex"]},"note":"","attr":"","line":"func predecessor() -> ReverseBidirectionalIndex<I>","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A wrapper for a `BidirectionalIndexType` that reverses its\ndirection of traversal"},"ReverseRandomAccessIndex":{"kind":"struct","name":"ReverseRandomAccessIndex","slug":"ReverseRandomAccessIndex","inherits":["RandomAccessIndexType"],"inherited":[],"generic":{"line":"I : RandomAccessIndexType","types":["RandomAccessIndexType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"ReverseRandomAccessIndex<I>","types":["ReverseRandomAccessIndex"]},"note":"","attr":"","line":"func successor() -> ReverseRandomAccessIndex<I>","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"ReverseRandomAccessIndex<I>","types":["ReverseRandomAccessIndex"]},"note":"","attr":"","line":"func predecessor() -> ReverseRandomAccessIndex<I>","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"ReverseRandomAccessIndex<I>","note":"","default":"","types":["ReverseRandomAccessIndex"]}],"ret":{"line":"I.Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: ReverseRandomAccessIndex<I>) -> I.Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"I.Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"ReverseRandomAccessIndex<I>","types":["ReverseRandomAccessIndex"]},"note":"","attr":"","line":"func advancedBy(amount: I.Distance) -> ReverseRandomAccessIndex<I>","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A wrapper for a `RandomAccessIndexType` that reverses its\ndirection of traversal"},"SequenceOf":{"kind":"struct","name":"SequenceOf","slug":"SequenceOf","inherits":["SequenceType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"GeneratorOf<T>","types":["GeneratorOf"]},"note":"","attr":"","line":"func generate() -> GeneratorOf<T>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{"line":"G : GeneratorType where T == T","types":["GeneratorType"]},"params":[{"name":"makeUnderlyingGenerator","type":"() -> G","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance whose `generate()` method forwards to\n`makeUnderlyingGenerator`"},{"kind":"init","generic":{"line":"S : SequenceType where T == T","types":["SequenceType"]},"params":[{"name":"base","type":"S","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance whose `generate()` method forwards to\nthat of `base`."}],"subscripts":[],"comment":"A type-erased sequence.\n\nForwards operations to an arbitrary underlying sequence with the\nsame `Element` type, hiding the specifics of the underlying\nsequence type.\n\nSee also: `GeneratorOf<T>`."},"SequenceType":{"kind":"protocol","name":"SequenceType","slug":"SequenceType","inherits":["_Sequence_Type"],"inherited":["CollectionType","EmptyGenerator","EnumerateGenerator","EnumerateSequence","FilterGenerator","FilterSequenceView","GeneratorOf","GeneratorOfOne","GeneratorSequence","IndexingGenerator","LazySequence","MapSequenceGenerator","MapSequenceView","PermutationGenerator","RangeGenerator","SequenceOf","StrideThrough","StrideTo","UnsafeBufferPointerGenerator","Zip2","String.UnicodeScalarView"],"attr":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"Generator","types":["Generator"]},"note":"","attr":"","line":"func generate() -> Generator","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Generator","type":"","proto":"GeneratorType","comment":"A type that provides the *sequence*\\ 's iteration interface and\nencapsulates its iteration state."}],"inits":[],"subscripts":[],"comment":"A type that can be iterated with a `for`\\ ...\\ `in` loop.\n\n`SequenceType` makes no requirement on conforming types regarding\nwhether they will be destructively \"consumed\" by iteration.  To\nensure non-destructive iteration, constrain your *sequence* to\n`CollectionType`."},"SignedIntegerType":{"kind":"protocol","name":"SignedIntegerType","slug":"SignedIntegerType","inherits":["_SignedIntegerType","IntegerType"],"inherited":["Int","Int16","Int32","Int64","Int8"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A set of common requirements for Swift's signed integer types."},"SignedNumberType":{"kind":"protocol","name":"SignedNumberType","slug":"SignedNumberType","inherits":["_SignedNumberType"],"inherited":["AbsoluteValuable","Int","Int16","Int32","Int64","Int8","_SignedIntegerType"],"attr":"","operators":[],"functions":[{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"prefix","params":[{"name":"x","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"prefix func -(x: Self) -> Self","comment":"Return the result of negating `x`."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"Instances of conforming types can be subtracted, arithmetically\nnegated, and initialized from `0`.\n\nAxioms:\n\n- `x - 0 == x`\n- `-x == 0 - x`\n- `-(-x) == x`"},"SinkOf":{"kind":"struct","name":"SinkOf","slug":"SinkOf","inherits":["SinkType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"put","slug":"put","generic":{},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func put(x: T)","comment":"Write `x` to this sink."}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"putElement","type":"(T) -> ()","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance whose `put(x)` calls `putElement(x)`"},{"kind":"init","generic":{"line":"S : SinkType where T == T","types":["SinkType"]},"params":[{"name":"base","type":"S","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct an instance whose `put(x)` calls `base.put(x)`"}],"subscripts":[],"comment":"A type-erased sink.\n\nForwards operations to an arbitrary underlying sink with the same\n`Element` type, hiding the specifics of the underlying sink type."},"SinkType":{"kind":"protocol","name":"SinkType","slug":"SinkType","inherits":[],"inherited":["SinkOf","UnsafeMutablePointer"],"attr":"","operators":[],"functions":[{"kind":"func","name":"put","slug":"put","generic":{},"params":[{"name":"x","type":"Element","note":"","default":"","types":["Element"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func put(x: Element)","comment":"Write `x` to this sink."}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Element","type":"","proto":"","comment":"The type of element to be written to this sink."}],"inits":[],"subscripts":[],"comment":"Instances of conforming types are effectively functions with the\nsignature `(Element) -> Void`.\n\nUseful mainly when the optimizer's ability to specialize generics\noutstrips its ability to specialize ordinary closures.  For\nexample, you may find that instead of::\n\n  func f(g: (X)->Void) { ... g(a) ...}\n\nthe following generates better code::\n\n  func f<T: Sink where T.Element == X>(g: T) { ... g.put(a) ...}"},"Slice":{"kind":"struct","name":"Slice","slug":"Slice","inherits":["MutableCollectionType","Sliceable","ArrayLiteralConvertible","Reflectable","Printable","DebugPrintable","ArrayType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"IndexingGenerator<Slice<T>>","types":["IndexingGenerator","Slice"]},"note":"","attr":"","line":"func generate() -> IndexingGenerator<Slice<T>>","comment":"Return a *generator* over the elements.\n\nComplexity: O(1)"},{"kind":"func","name":"reserveCapacity","slug":"reserveCapacity","generic":{},"params":[{"name":"minimumCapacity","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func reserveCapacity(minimumCapacity: Int)","comment":"Reserve enough space to store minimumCapacity elements.\n\nPostCondition: `capacity >= minimumCapacity` and the array has\nmutable contiguous storage.\n\nComplexity: O(`count`)"},{"kind":"func","name":"append","slug":"append","generic":{},"params":[{"name":"newElement","type":"T","note":"","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func append(newElement: T)","comment":"Append newElement to the Slice\n\nComplexity: amortized O(1) unless `self`'s storage is shared with another live array; O(`count`) otherwise."},{"kind":"func","name":"extend","slug":"extend","generic":{"line":"S : SequenceType where T == T","types":["SequenceType"]},"params":[{"name":"newElements","type":"S","note":"","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func extend<S : SequenceType where T == T>(newElements: S)","comment":"Append the elements of `newElements` to `self`.\n\nComplexity: O(*length of result*) \n"},{"kind":"func","name":"removeLast","slug":"removeLast","generic":{},"params":[],"ret":{"line":"T","types":[]},"note":"mutating","attr":"","line":"mutating func removeLast() -> T","comment":"Remove an element from the end of the Slice in O(1).\nRequires: count > 0"},{"kind":"func","name":"insert","slug":"insert","generic":{},"params":[{"name":"newElement","type":"T","note":"","default":"","types":[]},{"name":"i","type":"Int","note":"atIndex","default":"","types":["Int"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func insert(newElement: T, atIndex i: Int)","comment":"Insert `newElement` at index `i`.\n\nRequires: `i <= count`\n\nComplexity: O(\\ `count`\\ )."},{"kind":"func","name":"removeAtIndex","slug":"removeAtIndex","generic":{},"params":[{"name":"index","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T","types":[]},"note":"mutating","attr":"","line":"mutating func removeAtIndex(index: Int) -> T","comment":"Remove and return the element at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `count`\\ )."},{"kind":"func","name":"removeAll","slug":"removeAll","generic":{},"params":[{"name":"keepCapacity","type":"Bool","note":"","default":"default","types":["Bool"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeAll(keepCapacity: Bool = default)","comment":"Remove all elements.\n\nPostcondition: `capacity == 0` iff `keepCapacity` is `false`.\n\nComplexity: O(\\ `countElements(self)`\\ )."},{"kind":"func","name":"join","slug":"join","generic":{"line":"S : SequenceType where Slice<T> == Slice<T>","types":["SequenceType","Slice"]},"params":[{"name":"elements","type":"S","note":"","default":"","types":[]}],"ret":{"line":"Slice<T>","types":["Slice"]},"note":"","attr":"","line":"func join<S : SequenceType where Slice<T> == Slice<T>>(elements: S) -> Slice<T>","comment":"Interpose `self` between each consecutive pair of `elements`,\nand concatenate the elements of the resulting sequence.  For\nexample, `[-1, -2].join([[1, 2, 3], [4, 5, 6], [7, 8, 9]])`\nyields `[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]`"},{"kind":"func","name":"reduce","slug":"reduce","generic":{"line":"U","types":[]},"params":[{"name":"initial","type":"U","note":"","default":"","types":[]},{"name":"combine","type":"(U, T) -> U","note":"","default":"","types":[]}],"ret":{"line":"U","types":[]},"note":"","attr":"","line":"func reduce<U>(initial: U, combine: (U, T) -> U) -> U","comment":"Return the result of repeatedly calling `combine` with an\naccumulated value initialized to `initial` and each element of\n`self`, in turn, i.e. return\n`combine(combine(...combine(combine(initial, self[0]),\nself[1]),...self[count-2]), self[count-1])`."},{"kind":"func","name":"sort","slug":"sort","generic":{},"params":[{"name":"isOrderedBefore","type":"(T, T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func sort(isOrderedBefore: (T, T) -> Bool)","comment":"Sort `self` in-place according to `isOrderedBefore`.  Requires:\n`isOrderedBefore` induces a `strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover the elements."},{"kind":"func","name":"sorted","slug":"sorted","generic":{},"params":[{"name":"isOrderedBefore","type":"(T, T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"Slice<T>","types":["Slice"]},"note":"","attr":"","line":"func sorted(isOrderedBefore: (T, T) -> Bool) -> Slice<T>","comment":"Return a copy of `self` that has been sorted according to\n`isOrderedBefore`.  Requires: `isOrderedBefore` induces a\n`strict weak ordering\n<http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings>`__\nover the elements."},{"kind":"func","name":"map","slug":"map","generic":{"line":"U","types":[]},"params":[{"name":"transform","type":"(T) -> U","note":"","default":"","types":[]}],"ret":{"line":"Slice<U>","types":["Slice"]},"note":"","attr":"","line":"func map<U>(transform: (T) -> U) -> Slice<U>","comment":"Return a `Slice` containing the results of calling\n`transform(x)` on each element `x` of `self`"},{"kind":"func","name":"reverse","slug":"reverse","generic":{},"params":[],"ret":{"line":"Slice<T>","types":["Slice"]},"note":"","attr":"","line":"func reverse() -> Slice<T>","comment":"A Slice containing the elements of `self` in reverse order"},{"kind":"func","name":"filter","slug":"filter","generic":{},"params":[{"name":"includeElement","type":"(T) -> Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"Slice<T>","types":["Slice"]},"note":"","attr":"","line":"func filter(includeElement: (T) -> Bool) -> Slice<T>","comment":"Return a `Slice` containing the elements `x` of `self` for which\n`includeElement(x)` is `true`"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"withUnsafeBufferPointer","slug":"withUnsafeBufferPointer","generic":{"line":"R","types":[]},"params":[{"name":"body","type":"(UnsafeBufferPointer<T>) -> R","note":"","default":"","types":["UnsafeBufferPointer"]}],"ret":{"line":"R","types":[]},"note":"","attr":"","line":"func withUnsafeBufferPointer<R>(body: (UnsafeBufferPointer<T>) -> R) -> R","comment":"Call `body(p)`, where `p` is a pointer to the `Slice`\\ 's\ncontiguous storage.\n\nOften, the optimizer can eliminate bounds checks within an\narray algorithm, but when that fails, invoking the\nsame algorithm on `body`\\ 's argument lets you trade safety for\nspeed."},{"kind":"func","name":"withUnsafeMutableBufferPointer","slug":"withUnsafeMutableBufferPointer","generic":{"line":"R","types":[]},"params":[{"name":"body","type":"(inout UnsafeMutableBufferPointer<T>) -> R","note":"","default":"","types":["UnsafeMutableBufferPointer"]}],"ret":{"line":"R","types":[]},"note":"mutating","attr":"","line":"mutating func withUnsafeMutableBufferPointer<R>(body: (inout UnsafeMutableBufferPointer<T>) -> R) -> R","comment":"Call `body(p)`, where `p` is a pointer to the `Slice`\\ 's\nmutable contiguous storage.\n\nOften, the optimizer can eliminate bounds- and uniqueness-checks\nwithin an array algorithm, but when that fails, invoking the\nsame algorithm on `body`\\ 's argument lets you trade safety for\nspeed."},{"kind":"func","name":"replaceRange","slug":"replaceRange","generic":{"line":"C : CollectionType where T == T","types":["CollectionType"]},"params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]},{"name":"newElements","type":"C","note":"with","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func replaceRange<C : CollectionType where T == T>(subRange: Range<Int>, with newElements: C)","comment":"Replace the given `subRange` of elements with `newElements`.\n\nComplexity: O(\\ `countElements(subRange)`\\ ) if `subRange.endIndex\n== self.endIndex` and `isEmpty(newElements)`\\ , O(N) otherwise."},{"kind":"func","name":"splice","slug":"splice","generic":{"line":"S : CollectionType where T == T","types":["CollectionType"]},"params":[{"name":"newElements","type":"S","note":"","default":"","types":[]},{"name":"i","type":"Int","note":"atIndex","default":"","types":["Int"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func splice<S : CollectionType where T == T>(newElements: S, atIndex i: Int)","comment":"Insert `newElements` at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `count + countElements(newElements)`\\ )."},{"kind":"func","name":"removeRange","slug":"removeRange","generic":{},"params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeRange(subRange: Range<Int>)","comment":"Remove the indicated `subRange` of elements\n\nComplexity: O(\\ `count`\\ )."}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"Always zero, which is the index of the first element when non-empty."},{"kind":"var","name":"endIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"A \"past-the-end\" element index; the successor of the last valid\nsubscript argument."},{"kind":"var","name":"count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"How many elements the Slice stores"},{"kind":"var","name":"capacity","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"How many elements the `Slice` can store without reallocation"},{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` if and only if the `Slice` is empty"},{"kind":"var","name":"first","type":"T?","readonly":true,"stat":"","subtypes":[],"comment":"The first element, or `nil` if the array is empty"},{"kind":"var","name":"last","type":"T?","readonly":true,"stat":"","subtypes":[],"comment":"The last element, or `nil` if the array is empty"},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[{"kind":"typealias","name":"Element","type":"T","proto":"","comment":"The type of element stored by this `Slice`"},{"kind":"typealias","name":"SubSlice","type":"Slice<T>","proto":"","comment":"A type that can represent a sub-range of a `Slice` "}],"inits":[{"kind":"init","generic":{},"params":[{"name":"buffer","type":"_SliceBuffer<T>","note":"_","default":"","types":["_SliceBuffer"]}],"init":"init","note":"","comment":"Initialization from an existing buffer does not have \"array.init\"\nsemantics because the caller may retain an alias to buffer."},{"kind":"init","generic":{},"params":[{"name":"elements","type":"T...","note":"arrayLiteral","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance containing `elements`."},{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Construct an empty Slice"},{"kind":"init","generic":{"line":"S : SequenceType where T == T","types":["SequenceType"]},"params":[{"name":"s","type":"S","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Construct from an arbitrary sequence with elements of type `T`"},{"kind":"init","generic":{},"params":[{"name":"count","type":"Int","note":"","default":"","types":["Int"]},{"name":"repeatedValue","type":"T","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Construct a Slice of `count` elements, each initialized to\n`repeatedValue`."}],"subscripts":[{"kind":"subscript","params":[{"name":"index","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T","types":[]},"comment":""},{"kind":"subscript","params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]}],"ret":{"line":"Slice<T>","types":["Slice"]},"comment":""}],"comment":"The `Array`-like type that represents a sub-sequence of any\n`Array`, `ContiguousArray`, or other `Slice`.\n\n`Slice` always uses contiguous storage and does not bridge to\nObjective-C.\n\n.. Warning:: Long-term storage of `Slice` instances is discouraged\n\n   Because a `Slice` presents a *view* onto the storage of some\n   larger array even after the original array's lifetime ends,\n   storing the slice may prolong the lifetime of elements that are\n   no longer accessible, which can manifest as apparent memory and\n   object leakage.  To prevent this effect, use `Slice` only for\n   transient computation."},"Sliceable":{"kind":"protocol","name":"Sliceable","slug":"Sliceable","inherits":["_Sliceable"],"inherited":["Array","ContiguousArray","MutableSliceable","Slice","String","String.UnicodeScalarView","String.UTF16View"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"SubSlice","type":"","proto":"_Sliceable","comment":"The *collection* type that represents a sub-range of elements.\n\nThough it can't currently be enforced by the type system, the\n`SubSlice` type in a concrete implementation of `Sliceable`\nshould also be `Sliceable`."}],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"bounds","type":"Range<Self.Index>","note":"","default":"","types":["Index","Range","Self"]}],"ret":{"line":"SubSlice { get }","types":["SubSlice"]},"comment":""}],"comment":"A *collection* from which a sub-range of elements (a \"slice\")\ncan be efficiently extracted."},"StaticString":{"kind":"struct","name":"StaticString","slug":"StaticString","inherits":["UnicodeScalarLiteralConvertible","ExtendedGraphemeClusterLiteralConvertible","StringLiteralConvertible","Printable","DebugPrintable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"withUTF8Buffer","slug":"withUTF8Buffer","generic":{"line":"R","types":[]},"params":[{"name":"body","type":"(UnsafeBufferPointer<UInt8>) -> R","note":"","default":"","types":["UInt8","UnsafeBufferPointer"]}],"ret":{"line":"R","types":[]},"note":"","attr":"","line":"func withUTF8Buffer<R>(body: (UnsafeBufferPointer<UInt8>) -> R) -> R","comment":"Invoke `body` with a buffer containing the UTF-8 code units of\n`self`.\n\nThis method works regardless of what `self` stores."}],"types":[],"properties":[{"kind":"var","name":"utf8Start","type":"UnsafePointer<UInt8>","readonly":true,"stat":"","subtypes":["UInt8","UnsafePointer"],"comment":"A pointer to the beginning of UTF-8 code units\n\nRequires: `self` stores a pointer to either ASCII or UTF-8 code\nunits."},{"kind":"var","name":"unicodeScalar","type":"UnicodeScalar","readonly":true,"stat":"","subtypes":["UnicodeScalar"],"comment":"The stored Unicode scalar value\n\nRequires: `self` stores a single Unicode scalar value."},{"kind":"var","name":"byteSize","type":"Word","readonly":true,"stat":"","subtypes":["Word"],"comment":"If `self` stores a pointer to ASCII or UTF-8 code units, the\nlength in bytes of that data.\n\nIf `self` stores a single Unicode scalar value, the value of\n`byteSize` is unspecified."},{"kind":"var","name":"hasPointerRepresentation","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` stores a pointer to ASCII or UTF-8 code units"},{"kind":"var","name":"isASCII","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` if `self` stores a pointer to ASCII code units.\n\nIf `self` stores a single Unicode scalar value, the value of\n`isASCII` is unspecified."},{"kind":"var","name":"stringValue","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"Return a `String` representing the same sequence of Unicode\nscalar values as `self` does."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an empty instance."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int32","note":"_builtinUnicodeScalarLiteral","default":"","types":["Builtin","Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"StaticString","note":"unicodeScalarLiteral","default":"","types":["StaticString"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"start","type":"Builtin.RawPointer","note":"_builtinExtendedGraphemeClusterLiteral","default":"","types":["Builtin","RawPointer"]},{"name":"byteSize","type":"Builtin.Word","note":"","default":"","types":["Builtin","Word"]},{"name":"isASCII","type":"Builtin.Int1","note":"","default":"","types":["Builtin","Int1"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"StaticString","note":"extendedGraphemeClusterLiteral","default":"","types":["StaticString"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"start","type":"Builtin.RawPointer","note":"_builtinStringLiteral","default":"","types":["Builtin","RawPointer"]},{"name":"byteSize","type":"Builtin.Word","note":"","default":"","types":["Builtin","Word"]},{"name":"isASCII","type":"Builtin.Int1","note":"","default":"","types":["Builtin","Int1"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"StaticString","note":"stringLiteral","default":"","types":["StaticString"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."}],"subscripts":[],"comment":"An simple string designed to represent text that is \"knowable at\ncompile-time\".\n\nLogically speaking, each instance looks something like this::\n\n   enum StaticString {\n      case ASCII(start: UnsafePointer<UInt8>, length: Int)\n      case UTF8(start: UnsafePointer<UInt8>, length: Int)\n      case Scalar(UnicodeScalar)\n   }"},"Streamable":{"kind":"protocol","name":"Streamable","slug":"Streamable","inherits":[],"inherited":["Character","String","UnicodeScalar"],"attr":"","operators":[],"functions":[{"kind":"func","name":"writeTo","slug":"writeTo","generic":{"line":"Target : OutputStreamType","types":["OutputStreamType","Target"]},"params":[{"name":"target","type":"Target","note":"inout","default":"","types":["Target"]}],"ret":{},"note":"","attr":"","line":"func writeTo<Target : OutputStreamType>(inout target: Target)","comment":"Write a textual representation of `self` into `target`"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A source of text streaming operations.  `Streamable` instances can\nbe written to any *output stream*.\n\nFor example: `String`, `Character`, `UnicodeScalar`."},"StrideThrough":{"kind":"struct","name":"StrideThrough","slug":"StrideThrough","inherits":["SequenceType","Reflectable"],"inherited":[],"generic":{"line":"T : Strideable","types":["Strideable"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"StrideThroughGenerator<T>","types":["StrideThroughGenerator"]},"note":"","attr":"","line":"func generate() -> StrideThroughGenerator<T>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A `SequenceType` of values formed by striding over a closed interval"},"StrideThroughGenerator":{"kind":"struct","name":"StrideThroughGenerator","slug":"StrideThroughGenerator","inherits":["GeneratorType"],"inherited":[],"generic":{"line":"T : Strideable","types":["Strideable"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"T?","types":[]},"note":"mutating","attr":"","line":"mutating func next() -> T?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A GeneratorType for StrideThrough<T>"},"StrideTo":{"kind":"struct","name":"StrideTo","slug":"StrideTo","inherits":["SequenceType","Reflectable"],"inherited":[],"generic":{"line":"T : Strideable","types":["Strideable"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"StrideToGenerator<T>","types":["StrideToGenerator"]},"note":"","attr":"","line":"func generate() -> StrideToGenerator<T>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A `SequenceType` of values formed by striding over a half-open interval"},"StrideToGenerator":{"kind":"struct","name":"StrideToGenerator","slug":"StrideToGenerator","inherits":["GeneratorType"],"inherited":[],"generic":{"line":"T : Strideable","types":["Strideable"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"T?","types":[]},"note":"mutating","attr":"","line":"mutating func next() -> T?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A GeneratorType for StrideTo<T>"},"Strideable":{"kind":"protocol","name":"Strideable","slug":"Strideable","inherits":["Comparable","_Strideable"],"inherited":["Double","Float","Float80","FloatingPointType","_RandomAccessIndexType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"Conforming types are notionally continuous, one-dimensional\nvalues that can be offset and measured.\n\nSee also: `stride(from: to: by:)` and `stride(from: through: by:)`"},"String":{"kind":"struct","name":"String","slug":"String","inherits":["CollectionType","Reflectable","OutputStreamType","Streamable","UnicodeScalarLiteralConvertible","ExtendedGraphemeClusterLiteralConvertible","StringLiteralConvertible","DebugPrintable","Equatable","Comparable","Hashable","StringInterpolationConvertible","Sliceable","ExtensibleCollectionType","RangeReplaceableCollectionType","_ObjectiveCBridgeable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"IndexingGenerator<String>","types":["IndexingGenerator","String"]},"note":"","attr":"","line":"func generate() -> IndexingGenerator<String>","comment":"Return a *generator* over the `Characters` in this `String`.\n\nComplexity: O(1)"},{"kind":"func","name":"fromCString","slug":"fromCString","generic":{},"params":[{"name":"cs","type":"UnsafePointer<CChar>","note":"","default":"","types":["CChar","UnsafePointer"]}],"ret":{"line":"String?","types":["String"]},"note":"static","attr":"","line":"static func fromCString(cs: UnsafePointer<CChar>) -> String?","comment":"Creates a new `String` by copying the nul-terminated UTF-8 data\nreferenced by a `CString`.\n\nReturns `nil` if the `CString` is `NULL` or if it contains ill-formed\nUTF-8 code unit sequences."},{"kind":"func","name":"fromCStringRepairingIllFormedUTF8","slug":"fromCStringRepairingIllFormedUTF8","generic":{},"params":[{"name":"cs","type":"UnsafePointer<CChar>","note":"","default":"","types":["CChar","UnsafePointer"]}],"ret":{"line":"(String?, hadError: Bool)","types":["Bool","String"]},"note":"static","attr":"","line":"static func fromCStringRepairingIllFormedUTF8(cs: UnsafePointer<CChar>) -> (String?, hadError: Bool)","comment":"Creates a new `String` by copying the nul-terminated UTF-8 data\nreferenced by a `CString`.\n\nReturns `nil` if the `CString` is `NULL`.  If `CString` contains\nill-formed UTF-8 code unit sequences, replaces them with replacement\ncharacters (U+FFFD)."},{"kind":"func","name":"withCString","slug":"withCString","generic":{"line":"Result","types":["Result"]},"params":[{"name":"f","type":"(UnsafePointer<Int8>) -> Result","note":"","default":"","types":["Int8","Result","UnsafePointer"]}],"ret":{"line":"Result","types":["Result"]},"note":"","attr":"","line":"func withCString<Result>(f: (UnsafePointer<Int8>) -> Result) -> Result","comment":"Invoke `f` on the contents of this string, represented as\na nul-terminated array of char, ensuring that the array's\nlifetime extends through the execution of `f`."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"write","slug":"write","generic":{},"params":[{"name":"other","type":"String","note":"","default":"","types":["String"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func write(other: String)","comment":""},{"kind":"func","name":"writeTo","slug":"writeTo","generic":{"line":"Target : OutputStreamType","types":["OutputStreamType","Target"]},"params":[{"name":"target","type":"Target","note":"inout","default":"","types":["Target"]}],"ret":{},"note":"","attr":"","line":"func writeTo<Target : OutputStreamType>(inout target: Target)","comment":"Write a textual representation of `self` into `target`"},{"kind":"func","name":"extend","slug":"extend","generic":{},"params":[{"name":"other","type":"String","note":"","default":"","types":["String"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func extend(other: String)","comment":"Append the elements of `other` to `self`."},{"kind":"func","name":"append","slug":"append","generic":{},"params":[{"name":"x","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func append(x: UnicodeScalar)","comment":"Append `x` to `self`.\n\nComplexity: amortized O(1)."},{"kind":"func","name":"convertFromStringInterpolation","slug":"convertFromStringInterpolation","generic":{},"params":[{"name":"strings","type":"String...","note":"","default":"","types":["String"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolation(strings: String...) -> String","comment":"Create an instance by concatenating the elements of `strings`"},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{"line":"T","types":[]},"params":[{"name":"expr","type":"T","note":"","default":"","types":[]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment<T>(expr: T) -> String","comment":"Create an instance containing `expr`\\ 's `print` representation"},{"kind":"func","name":"reserveCapacity","slug":"reserveCapacity","generic":{},"params":[{"name":"n","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func reserveCapacity(n: Int)","comment":"Reserve enough space to store `n` ASCII characters.\n\nComplexity: O(`n`)"},{"kind":"func","name":"append","slug":"append","generic":{},"params":[{"name":"c","type":"Character","note":"","default":"","types":["Character"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func append(c: Character)","comment":"Append `c` to `self`.\n\nComplexity: amortized O(1)."},{"kind":"func","name":"extend","slug":"extend","generic":{"line":"S : SequenceType where Character == Character","types":["Character","SequenceType"]},"params":[{"name":"newElements","type":"S","note":"","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func extend<S : SequenceType where Character == Character>(newElements: S)","comment":"Append the elements of `newElements` to `self`."},{"kind":"func","name":"join","slug":"join","generic":{"line":"S : SequenceType where String == String","types":["SequenceType","String"]},"params":[{"name":"elements","type":"S","note":"","default":"","types":[]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func join<S : SequenceType where String == String>(elements: S) -> String","comment":"Interpose `self` between every pair of consecutive `elements`,\nthen concatenate the result.  For example::\n\n  \"-|-\".join([\"foo\", \"bar\", \"baz\"]) // \"foo-|-bar-|-baz\""},{"kind":"func","name":"replaceRange","slug":"replaceRange","generic":{"line":"C : CollectionType where Character == Character","types":["Character","CollectionType"]},"params":[{"name":"subRange","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]},{"name":"newElements","type":"C","note":"with","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func replaceRange<C : CollectionType where Character == Character>(subRange: Range<String.Index>, with newElements: C)","comment":"Replace the given `subRange` of elements with `newElements`.\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `countElements(subRange)`\\ ) if `subRange.endIndex\n== self.endIndex` and `isEmpty(newElements)`\\ , O(N) otherwise."},{"kind":"func","name":"insert","slug":"insert","generic":{},"params":[{"name":"newElement","type":"Character","note":"","default":"","types":["Character"]},{"name":"i","type":"String.Index","note":"atIndex","default":"","types":["Index","String"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func insert(newElement: Character, atIndex i: String.Index)","comment":"Insert `newElement` at index `i`.\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `countElements(self)`\\ )."},{"kind":"func","name":"splice","slug":"splice","generic":{"line":"S : CollectionType where Character == Character","types":["Character","CollectionType"]},"params":[{"name":"newElements","type":"S","note":"","default":"","types":[]},{"name":"i","type":"String.Index","note":"atIndex","default":"","types":["Index","String"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func splice<S : CollectionType where Character == Character>(newElements: S, atIndex i: String.Index)","comment":"Insert `newElements` at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `countElements(self) + countElements(newElements)`\\ )."},{"kind":"func","name":"removeAtIndex","slug":"removeAtIndex","generic":{},"params":[{"name":"i","type":"String.Index","note":"","default":"","types":["Index","String"]}],"ret":{"line":"Character","types":["Character"]},"note":"mutating","attr":"","line":"mutating func removeAtIndex(i: String.Index) -> Character","comment":"Remove and return the element at index `i`\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `countElements(self)`\\ )."},{"kind":"func","name":"removeRange","slug":"removeRange","generic":{},"params":[{"name":"subRange","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeRange(subRange: Range<String.Index>)","comment":"Remove the indicated `subRange` of characters\n\nInvalidates all indices with respect to `self`.\n\nComplexity: O(\\ `countElements(self)`\\ )."},{"kind":"func","name":"removeAll","slug":"removeAll","generic":{},"params":[{"name":"keepCapacity","type":"Bool","note":"","default":"default","types":["Bool"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func removeAll(keepCapacity: Bool = default)","comment":"Remove all characters.\n\nInvalidates all indices with respect to `self`.\n\n:param: `keepCapacity`, if `true`, prevents the release of\n/   allocated storage, which can be a useful optimization\n   when `self` is going to be grown again."},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: String) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"Character","note":"","default":"","types":["Character"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: Character) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: UnicodeScalar) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: Bool) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"Float32","note":"","default":"","types":["Float32"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: Float32) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"Float64","note":"","default":"","types":["Float64"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: Float64) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: UInt8) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"Int8","note":"","default":"","types":["Int8"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: Int8) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: UInt16) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"Int16","note":"","default":"","types":["Int16"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: Int16) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: UInt32) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"Int32","note":"","default":"","types":["Int32"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: Int32) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: UInt64) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"Int64","note":"","default":"","types":["Int64"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: Int64) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: UInt) -> String","comment":""},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{},"params":[{"name":"expr","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func convertFromStringInterpolationSegment(expr: Int) -> String","comment":""},{"kind":"func","name":"hasPrefix","slug":"hasPrefix","generic":{},"params":[{"name":"prefix","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func hasPrefix(prefix: String) -> Bool","comment":"Return `true` iff `self` begins with `prefix`"},{"kind":"func","name":"hasSuffix","slug":"hasSuffix","generic":{},"params":[{"name":"suffix","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func hasSuffix(suffix: String) -> Bool","comment":"Return `true` iff `self` ends with `suffix`"},{"kind":"func","name":"toInt","slug":"toInt","generic":{},"params":[],"ret":{"line":"Int?","types":["Int"]},"note":"","attr":"","line":"func toInt() -> Int?","comment":"If the string represents an integer that fits into an Int, returns\nthe corresponding integer.  This accepts strings that match the regular\nexpression \"[-+]?[0-9]+\" only."},{"kind":"func","name":"availableStringEncodings","slug":"availableStringEncodings","generic":{},"params":[],"ret":{"line":"[NSStringEncoding]","types":["NSStringEncoding"]},"note":"static","attr":"","line":"static func availableStringEncodings() -> [NSStringEncoding]","comment":"*[Foundation]* Returns an Array of the encodings string objects support\nin the application’s environment.\n "},{"kind":"func","name":"defaultCStringEncoding","slug":"defaultCStringEncoding","generic":{},"params":[],"ret":{"line":"NSStringEncoding","types":["NSStringEncoding"]},"note":"static","attr":"","line":"static func defaultCStringEncoding() -> NSStringEncoding","comment":"*[Foundation]* Returns the C-string encoding assumed for any method accepting\na C string as an argument."},{"kind":"func","name":"localizedNameOfStringEncoding","slug":"localizedNameOfStringEncoding","generic":{},"params":[{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func localizedNameOfStringEncoding(encoding: NSStringEncoding) -> String","comment":"*[Foundation]* Returns a human-readable string giving the name of a given encoding."},{"kind":"func","name":"localizedStringWithFormat","slug":"localizedStringWithFormat","generic":{},"params":[{"name":"format","type":"String","note":"","default":"","types":["String"]},{"name":"arguments","type":"CVarArgType...","note":"_","default":"","types":["CVarArgType"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func localizedStringWithFormat(format: String, _ arguments: CVarArgType...) -> String","comment":"*[Foundation]* Returns a string created by using a given format string as a\ntemplate into which the remaining argument values are substituted\naccording to the user's default locale."},{"kind":"func","name":"pathWithComponents","slug":"pathWithComponents","generic":{},"params":[{"name":"components","type":"[String]","note":"","default":"","types":["String"]}],"ret":{"line":"String","types":["String"]},"note":"static","attr":"","line":"static func pathWithComponents(components: [String]) -> String","comment":"*[Foundation]* Returns a string built from the strings in a given array\nby concatenating them with a path separator between each pair."},{"kind":"func","name":"canBeConvertedToEncoding","slug":"canBeConvertedToEncoding","generic":{},"params":[{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func canBeConvertedToEncoding(encoding: NSStringEncoding) -> Bool","comment":"*[Foundation]* Returns a Boolean value that indicates whether the\n`String` can be converted to a given encoding without loss of\ninformation."},{"kind":"func","name":"capitalizedStringWithLocale","slug":"capitalizedStringWithLocale","generic":{},"params":[{"name":"locale","type":"NSLocale?","note":"","default":"","types":["NSLocale"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func capitalizedStringWithLocale(locale: NSLocale?) -> String","comment":"*[Foundation]* Returns a capitalized representation of the `String`\nusing the specified locale."},{"kind":"func","name":"caseInsensitiveCompare","slug":"caseInsensitiveCompare","generic":{},"params":[{"name":"aString","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"NSComparisonResult","types":["NSComparisonResult"]},"note":"","attr":"","line":"func caseInsensitiveCompare(aString: String) -> NSComparisonResult","comment":"*[Foundation]* Returns the result of invoking `compare:options:` with\n`NSCaseInsensitiveSearch` as the only option."},{"kind":"func","name":"commonPrefixWithString","slug":"commonPrefixWithString","generic":{},"params":[{"name":"aString","type":"String","note":"","default":"","types":["String"]},{"name":"options","type":"NSStringCompareOptions","note":"","default":"","types":["NSStringCompareOptions"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func commonPrefixWithString(aString: String, options: NSStringCompareOptions) -> String","comment":"*[Foundation]* Returns a string containing characters the `String` and a\ngiven string have in common, starting from the beginning of each\nup to the first characters that aren’t equivalent.\n "},{"kind":"func","name":"compare","slug":"compare","generic":{},"params":[{"name":"aString","type":"String","note":"","default":"","types":["String"]},{"name":"mask","type":"NSStringCompareOptions","note":"options","default":"default","types":["NSStringCompareOptions"]},{"name":"range","type":"Range<String.Index>?","note":"","default":"default","types":["Index","Range","String"]},{"name":"locale","type":"NSLocale?","note":"","default":"default","types":["NSLocale"]}],"ret":{"line":"NSComparisonResult","types":["NSComparisonResult"]},"note":"","attr":"","line":"func compare(aString: String, options mask: NSStringCompareOptions = default, range: Range<String.Index>? = default, locale: NSLocale? = default) -> NSComparisonResult","comment":"*[Foundation]* Compares the string using the specified options and\nreturns the lexical ordering for the range."},{"kind":"func","name":"completePathIntoString","slug":"completePathIntoString","generic":{},"params":[{"name":"outputName","type":"UnsafeMutablePointer<String>","note":"_","default":"default","types":["String","UnsafeMutablePointer"]},{"name":"caseSensitive","type":"Bool","note":"","default":"","types":["Bool"]},{"name":"matchesIntoArray","type":"UnsafeMutablePointer<[String]>","note":"","default":"default","types":["String","UnsafeMutablePointer"]},{"name":"filterTypes","type":"[String]?","note":"","default":"default","types":["String"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func completePathIntoString(_ outputName: UnsafeMutablePointer<String> = default, caseSensitive: Bool, matchesIntoArray: UnsafeMutablePointer<[String]> = default, filterTypes: [String]? = default) -> Int","comment":"*[Foundation]* Interprets the `String` as a path in the file system and\nattempts to perform filename completion, returning a numeric\nvalue that indicates whether a match was possible, and by\nreference the longest path that matches the `String`.\nReturns the actual number of matching paths."},{"kind":"func","name":"componentsSeparatedByCharactersInSet","slug":"componentsSeparatedByCharactersInSet","generic":{},"params":[{"name":"separator","type":"NSCharacterSet","note":"","default":"","types":["NSCharacterSet"]}],"ret":{"line":"[String]","types":["String"]},"note":"","attr":"","line":"func componentsSeparatedByCharactersInSet(separator: NSCharacterSet) -> [String]","comment":"*[Foundation]* Returns an array containing substrings from the `String`\nthat have been divided by characters in a given set."},{"kind":"func","name":"componentsSeparatedByString","slug":"componentsSeparatedByString","generic":{},"params":[{"name":"separator","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"[String]","types":["String"]},"note":"","attr":"","line":"func componentsSeparatedByString(separator: String) -> [String]","comment":"*[Foundation]* Returns an array containing substrings from the `String`\nthat have been divided by a given separator."},{"kind":"func","name":"cStringUsingEncoding","slug":"cStringUsingEncoding","generic":{},"params":[{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]}],"ret":{"line":"[CChar]?","types":["CChar"]},"note":"","attr":"","line":"func cStringUsingEncoding(encoding: NSStringEncoding) -> [CChar]?","comment":"*[Foundation]* Returns a representation of the `String` as a C string\nusing a given encoding."},{"kind":"func","name":"dataUsingEncoding","slug":"dataUsingEncoding","generic":{},"params":[{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]},{"name":"allowLossyConversion","type":"Bool","note":"","default":"default","types":["Bool"]}],"ret":{"line":"NSData?","types":["NSData"]},"note":"","attr":"","line":"func dataUsingEncoding(encoding: NSStringEncoding, allowLossyConversion: Bool = default) -> NSData?","comment":"*[Foundation]* Returns an `NSData` object containing a representation of\nthe `String` encoded using a given encoding."},{"kind":"func","name":"enumerateLines","slug":"enumerateLines","generic":{},"params":[{"name":"body","type":"(line: String, inout stop: Bool) -> ()","note":"","default":"","types":["Bool","String"]}],"ret":{},"note":"","attr":"","line":"func enumerateLines(body: (line: String, inout stop: Bool) -> ())","comment":"*[Foundation]* Enumerates all the lines in a string."},{"kind":"func","name":"enumerateLinguisticTagsInRange","slug":"enumerateLinguisticTagsInRange","generic":{},"params":[{"name":"range","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]},{"name":"tagScheme","type":"String","note":"scheme","default":"","types":["String"]},{"name":"opts","type":"NSLinguisticTaggerOptions","note":"options","default":"","types":["NSLinguisticTaggerOptions"]},{"name":"orthography","type":"NSOrthography?","note":"","default":"","types":["NSOrthography"]},{"name":"body","type":"(String, Range<String.Index>, Range<String.Index>, inout Bool) -> ()","note":"_","default":"","types":["Bool","Index","Range","String"]}],"ret":{},"note":"","attr":"","line":"func enumerateLinguisticTagsInRange(range: Range<String.Index>, scheme tagScheme: String, options opts: NSLinguisticTaggerOptions, orthography: NSOrthography?, _ body: (String, Range<String.Index>, Range<String.Index>, inout Bool) -> ())","comment":"*[Foundation]* Performs linguistic analysis on the specified string by\nenumerating the specific range of the string, providing the\nBlock with the located tags."},{"kind":"func","name":"enumerateSubstringsInRange","slug":"enumerateSubstringsInRange","generic":{},"params":[{"name":"range","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]},{"name":"opts","type":"NSStringEnumerationOptions","note":"options","default":"","types":["NSStringEnumerationOptions"]},{"name":"body","type":"(substring: String, substringRange: Range<String.Index>, enclosingRange: Range<String.Index>, inout Bool) -> ()","note":"_","default":"","types":["Bool","Index","Range","String"]}],"ret":{},"note":"","attr":"","line":"func enumerateSubstringsInRange(range: Range<String.Index>, options opts: NSStringEnumerationOptions, _ body: (substring: String, substringRange: Range<String.Index>, enclosingRange: Range<String.Index>, inout Bool) -> ())","comment":"*[Foundation]* Enumerates the substrings of the specified type in the\nspecified range of the string."},{"kind":"func","name":"fileSystemRepresentation","slug":"fileSystemRepresentation","generic":{},"params":[],"ret":{"line":"[CChar]","types":["CChar"]},"note":"","attr":"","line":"func fileSystemRepresentation() -> [CChar]","comment":"*[Foundation]* Returns a file system-specific representation of the `String`."},{"kind":"func","name":"getBytes","slug":"getBytes","generic":{},"params":[{"name":"buffer","type":"[UInt8]","note":"inout","default":"","types":["UInt8"]},{"name":"maxLength","type":"Int","note":"","default":"","types":["Int"]},{"name":"usedLength","type":"UnsafeMutablePointer<Int>","note":"","default":"","types":["Int","UnsafeMutablePointer"]},{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]},{"name":"options","type":"NSStringEncodingConversionOptions","note":"","default":"","types":["NSStringEncodingConversionOptions"]},{"name":"range","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]},{"name":"remainingRange","type":"UnsafeMutablePointer<Range<String.Index>>","note":"","default":"","types":["Index","Range","String","UnsafeMutablePointer"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func getBytes(inout buffer: [UInt8], maxLength: Int, usedLength: UnsafeMutablePointer<Int>, encoding: NSStringEncoding, options: NSStringEncodingConversionOptions, range: Range<String.Index>, remainingRange: UnsafeMutablePointer<Range<String.Index>>) -> Bool","comment":"*[Foundation]* Gets a given range of characters as bytes in a specified encoding.\nNote: will get a maximum of `min(buffer.count, maxLength)` bytes."},{"kind":"func","name":"getCString","slug":"getCString","generic":{},"params":[{"name":"buffer","type":"[CChar]","note":"inout","default":"","types":["CChar"]},{"name":"maxLength","type":"Int","note":"","default":"","types":["Int"]},{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func getCString(inout buffer: [CChar], maxLength: Int, encoding: NSStringEncoding) -> Bool","comment":"*[Foundation]* Converts the `String`’s content to a given encoding and\n \nstores them in a buffer. Note: will store a maximum of\n`min(buffer.count, maxLength)` bytes."},{"kind":"func","name":"getFileSystemRepresentation","slug":"getFileSystemRepresentation","generic":{},"params":[{"name":"buffer","type":"[CChar]","note":"inout","default":"","types":["CChar"]},{"name":"maxLength","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func getFileSystemRepresentation(inout buffer: [CChar], maxLength: Int) -> Bool","comment":"*[Foundation]* Interprets the `String` as a system-independent path and\nfills a buffer with a C-string in a format and encoding suitable\nfor use with file-system calls. Note: will store a maximum of\n`min(buffer.count, maxLength)` bytes."},{"kind":"func","name":"getLineStart","slug":"getLineStart","generic":{},"params":[{"name":"start","type":"UnsafeMutablePointer<String.Index>","note":"","default":"","types":["Index","String","UnsafeMutablePointer"]},{"name":"end","type":"UnsafeMutablePointer<String.Index>","note":"","default":"","types":["Index","String","UnsafeMutablePointer"]},{"name":"contentsEnd","type":"UnsafeMutablePointer<String.Index>","note":"","default":"","types":["Index","String","UnsafeMutablePointer"]},{"name":"forRange","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]}],"ret":{},"note":"","attr":"","line":"func getLineStart(start: UnsafeMutablePointer<String.Index>, end: UnsafeMutablePointer<String.Index>, contentsEnd: UnsafeMutablePointer<String.Index>, forRange: Range<String.Index>)","comment":"*[Foundation]* Returns by reference the beginning of the first line and\nthe end of the last line touched by the given range."},{"kind":"func","name":"getParagraphStart","slug":"getParagraphStart","generic":{},"params":[{"name":"start","type":"UnsafeMutablePointer<String.Index>","note":"","default":"","types":["Index","String","UnsafeMutablePointer"]},{"name":"end","type":"UnsafeMutablePointer<String.Index>","note":"","default":"","types":["Index","String","UnsafeMutablePointer"]},{"name":"contentsEnd","type":"UnsafeMutablePointer<String.Index>","note":"","default":"","types":["Index","String","UnsafeMutablePointer"]},{"name":"forRange","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]}],"ret":{},"note":"","attr":"","line":"func getParagraphStart(start: UnsafeMutablePointer<String.Index>, end: UnsafeMutablePointer<String.Index>, contentsEnd: UnsafeMutablePointer<String.Index>, forRange: Range<String.Index>)","comment":"*[Foundation]* Returns by reference the beginning of the first paragraph\nand the end of the last paragraph touched by the given range."},{"kind":"func","name":"lengthOfBytesUsingEncoding","slug":"lengthOfBytesUsingEncoding","generic":{},"params":[{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func lengthOfBytesUsingEncoding(encoding: NSStringEncoding) -> Int","comment":"*[Foundation]* Returns the number of bytes required to store the\n`String` in a given encoding."},{"kind":"func","name":"lineRangeForRange","slug":"lineRangeForRange","generic":{},"params":[{"name":"aRange","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]}],"ret":{"line":"Range<String.Index>","types":["Index","Range","String"]},"note":"","attr":"","line":"func lineRangeForRange(aRange: Range<String.Index>) -> Range<String.Index>","comment":"*[Foundation]* Returns the range of characters representing the line or lines\ncontaining a given range."},{"kind":"func","name":"linguisticTagsInRange","slug":"linguisticTagsInRange","generic":{},"params":[{"name":"range","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]},{"name":"tagScheme","type":"String","note":"scheme","default":"","types":["String"]},{"name":"opts","type":"NSLinguisticTaggerOptions","note":"options","default":"default","types":["NSLinguisticTaggerOptions"]},{"name":"orthography","type":"NSOrthography?","note":"","default":"default","types":["NSOrthography"]},{"name":"tokenRanges","type":"UnsafeMutablePointer<[Range<String.Index>]>","note":"","default":"default","types":["Index","Range","String","UnsafeMutablePointer"]}],"ret":{"line":"[String]","types":["String"]},"note":"","attr":"","line":"func linguisticTagsInRange(range: Range<String.Index>, scheme tagScheme: String, options opts: NSLinguisticTaggerOptions = default, orthography: NSOrthography? = default, tokenRanges: UnsafeMutablePointer<[Range<String.Index>]> = default) -> [String]","comment":"*[Foundation]* Returns an array of linguistic tags for the specified\nrange and requested tags within the receiving string."},{"kind":"func","name":"localizedCaseInsensitiveCompare","slug":"localizedCaseInsensitiveCompare","generic":{},"params":[{"name":"aString","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"NSComparisonResult","types":["NSComparisonResult"]},"note":"","attr":"","line":"func localizedCaseInsensitiveCompare(aString: String) -> NSComparisonResult","comment":"*[Foundation]* Compares the string and a given string using a\ncase-insensitive, localized, comparison."},{"kind":"func","name":"localizedCompare","slug":"localizedCompare","generic":{},"params":[{"name":"aString","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"NSComparisonResult","types":["NSComparisonResult"]},"note":"","attr":"","line":"func localizedCompare(aString: String) -> NSComparisonResult","comment":"*[Foundation]* Compares the string and a given string using a localized\ncomparison."},{"kind":"func","name":"localizedStandardCompare","slug":"localizedStandardCompare","generic":{},"params":[{"name":"string","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"NSComparisonResult","types":["NSComparisonResult"]},"note":"","attr":"","line":"func localizedStandardCompare(string: String) -> NSComparisonResult","comment":"*[Foundation]* Compares strings as sorted by the Finder."},{"kind":"func","name":"lowercaseStringWithLocale","slug":"lowercaseStringWithLocale","generic":{},"params":[{"name":"locale","type":"NSLocale","note":"","default":"","types":["NSLocale"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func lowercaseStringWithLocale(locale: NSLocale) -> String","comment":"*[Foundation]* Returns a version of the string with all letters\nconverted to lowercase, taking into account the specified\nlocale."},{"kind":"func","name":"maximumLengthOfBytesUsingEncoding","slug":"maximumLengthOfBytesUsingEncoding","generic":{},"params":[{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func maximumLengthOfBytesUsingEncoding(encoding: NSStringEncoding) -> Int","comment":"*[Foundation]* Returns the maximum number of bytes needed to store the\n`String` in a given encoding."},{"kind":"func","name":"paragraphRangeForRange","slug":"paragraphRangeForRange","generic":{},"params":[{"name":"aRange","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]}],"ret":{"line":"Range<String.Index>","types":["Index","Range","String"]},"note":"","attr":"","line":"func paragraphRangeForRange(aRange: Range<String.Index>) -> Range<String.Index>","comment":"*[Foundation]* Returns the range of characters representing the\nparagraph or paragraphs containing a given range."},{"kind":"func","name":"propertyList","slug":"propertyList","generic":{},"params":[],"ret":{"line":"AnyObject","types":["AnyObject"]},"note":"","attr":"","line":"func propertyList() -> AnyObject","comment":"*[Foundation]* Parses the `String` as a text representation of a\nproperty list, returning an NSString, NSData, NSArray, or\nNSDictionary object, according to the topmost element."},{"kind":"func","name":"propertyListFromStringsFileFormat","slug":"propertyListFromStringsFileFormat","generic":{},"params":[],"ret":{"line":"[String : String]","types":["String"]},"note":"","attr":"","line":"func propertyListFromStringsFileFormat() -> [String : String]","comment":"*[Foundation]* Returns a dictionary object initialized with the keys and\nvalues found in the `String`."},{"kind":"func","name":"rangeOfCharacterFromSet","slug":"rangeOfCharacterFromSet","generic":{},"params":[{"name":"aSet","type":"NSCharacterSet","note":"","default":"","types":["NSCharacterSet"]},{"name":"mask","type":"NSStringCompareOptions","note":"options","default":"default","types":["NSStringCompareOptions"]},{"name":"aRange","type":"Range<String.Index>?","note":"range","default":"default","types":["Index","Range","String"]}],"ret":{"line":"Range<String.Index>?","types":["Index","Range","String"]},"note":"","attr":"","line":"func rangeOfCharacterFromSet(aSet: NSCharacterSet, options mask: NSStringCompareOptions = default, range aRange: Range<String.Index>? = default) -> Range<String.Index>?","comment":"*[Foundation]* Finds and returns the range in the `String` of the first\ncharacter from a given character set found in a given range with\ngiven options."},{"kind":"func","name":"rangeOfComposedCharacterSequenceAtIndex","slug":"rangeOfComposedCharacterSequenceAtIndex","generic":{},"params":[{"name":"anIndex","type":"String.Index","note":"","default":"","types":["Index","String"]}],"ret":{"line":"Range<String.Index>","types":["Index","Range","String"]},"note":"","attr":"","line":"func rangeOfComposedCharacterSequenceAtIndex(anIndex: String.Index) -> Range<String.Index>","comment":"*[Foundation]* Returns the range in the `String` of the composed\ncharacter sequence located at a given index."},{"kind":"func","name":"rangeOfComposedCharacterSequencesForRange","slug":"rangeOfComposedCharacterSequencesForRange","generic":{},"params":[{"name":"range","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]}],"ret":{"line":"Range<String.Index>","types":["Index","Range","String"]},"note":"","attr":"","line":"func rangeOfComposedCharacterSequencesForRange(range: Range<String.Index>) -> Range<String.Index>","comment":"*[Foundation]* Returns the range in the string of the composed character\nsequences for a given range."},{"kind":"func","name":"rangeOfString","slug":"rangeOfString","generic":{},"params":[{"name":"aString","type":"String","note":"","default":"","types":["String"]},{"name":"mask","type":"NSStringCompareOptions","note":"options","default":"default","types":["NSStringCompareOptions"]},{"name":"searchRange","type":"Range<String.Index>?","note":"range","default":"default","types":["Index","Range","String"]},{"name":"locale","type":"NSLocale?","note":"","default":"default","types":["NSLocale"]}],"ret":{"line":"Range<String.Index>?","types":["Index","Range","String"]},"note":"","attr":"","line":"func rangeOfString(aString: String, options mask: NSStringCompareOptions = default, range searchRange: Range<String.Index>? = default, locale: NSLocale? = default) -> Range<String.Index>?","comment":"*[Foundation]* Finds and returns the range of the first occurrence of a\ngiven string within a given range of the `String`, subject to\ngiven options, using the specified locale, if any."},{"kind":"func","name":"stringByAddingPercentEncodingWithAllowedCharacters","slug":"stringByAddingPercentEncodingWithAllowedCharacters","generic":{},"params":[{"name":"allowedCharacters","type":"NSCharacterSet","note":"","default":"","types":["NSCharacterSet"]}],"ret":{"line":"String?","types":["String"]},"note":"","attr":"","line":"func stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacters: NSCharacterSet) -> String?","comment":"*[Foundation]* Returns a new string made from the `String` by replacing\nall characters not in the specified set with percent encoded\ncharacters."},{"kind":"func","name":"stringByAddingPercentEscapesUsingEncoding","slug":"stringByAddingPercentEscapesUsingEncoding","generic":{},"params":[{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]}],"ret":{"line":"String?","types":["String"]},"note":"","attr":"","line":"func stringByAddingPercentEscapesUsingEncoding(encoding: NSStringEncoding) -> String?","comment":"*[Foundation]* Returns a representation of the `String` using a given\nencoding to determine the percent escapes necessary to convert\nthe `String` into a legal URL string."},{"kind":"func","name":"stringByAppendingFormat","slug":"stringByAppendingFormat","generic":{},"params":[{"name":"format","type":"String","note":"","default":"","types":["String"]},{"name":"arguments","type":"CVarArgType...","note":"_","default":"","types":["CVarArgType"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func stringByAppendingFormat(format: String, _ arguments: CVarArgType...) -> String","comment":"*[Foundation]* Returns a string made by appending to the `String` a\nstring constructed from a given format string and the following\narguments."},{"kind":"func","name":"stringByAppendingPathComponent","slug":"stringByAppendingPathComponent","generic":{},"params":[{"name":"aString","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func stringByAppendingPathComponent(aString: String) -> String","comment":"*[Foundation]* Returns a new string made by appending to the `String` a given string."},{"kind":"func","name":"stringByAppendingPathExtension","slug":"stringByAppendingPathExtension","generic":{},"params":[{"name":"ext","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"String?","types":["String"]},"note":"","attr":"","line":"func stringByAppendingPathExtension(ext: String) -> String?","comment":"*[Foundation]* Returns a new string made by appending to the `String` an\nextension separator followed by a given extension."},{"kind":"func","name":"stringByAppendingString","slug":"stringByAppendingString","generic":{},"params":[{"name":"aString","type":"String","note":"","default":"","types":["String"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func stringByAppendingString(aString: String) -> String","comment":"*[Foundation]* Returns a new string made by appending a given string to\nthe `String`."},{"kind":"func","name":"stringByFoldingWithOptions","slug":"stringByFoldingWithOptions","generic":{},"params":[{"name":"options","type":"NSStringCompareOptions","note":"","default":"","types":["NSStringCompareOptions"]},{"name":"locale","type":"NSLocale","note":"","default":"","types":["NSLocale"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func stringByFoldingWithOptions(options: NSStringCompareOptions, locale: NSLocale) -> String","comment":"*[Foundation]* Returns a string with the given character folding options\napplied."},{"kind":"func","name":"stringByPaddingToLength","slug":"stringByPaddingToLength","generic":{},"params":[{"name":"newLength","type":"Int","note":"","default":"","types":["Int"]},{"name":"padString","type":"String","note":"withString","default":"","types":["String"]},{"name":"padIndex","type":"Int","note":"startingAtIndex","default":"","types":["Int"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func stringByPaddingToLength(newLength: Int, withString padString: String, startingAtIndex padIndex: Int) -> String","comment":"*[Foundation]* Returns a new string formed from the `String` by either\nremoving characters from the end, or by appending as many\noccurrences as necessary of a given pad string."},{"kind":"func","name":"stringByReplacingCharactersInRange","slug":"stringByReplacingCharactersInRange","generic":{},"params":[{"name":"range","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]},{"name":"replacement","type":"String","note":"withString","default":"","types":["String"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func stringByReplacingCharactersInRange(range: Range<String.Index>, withString replacement: String) -> String","comment":"*[Foundation]* Returns a new string in which the characters in a\nspecified range of the `String` are replaced by a given string."},{"kind":"func","name":"stringByReplacingOccurrencesOfString","slug":"stringByReplacingOccurrencesOfString","generic":{},"params":[{"name":"target","type":"String","note":"","default":"","types":["String"]},{"name":"replacement","type":"String","note":"withString","default":"","types":["String"]},{"name":"options","type":"NSStringCompareOptions","note":"","default":"default","types":["NSStringCompareOptions"]},{"name":"searchRange","type":"Range<String.Index>?","note":"range","default":"default","types":["Index","Range","String"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func stringByReplacingOccurrencesOfString(target: String, withString replacement: String, options: NSStringCompareOptions = default, range searchRange: Range<String.Index>? = default) -> String","comment":"*[Foundation]* Returns a new string in which all occurrences of a target\nstring in a specified range of the `String` are replaced by\nanother given string."},{"kind":"func","name":"stringByReplacingPercentEscapesUsingEncoding","slug":"stringByReplacingPercentEscapesUsingEncoding","generic":{},"params":[{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]}],"ret":{"line":"String?","types":["String"]},"note":"","attr":"","line":"func stringByReplacingPercentEscapesUsingEncoding(encoding: NSStringEncoding) -> String?","comment":"*[Foundation]* Returns a new string made by replacing in the `String`\nall percent escapes with the matching characters as determined\nby a given encoding."},{"kind":"func","name":"stringByTrimmingCharactersInSet","slug":"stringByTrimmingCharactersInSet","generic":{},"params":[{"name":"set","type":"NSCharacterSet","note":"","default":"","types":["NSCharacterSet"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func stringByTrimmingCharactersInSet(set: NSCharacterSet) -> String","comment":"*[Foundation]* Returns a new string made by removing from both ends of\nthe `String` characters contained in a given character set."},{"kind":"func","name":"stringsByAppendingPaths","slug":"stringsByAppendingPaths","generic":{},"params":[{"name":"paths","type":"[String]","note":"","default":"","types":["String"]}],"ret":{"line":"[String]","types":["String"]},"note":"","attr":"","line":"func stringsByAppendingPaths(paths: [String]) -> [String]","comment":"*[Foundation]* Returns an array of strings made by separately appending\nto the `String` each string in in a given array."},{"kind":"func","name":"substringFromIndex","slug":"substringFromIndex","generic":{},"params":[{"name":"index","type":"String.Index","note":"","default":"","types":["Index","String"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func substringFromIndex(index: String.Index) -> String","comment":"*[Foundation]* Returns a new string containing the characters of the\n`String` from the one at a given index to the end."},{"kind":"func","name":"substringToIndex","slug":"substringToIndex","generic":{},"params":[{"name":"index","type":"String.Index","note":"","default":"","types":["Index","String"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func substringToIndex(index: String.Index) -> String","comment":"*[Foundation]* Returns a new string containing the characters of the\n`String` up to, but not including, the one at a given index."},{"kind":"func","name":"substringWithRange","slug":"substringWithRange","generic":{},"params":[{"name":"aRange","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func substringWithRange(aRange: Range<String.Index>) -> String","comment":"*[Foundation]* Returns a string object containing the characters of the\n`String` that lie within a given range."},{"kind":"func","name":"uppercaseStringWithLocale","slug":"uppercaseStringWithLocale","generic":{},"params":[{"name":"locale","type":"NSLocale","note":"","default":"","types":["NSLocale"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func uppercaseStringWithLocale(locale: NSLocale) -> String","comment":"*[Foundation]* Returns a version of the string with all letters\nconverted to uppercase, taking into account the specified\nlocale."},{"kind":"func","name":"writeToFile","slug":"writeToFile","generic":{},"params":[{"name":"path","type":"String","note":"","default":"","types":["String"]},{"name":"useAuxiliaryFile","type":"Bool","note":"atomically","default":"","types":["Bool"]},{"name":"enc","type":"NSStringEncoding","note":"encoding","default":"","types":["NSStringEncoding"]},{"name":"error","type":"NSErrorPointer","note":"","default":"default","types":["NSErrorPointer"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func writeToFile(path: String, atomically useAuxiliaryFile: Bool, encoding enc: NSStringEncoding, error: NSErrorPointer = default) -> Bool","comment":"*[Foundation]* Writes the contents of the `String` to a file at a given\npath using a given encoding."},{"kind":"func","name":"writeToURL","slug":"writeToURL","generic":{},"params":[{"name":"url","type":"NSURL","note":"","default":"","types":["NSURL"]},{"name":"useAuxiliaryFile","type":"Bool","note":"atomically","default":"","types":["Bool"]},{"name":"enc","type":"NSStringEncoding","note":"encoding","default":"","types":["NSStringEncoding"]},{"name":"error","type":"NSErrorPointer","note":"","default":"default","types":["NSErrorPointer"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func writeToURL(url: NSURL, atomically useAuxiliaryFile: Bool, encoding enc: NSStringEncoding, error: NSErrorPointer = default) -> Bool","comment":"*[Foundation]* Writes the contents of the `String` to the URL specified\nby url using the specified encoding."}],"types":["String.Index","String.UTF8View","String.UnicodeScalarView","String.UTF16View","String.UTF8View.Index","String.UnicodeScalarView.Index","String.UnicodeScalarView.Generator"],"properties":[{"kind":"var","name":"startIndex","type":"String.Index","readonly":true,"stat":"","subtypes":["Index","String"],"comment":"The position of the first `Character` if the `String` is\nnon-empty; identical to `endIndex` otherwise."},{"kind":"var","name":"endIndex","type":"String.Index","readonly":true,"stat":"","subtypes":["Index","String"],"comment":"The `String`\\ 's \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."},{"kind":"var","name":"utf8","type":"String.UTF8View","readonly":true,"stat":"","subtypes":["String","UTF8View"],"comment":"A UTF-8 encoding of `self`."},{"kind":"var","name":"nulTerminatedUTF8","type":"ContiguousArray<CodeUnit>","readonly":true,"stat":"","subtypes":["CodeUnit","ContiguousArray"],"comment":"A contiguously-stored nul-terminated UTF-8 representation of\n`self`.\n\nTo access the underlying memory, invoke\n`withUnsafeBufferPointer` on the `ContiguousArray`."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"isEmpty","type":"Bool","readonly":true,"stat":"","subtypes":["Bool"],"comment":"`true` iff `self` contains no characters."},{"kind":"var","name":"utf16","type":"String.UTF16View","readonly":true,"stat":"","subtypes":["String","UTF16View"],"comment":"A UTF-16 encoding of `self`."},{"kind":"var","name":"unicodeScalars","type":"String.UnicodeScalarView","readonly":true,"stat":"","subtypes":["String","UnicodeScalarView"],"comment":"The value of `self` as a collection of Unicode scalar values."},{"kind":"var","name":"capitalizedString","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Produce a string with the first character from each word changed\nto the corresponding uppercase value."},{"kind":"var","name":"decomposedStringWithCanonicalMapping","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a string made by normalizing the `String`’s\n \ncontents using Form D."},{"kind":"var","name":"decomposedStringWithCompatibilityMapping","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a string made by normalizing the `String`’s\n \ncontents using Form KD."},{"kind":"var","name":"fastestEncoding","type":"NSStringEncoding","readonly":true,"stat":"","subtypes":["NSStringEncoding"],"comment":"*[Foundation]* Returns the fastest encoding to which the `String` may be\nconverted without loss of information."},{"kind":"var","name":"hash","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"*[Foundation]* An unsigned integer that can be used as a hash table address."},{"kind":"var","name":"lastPathComponent","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns the last path component of the `String`."},{"kind":"var","name":"utf16Count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"*[Foundation]* Returns the number of Unicode characters in the `String`."},{"kind":"var","name":"pathComponents","type":"[String]","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns an array of NSString objects containing, in\norder, each path component of the `String`."},{"kind":"var","name":"pathExtension","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Interprets the `String` as a path and returns the\n`String`’s extension, if any.\n "},{"kind":"var","name":"precomposedStringWithCanonicalMapping","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a string made by normalizing the `String`’s\n \ncontents using Form C."},{"kind":"var","name":"precomposedStringWithCompatibilityMapping","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a string made by normalizing the `String`’s\n \ncontents using Form KC."},{"kind":"var","name":"smallestEncoding","type":"NSStringEncoding","readonly":true,"stat":"","subtypes":["NSStringEncoding"],"comment":"*[Foundation]* Returns the smallest encoding to which the `String` can\nbe converted without loss of information."},{"kind":"var","name":"stringByAbbreviatingWithTildeInPath","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a new string that replaces the current home\ndirectory portion of the current path with a tilde (`~`)\ncharacter."},{"kind":"var","name":"stringByDeletingLastPathComponent","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a new string made by deleting the last path\ncomponent from the `String`, along with any final path\nseparator."},{"kind":"var","name":"stringByDeletingPathExtension","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a new string made by deleting the extension (if\nany, and only the last) from the `String`."},{"kind":"var","name":"stringByExpandingTildeInPath","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a new string made by expanding the initial\ncomponent of the `String` to its full path value."},{"kind":"var","name":"stringByRemovingPercentEncoding","type":"String?","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a new string made from the `String` by replacing\nall percent encoded sequences with the matching UTF-8\ncharacters."},{"kind":"var","name":"stringByResolvingSymlinksInPath","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a new string made from the `String` by resolving\nall symbolic links and standardizing path."},{"kind":"var","name":"stringByStandardizingPath","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* Returns a new string made by removing extraneous path\ncomponents from the `String`."},{"kind":"var","name":"lowercaseString","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* "},{"kind":"var","name":"uppercaseString","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"*[Foundation]* "}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"c","type":"Character","note":"_","default":"","types":["Character"]}],"init":"init","note":"","comment":"Construct an instance containing just the given `Character`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int32","note":"_builtinUnicodeScalarLiteral","default":"","types":["Builtin","Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"String","note":"unicodeScalarLiteral","default":"","types":["String"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"start","type":"Builtin.RawPointer","note":"_builtinExtendedGraphemeClusterLiteral","default":"","types":["Builtin","RawPointer"]},{"name":"byteSize","type":"Builtin.Word","note":"","default":"","types":["Builtin","Word"]},{"name":"isASCII","type":"Builtin.Int1","note":"","default":"","types":["Builtin","Int1"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"String","note":"extendedGraphemeClusterLiteral","default":"","types":["String"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"start","type":"Builtin.RawPointer","note":"_builtinUTF16StringLiteral","default":"","types":["Builtin","RawPointer"]},{"name":"numberOfCodeUnits","type":"Builtin.Word","note":"","default":"","types":["Builtin","Word"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"start","type":"Builtin.RawPointer","note":"_builtinStringLiteral","default":"","types":["Builtin","RawPointer"]},{"name":"byteSize","type":"Builtin.Word","note":"","default":"","types":["Builtin","Word"]},{"name":"isASCII","type":"Builtin.Int1","note":"","default":"","types":["Builtin","Int1"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"String","note":"stringLiteral","default":"","types":["String"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{"line":"S : SequenceType where Character == Character","types":["Character","SequenceType"]},"params":[{"name":"characters","type":"S","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance containing `characters`."},{"kind":"init","generic":{},"params":[{"name":"sz","type":"Int","note":"count","default":"","types":["Int"]},{"name":"c","type":"Character","note":"repeatedValue","default":"","types":["Character"]}],"init":"init","note":"","comment":"Construct an instance that is the concatenation of `sz` copies\nof `repeatedValue`"},{"kind":"init","generic":{},"params":[{"name":"count","type":"Int","note":"","default":"","types":["Int"]},{"name":"c","type":"UnicodeScalar","note":"repeatedValue","default":"","types":["UnicodeScalar"]}],"init":"init","note":"","comment":"Construct an instance that is the concatenation of `sz` copies\nof `Character(repeatedValue)`"},{"kind":"init","generic":{"line":"T : _SignedIntegerType","types":["_SignedIntegerType"]},"params":[{"name":"v","type":"T","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance representing `v` in base 10."},{"kind":"init","generic":{"line":"T : _UnsignedIntegerType","types":["_UnsignedIntegerType"]},"params":[{"name":"v","type":"T","note":"_","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance representing `v` in base 10."},{"kind":"init","generic":{"line":"T : _SignedIntegerType","types":["_SignedIntegerType"]},"params":[{"name":"v","type":"T","note":"_","default":"","types":[]},{"name":"radix","type":"Int","note":"","default":"","types":["Int"]},{"name":"uppercase","type":"Bool","note":"","default":"default","types":["Bool"]}],"init":"init","note":"","comment":"Create an instance representing `v` in the given `radix` (base).\n\nNumerals greater than 9 are represented as roman letters,\nstarting with `a` if `uppercase` is `false` or `A` otherwise."},{"kind":"init","generic":{"line":"T : _UnsignedIntegerType","types":["_UnsignedIntegerType"]},"params":[{"name":"v","type":"T","note":"_","default":"","types":[]},{"name":"radix","type":"Int","note":"","default":"","types":["Int"]},{"name":"uppercase","type":"Bool","note":"","default":"default","types":["Bool"]}],"init":"init","note":"","comment":"Create an instance representing `v` in the given `radix` (base).\n\nNumerals greater than 9 are represented as roman letters,\nstarting with `a` if `uppercase` is `false` or `A` otherwise."},{"kind":"init","generic":{},"params":[{"name":"view","type":"String.UnicodeScalarView","note":"_","default":"","types":["String","UnicodeScalarView"]}],"init":"init","note":"","comment":"Construct an instance given a collection of Unicode scalar\nvalues."},{"kind":"init","generic":{},"params":[{"name":"path","type":"String","note":"contentsOfFile","default":"","types":["String"]},{"name":"enc","type":"NSStringEncoding","note":"encoding","default":"","types":["NSStringEncoding"]},{"name":"error","type":"NSErrorPointer","note":"","default":"default","types":["NSErrorPointer"]}],"init":"init?","note":"","comment":"*[Foundation]* Produces a string created by reading data from the file at a\ngiven path interpreted using a given encoding."},{"kind":"init","generic":{},"params":[{"name":"path","type":"String","note":"contentsOfFile","default":"","types":["String"]},{"name":"usedEncoding","type":"UnsafeMutablePointer<NSStringEncoding>","note":"","default":"default","types":["NSStringEncoding","UnsafeMutablePointer"]},{"name":"error","type":"NSErrorPointer","note":"","default":"default","types":["NSErrorPointer"]}],"init":"init?","note":"","comment":"*[Foundation]* Produces a string created by reading data from the file at\na given path and returns by reference the encoding used to\ninterpret the file."},{"kind":"init","generic":{},"params":[{"name":"url","type":"NSURL","note":"contentsOfURL","default":"","types":["NSURL"]},{"name":"enc","type":"NSStringEncoding","note":"encoding","default":"","types":["NSStringEncoding"]},{"name":"error","type":"NSErrorPointer","note":"","default":"default","types":["NSErrorPointer"]}],"init":"init?","note":"","comment":"*[Foundation]* Produces a string created by reading data from a given URL\ninterpreted using a given encoding.  Errors are written into the\ninout `error` argument."},{"kind":"init","generic":{},"params":[{"name":"url","type":"NSURL","note":"contentsOfURL","default":"","types":["NSURL"]},{"name":"enc","type":"UnsafeMutablePointer<NSStringEncoding>","note":"usedEncoding","default":"default","types":["NSStringEncoding","UnsafeMutablePointer"]},{"name":"error","type":"NSErrorPointer","note":"","default":"default","types":["NSErrorPointer"]}],"init":"init?","note":"","comment":"*[Foundation]* Produces a string created by reading data from a given URL\nand returns by reference the encoding used to interpret the\ndata.  Errors are written into the inout `error` argument."},{"kind":"init","generic":{},"params":[{"name":"CString","type":"UnsafePointer<CChar>","note":"","default":"","types":["CChar","UnsafePointer"]},{"name":"enc","type":"NSStringEncoding","note":"encoding","default":"","types":["NSStringEncoding"]}],"init":"init?","note":"","comment":"*[Foundation]* Produces a string containing the bytes in a given C array,\ninterpreted according to a given encoding."},{"kind":"init","generic":{},"params":[{"name":"bytes","type":"UnsafePointer<CChar>","note":"UTF8String","default":"","types":["CChar","UnsafePointer"]}],"init":"init?","note":"","comment":"*[Foundation]* Produces a string created by copying the data from a given\nC array of UTF8-encoded bytes."},{"kind":"init","generic":{"line":"S : SequenceType where UInt8 == UInt8","types":["SequenceType","UInt8"]},"params":[{"name":"bytes","type":"S","note":"","default":"","types":[]},{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]}],"init":"init?","note":"","comment":"*[Foundation]* Produces an initialized `NSString` object equivalent to the given\n`bytes` interpreted in the given `encoding`."},{"kind":"init","generic":{},"params":[{"name":"bytes","type":"UnsafeMutablePointer<Void>","note":"bytesNoCopy","default":"","types":["UnsafeMutablePointer","Void"]},{"name":"length","type":"Int","note":"","default":"","types":["Int"]},{"name":"encoding","type":"NSStringEncoding","note":"","default":"","types":["NSStringEncoding"]},{"name":"flag","type":"Bool","note":"freeWhenDone","default":"","types":["Bool"]}],"init":"init?","note":"","comment":"*[Foundation]* Produces an initialized `String` object that contains a\ngiven number of bytes from a given buffer of bytes interpreted\nin a given encoding, and optionally frees the buffer.  WARNING:\nthis initializer is not memory-safe!"},{"kind":"init","generic":{},"params":[{"name":"utf16CodeUnits","type":"UnsafePointer<unichar>","note":"","default":"","types":["UnsafePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"*[Foundation]* Returns an initialized `String` object that contains a\ngiven number of characters from a given array of Unicode\ncharacters."},{"kind":"init","generic":{},"params":[{"name":"utf16CodeUnitsNoCopy","type":"UnsafePointer<unichar>","note":"","default":"","types":["UnsafePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]},{"name":"flag","type":"Bool","note":"freeWhenDone","default":"","types":["Bool"]}],"init":"init","note":"","comment":"*[Foundation]* Returns an initialized `String` object that contains a given\nnumber of characters from a given array of UTF-16 Code Units"},{"kind":"init","generic":{},"params":[{"name":"format","type":"String","note":"","default":"","types":["String"]},{"name":"arguments","type":"CVarArgType...","note":"_","default":"","types":["CVarArgType"]}],"init":"init","note":"","comment":"*[Foundation]* Returns a `String` object initialized by using a given\nformat string as a template into which the remaining argument\nvalues are substituted."},{"kind":"init","generic":{},"params":[{"name":"format","type":"String","note":"","default":"","types":["String"]},{"name":"arguments","type":"[CVarArgType]","note":"","default":"","types":["CVarArgType"]}],"init":"init","note":"","comment":"*[Foundation]* Returns a `String` object initialized by using a given\nformat string as a template into which the remaining argument\nvalues are substituted according to the user’s default locale.\n "},{"kind":"init","generic":{},"params":[{"name":"format","type":"String","note":"","default":"","types":["String"]},{"name":"locale","type":"NSLocale?","note":"","default":"","types":["NSLocale"]},{"name":"args","type":"CVarArgType...","note":"_","default":"","types":["CVarArgType"]}],"init":"init","note":"","comment":"*[Foundation]* Returns a `String` object initialized by using a given\nformat string as a template into which the remaining argument\nvalues are substituted according to given locale information."},{"kind":"init","generic":{},"params":[{"name":"format","type":"String","note":"","default":"","types":["String"]},{"name":"locale","type":"NSLocale?","note":"","default":"","types":["NSLocale"]},{"name":"arguments","type":"[CVarArgType]","note":"","default":"","types":["CVarArgType"]}],"init":"init","note":"","comment":"*[Foundation]* Returns a `String` object initialized by using a given\nformat string as a template into which the remaining argument\nvalues are substituted according to given locale information."},{"kind":"init","generic":{},"params":[{"name":"cocoaString","type":"NSString","note":"_","default":"","types":["NSString"]}],"init":"init","note":"","comment":"*[Foundation]* "}],"subscripts":[{"kind":"subscript","params":[{"name":"i","type":"String.Index","note":"","default":"","types":["Index","String"]}],"ret":{"line":"Character { get }","types":["Character"]},"comment":""},{"kind":"subscript","params":[{"name":"subRange","type":"Range<String.Index>","note":"","default":"","types":["Index","Range","String"]}],"ret":{"line":"String { get }","types":["String"]},"comment":""}],"comment":"An arbitrary Unicode string value.\n\nUnicode-Correct\n===============\n\nSwift strings are designed to be Unicode-correct.  In particular,\nthe APIs make it easy to write code that works correctly, and does\nnot surprise end-users, regardless of where you venture in the\nUnicode character space.  For example,\n\n* The `==` operator checks for Unicode canonical equivalence,\n  so two different representations of the same string will always\n  compare equal.\n\n* String elements are `Characters` (Unicode extended grapheme\n  clusters), a unit of text that is meaningful to most humans.\n\nLocale-Insensitive\n==================\n\nThe fundamental operations on Swift strings are not sensitive to\nlocale settings.  That's because, for example, the validity of a\n`Dictionary<String, T>` in a running program depends on a given\nstring comparison having a single, stable result.  Therefore,\nSwift always uses the default, un-tailored Unicode algorithms\nfor basic string operations.\n\nImporting `Foundation` endows swift strings with the full power of\nthe `NSString` API, which allows you to choose more complex\nlocale-sensitive operations explicitly.\n\nValue Semantics\n===============\n\nEach string variable, `let` binding, or stored property has an\nindependent value, so mutations to the string are not observable\nthrough its copies::\n\n  var a = \"foo\"\n  var b = a\n  b[b.endIndex.predecessor()] = \"x\"\n  println(\"a=\\(a), b=\\(b)\")     // a=foo, b=fox\n\nStrings use Copy-on-Write so that their data is only copied\nlazily, upon mutation, when more than one string instance is using\nthe same buffer.  Therefore, the first in any sequence of mutating\noperations may cost `O(N)` time and space, where `N` is the length\nof the string's (unspecified) underlying representation,.\n\nGrowth and Capacity\n===================\n\nWhen a string's contiguous storage fills up, new storage must be\nallocated and characters must be moved to the new storage.\n`String` uses an exponential growth strategy that makes `append` a\nconstant time operation *when amortized over many invocations*.\n\nObjective-C Bridge\n==================\n\n`String` is bridged to Objective-C as `NSString`, and a `String`\nthat originated in Objective-C may store its characters in an\n`NSString`.  Since any arbitrary subclass of `NSSString` can\nbecome a `String`, there are no guarantees about representation or\nefficiency in this case.  Since `NSString` is immutable, it is\njust as though the storage was shared by some copy: the first in\nany sequence of mutating operations causes elements to be copied\ninto unique, contiguous storage which may cost `O(N)` time and\nspace, where `N` is the length of the string representation (or\nmore, if the underlying `NSString` is has unusual performance\ncharacteristics)."},"StringInterpolationConvertible":{"kind":"protocol","name":"StringInterpolationConvertible","slug":"StringInterpolationConvertible","inherits":[],"inherited":["String"],"attr":"","operators":[],"functions":[{"kind":"func","name":"convertFromStringInterpolation","slug":"convertFromStringInterpolation","generic":{},"params":[{"name":"strings","type":"Self...","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"note":"class","attr":"","line":"class func convertFromStringInterpolation(strings: Self...) -> Self","comment":"Create an instance by concatenating the elements of `strings`"},{"kind":"func","name":"convertFromStringInterpolationSegment","slug":"convertFromStringInterpolationSegment","generic":{"line":"T","types":[]},"params":[{"name":"expr","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Self","types":["Self"]},"note":"class","attr":"","line":"class func convertFromStringInterpolationSegment<T>(expr: T) -> Self","comment":"Create an instance containing `expr`\\ 's `print` representation"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"Conforming types can be initialized with string interpolations\ncontaining `\\(`\\ ...\\ `)` clauses."},"StringLiteralConvertible":{"kind":"protocol","name":"StringLiteralConvertible","slug":"StringLiteralConvertible","inherits":["ExtendedGraphemeClusterLiteralConvertible"],"inherited":["StaticString","String"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"StringLiteralType","type":"","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"value","type":"StringLiteralType","note":"stringLiteral","default":"","types":["StringLiteralType"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."}],"subscripts":[],"comment":"Conforming types can be initialized with arbitrary string literals"},"UInt":{"kind":"struct","name":"UInt","slug":"UInt","inherits":["UnsignedIntegerType","Hashable","Printable","RandomAccessIndexType","BitwiseOperationsType","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"UInt","types":["UInt"]},"note":"","attr":"","line":"func successor() -> UInt","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"UInt","types":["UInt"]},"note":"","attr":"","line":"func predecessor() -> UInt","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"UInt","note":"","default":"","types":["UInt"]}],"ret":{"line":"Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: UInt) -> Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"UInt","types":["UInt"]},"note":"","attr":"","line":"func advancedBy(amount: Distance) -> UInt","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"_","default":"","types":["UInt"]}],"ret":{"line":"(UInt, overflow: Bool)","types":["Bool","UInt"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: UInt, _ rhs: UInt) -> (UInt, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"_","default":"","types":["UInt"]}],"ret":{"line":"(UInt, overflow: Bool)","types":["Bool","UInt"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: UInt, _ rhs: UInt) -> (UInt, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"_","default":"","types":["UInt"]}],"ret":{"line":"(UInt, overflow: Bool)","types":["Bool","UInt"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: UInt, _ rhs: UInt) -> (UInt, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"_","default":"","types":["UInt"]}],"ret":{"line":"(UInt, overflow: Bool)","types":["Bool","UInt"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: UInt, _ rhs: UInt) -> (UInt, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\na result and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt","note":"","default":"","types":["UInt"]},{"name":"rhs","type":"UInt","note":"_","default":"","types":["UInt"]}],"ret":{"line":"(UInt, overflow: Bool)","types":["Bool","UInt"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: UInt, _ rhs: UInt) -> (UInt, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\nthe remainder and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toUIntMax","slug":"toUIntMax","generic":{},"params":[],"ret":{"line":"UIntMax","types":["UIntMax"]},"note":"","attr":"","line":"func toUIntMax() -> UIntMax","comment":"Represent this number using Swift's widest native unsigned\ninteger type."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Explicitly convert to `IntMax`, trapping on overflow (except in -Ounchecked builds)."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"value","type":"Builtin.Word","readonly":true,"stat":"","subtypes":["Builtin","Word"],"comment":""},{"kind":"var","name":"bigEndian","type":"UInt","readonly":true,"stat":"","subtypes":["UInt"],"comment":"Returns the big-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"littleEndian","type":"UInt","readonly":true,"stat":"","subtypes":["UInt"],"comment":"Returns the little-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"byteSwapped","type":"UInt","readonly":true,"stat":"","subtypes":["UInt"],"comment":"Returns the current integer with the byte order swapped."},{"kind":"var","name":"max","type":"UInt","readonly":true,"stat":"static","subtypes":["UInt"],"comment":""},{"kind":"var","name":"min","type":"UInt","readonly":true,"stat":"static","subtypes":["UInt"],"comment":""},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"allZeros","type":"UInt","readonly":true,"stat":"static","subtypes":["UInt"],"comment":"The empty bitset of type UInt."}],"aliases":[{"kind":"typealias","name":"Distance","type":"Int","proto":"","comment":"A type that can represent the number of steps between pairs of\nvalues."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt","note":"bigEndian","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Creates an integer from its big-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt","note":"littleEndian","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Creates an integer from its little-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt","note":"integerLiteral","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt64","note":"","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Construct a `UInt` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int64","note":"","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Construct a `UInt` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"Construct a `UInt` having the same memory representation as\nthe `Int` `bitPattern`.  No range or overflow checking\noccurs, and the resulting `UInt` may not have the same numeric\nvalue as `bitPattern`--it is only guaranteed to use the same\npattern of bits."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."}],"subscripts":[],"comment":"A 64-bit unsigned integer value\ntype."},"UInt16":{"kind":"struct","name":"UInt16","slug":"UInt16","inherits":["UnsignedIntegerType","Hashable","Printable","RandomAccessIndexType","BitwiseOperationsType","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"UInt16","types":["UInt16"]},"note":"","attr":"","line":"func successor() -> UInt16","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"UInt16","types":["UInt16"]},"note":"","attr":"","line":"func predecessor() -> UInt16","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"UInt16","note":"","default":"","types":["UInt16"]}],"ret":{"line":"Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: UInt16) -> Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"UInt16","types":["UInt16"]},"note":"","attr":"","line":"func advancedBy(amount: Distance) -> UInt16","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"ret":{"line":"(UInt16, overflow: Bool)","types":["Bool","UInt16"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: UInt16, _ rhs: UInt16) -> (UInt16, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"ret":{"line":"(UInt16, overflow: Bool)","types":["Bool","UInt16"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: UInt16, _ rhs: UInt16) -> (UInt16, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"ret":{"line":"(UInt16, overflow: Bool)","types":["Bool","UInt16"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: UInt16, _ rhs: UInt16) -> (UInt16, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"ret":{"line":"(UInt16, overflow: Bool)","types":["Bool","UInt16"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: UInt16, _ rhs: UInt16) -> (UInt16, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\na result and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt16","note":"","default":"","types":["UInt16"]},{"name":"rhs","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"ret":{"line":"(UInt16, overflow: Bool)","types":["Bool","UInt16"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: UInt16, _ rhs: UInt16) -> (UInt16, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\nthe remainder and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toUIntMax","slug":"toUIntMax","generic":{},"params":[],"ret":{"line":"UIntMax","types":["UIntMax"]},"note":"","attr":"","line":"func toUIntMax() -> UIntMax","comment":"Represent this number using Swift's widest native unsigned\ninteger type."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Explicitly convert to `IntMax`."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"value","type":"Builtin.Int16","readonly":true,"stat":"","subtypes":["Builtin","Int16"],"comment":""},{"kind":"var","name":"bigEndian","type":"UInt16","readonly":true,"stat":"","subtypes":["UInt16"],"comment":"Returns the big-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"littleEndian","type":"UInt16","readonly":true,"stat":"","subtypes":["UInt16"],"comment":"Returns the little-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"byteSwapped","type":"UInt16","readonly":true,"stat":"","subtypes":["UInt16"],"comment":"Returns the current integer with the byte order swapped."},{"kind":"var","name":"max","type":"UInt16","readonly":true,"stat":"static","subtypes":["UInt16"],"comment":""},{"kind":"var","name":"min","type":"UInt16","readonly":true,"stat":"static","subtypes":["UInt16"],"comment":""},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"allZeros","type":"UInt16","readonly":true,"stat":"static","subtypes":["UInt16"],"comment":"The empty bitset of type UInt16."}],"aliases":[{"kind":"typealias","name":"Distance","type":"Int","proto":"","comment":"A type that can represent the number of steps between pairs of\nvalues."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt16","note":"bigEndian","default":"","types":["UInt16"]}],"init":"init","note":"","comment":"Creates an integer from its big-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt16","note":"littleEndian","default":"","types":["UInt16"]}],"init":"init","note":"","comment":"Creates an integer from its little-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt16","note":"integerLiteral","default":"","types":["UInt16"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt32","note":"","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Construct a `UInt16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int32","note":"","default":"","types":["Int32"]}],"init":"init","note":"","comment":"Construct a `UInt16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt64","note":"","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Construct a `UInt16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int64","note":"","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Construct a `UInt16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt","note":"","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Construct a `UInt16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"Construct a `UInt16` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"Int16","note":"","default":"","types":["Int16"]}],"init":"init","note":"","comment":"Construct a `UInt16` having the same memory representation as\nthe `Int16` `bitPattern`.  No range or overflow checking\noccurs, and the resulting `UInt16` may not have the same numeric\nvalue as `bitPattern`--it is only guaranteed to use the same\npattern of bits."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."}],"subscripts":[],"comment":"A 16-bit unsigned integer value\ntype."},"UInt32":{"kind":"struct","name":"UInt32","slug":"UInt32","inherits":["UnsignedIntegerType","Hashable","Printable","RandomAccessIndexType","BitwiseOperationsType","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"UInt32","types":["UInt32"]},"note":"","attr":"","line":"func successor() -> UInt32","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"UInt32","types":["UInt32"]},"note":"","attr":"","line":"func predecessor() -> UInt32","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"UInt32","note":"","default":"","types":["UInt32"]}],"ret":{"line":"Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: UInt32) -> Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"UInt32","types":["UInt32"]},"note":"","attr":"","line":"func advancedBy(amount: Distance) -> UInt32","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"ret":{"line":"(UInt32, overflow: Bool)","types":["Bool","UInt32"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: UInt32, _ rhs: UInt32) -> (UInt32, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"ret":{"line":"(UInt32, overflow: Bool)","types":["Bool","UInt32"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: UInt32, _ rhs: UInt32) -> (UInt32, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"ret":{"line":"(UInt32, overflow: Bool)","types":["Bool","UInt32"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: UInt32, _ rhs: UInt32) -> (UInt32, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"ret":{"line":"(UInt32, overflow: Bool)","types":["Bool","UInt32"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: UInt32, _ rhs: UInt32) -> (UInt32, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\na result and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt32","note":"","default":"","types":["UInt32"]},{"name":"rhs","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"ret":{"line":"(UInt32, overflow: Bool)","types":["Bool","UInt32"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: UInt32, _ rhs: UInt32) -> (UInt32, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\nthe remainder and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toUIntMax","slug":"toUIntMax","generic":{},"params":[],"ret":{"line":"UIntMax","types":["UIntMax"]},"note":"","attr":"","line":"func toUIntMax() -> UIntMax","comment":"Represent this number using Swift's widest native unsigned\ninteger type."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Explicitly convert to `IntMax`."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"value","type":"Builtin.Int32","readonly":true,"stat":"","subtypes":["Builtin","Int32"],"comment":""},{"kind":"var","name":"bigEndian","type":"UInt32","readonly":true,"stat":"","subtypes":["UInt32"],"comment":"Returns the big-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"littleEndian","type":"UInt32","readonly":true,"stat":"","subtypes":["UInt32"],"comment":"Returns the little-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"byteSwapped","type":"UInt32","readonly":true,"stat":"","subtypes":["UInt32"],"comment":"Returns the current integer with the byte order swapped."},{"kind":"var","name":"max","type":"UInt32","readonly":true,"stat":"static","subtypes":["UInt32"],"comment":""},{"kind":"var","name":"min","type":"UInt32","readonly":true,"stat":"static","subtypes":["UInt32"],"comment":""},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"allZeros","type":"UInt32","readonly":true,"stat":"static","subtypes":["UInt32"],"comment":"The empty bitset of type UInt32."}],"aliases":[{"kind":"typealias","name":"Distance","type":"Int","proto":"","comment":"A type that can represent the number of steps between pairs of\nvalues."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt32","note":"bigEndian","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Creates an integer from its big-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt32","note":"littleEndian","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Creates an integer from its little-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt32","note":"integerLiteral","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt64","note":"","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Construct a `UInt32` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int64","note":"","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Construct a `UInt32` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt","note":"","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Construct a `UInt32` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"Construct a `UInt32` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"Int32","note":"","default":"","types":["Int32"]}],"init":"init","note":"","comment":"Construct a `UInt32` having the same memory representation as\nthe `Int32` `bitPattern`.  No range or overflow checking\noccurs, and the resulting `UInt32` may not have the same numeric\nvalue as `bitPattern`--it is only guaranteed to use the same\npattern of bits."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UnicodeScalar","note":"_","default":"","types":["UnicodeScalar"]}],"init":"init","note":"","comment":"Construct with value `v.value`.\n\nRequires: `v.value` can be represented as UInt32."}],"subscripts":[],"comment":"A 32-bit unsigned integer value\ntype."},"UInt64":{"kind":"struct","name":"UInt64","slug":"UInt64","inherits":["UnsignedIntegerType","Hashable","Printable","RandomAccessIndexType","BitwiseOperationsType","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"UInt64","types":["UInt64"]},"note":"","attr":"","line":"func successor() -> UInt64","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"UInt64","types":["UInt64"]},"note":"","attr":"","line":"func predecessor() -> UInt64","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"UInt64","note":"","default":"","types":["UInt64"]}],"ret":{"line":"Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: UInt64) -> Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"UInt64","types":["UInt64"]},"note":"","attr":"","line":"func advancedBy(amount: Distance) -> UInt64","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"ret":{"line":"(UInt64, overflow: Bool)","types":["Bool","UInt64"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: UInt64, _ rhs: UInt64) -> (UInt64, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"ret":{"line":"(UInt64, overflow: Bool)","types":["Bool","UInt64"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: UInt64, _ rhs: UInt64) -> (UInt64, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"ret":{"line":"(UInt64, overflow: Bool)","types":["Bool","UInt64"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: UInt64, _ rhs: UInt64) -> (UInt64, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"ret":{"line":"(UInt64, overflow: Bool)","types":["Bool","UInt64"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: UInt64, _ rhs: UInt64) -> (UInt64, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\na result and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt64","note":"","default":"","types":["UInt64"]},{"name":"rhs","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"ret":{"line":"(UInt64, overflow: Bool)","types":["Bool","UInt64"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: UInt64, _ rhs: UInt64) -> (UInt64, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\nthe remainder and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toUIntMax","slug":"toUIntMax","generic":{},"params":[],"ret":{"line":"UIntMax","types":["UIntMax"]},"note":"","attr":"","line":"func toUIntMax() -> UIntMax","comment":"Represent this number using Swift's widest native unsigned\ninteger type."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Explicitly convert to `IntMax`, trapping on overflow (except in -Ounchecked builds)."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"value","type":"Builtin.Int64","readonly":true,"stat":"","subtypes":["Builtin","Int64"],"comment":""},{"kind":"var","name":"bigEndian","type":"UInt64","readonly":true,"stat":"","subtypes":["UInt64"],"comment":"Returns the big-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"littleEndian","type":"UInt64","readonly":true,"stat":"","subtypes":["UInt64"],"comment":"Returns the little-endian representation of the integer, changing the\nbyte order if necessary."},{"kind":"var","name":"byteSwapped","type":"UInt64","readonly":true,"stat":"","subtypes":["UInt64"],"comment":"Returns the current integer with the byte order swapped."},{"kind":"var","name":"max","type":"UInt64","readonly":true,"stat":"static","subtypes":["UInt64"],"comment":""},{"kind":"var","name":"min","type":"UInt64","readonly":true,"stat":"static","subtypes":["UInt64"],"comment":""},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"allZeros","type":"UInt64","readonly":true,"stat":"static","subtypes":["UInt64"],"comment":"The empty bitset of type UInt64."}],"aliases":[{"kind":"typealias","name":"Distance","type":"Int","proto":"","comment":"A type that can represent the number of steps between pairs of\nvalues."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt64","note":"bigEndian","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Creates an integer from its big-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt64","note":"littleEndian","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Creates an integer from its little-endian representation, changing the\nbyte order if necessary."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt64","note":"integerLiteral","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"Int64","note":"","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Construct a `UInt64` having the same memory representation as\nthe `Int64` `bitPattern`.  No range or overflow checking\noccurs, and the resulting `UInt64` may not have the same numeric\nvalue as `bitPattern`--it is only guaranteed to use the same\npattern of bits."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UnicodeScalar","note":"_","default":"","types":["UnicodeScalar"]}],"init":"init","note":"","comment":"Construct with value `v.value`.\n\nRequires: `v.value` can be represented as UInt64."}],"subscripts":[],"comment":"A 64-bit unsigned integer value\ntype."},"UInt8":{"kind":"struct","name":"UInt8","slug":"UInt8","inherits":["UnsignedIntegerType","Hashable","Printable","RandomAccessIndexType","BitwiseOperationsType","Reflectable","CVarArgType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"UInt8","types":["UInt8"]},"note":"","attr":"","line":"func successor() -> UInt8","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"UInt8","types":["UInt8"]},"note":"","attr":"","line":"func predecessor() -> UInt8","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"UInt8","note":"","default":"","types":["UInt8"]}],"ret":{"line":"Distance","types":["Distance"]},"note":"","attr":"","line":"func distanceTo(other: UInt8) -> Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"amount","type":"Distance","note":"","default":"","types":["Distance"]}],"ret":{"line":"UInt8","types":["UInt8"]},"note":"","attr":"","line":"func advancedBy(amount: Distance) -> UInt8","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"ret":{"line":"(UInt8, overflow: Bool)","types":["Bool","UInt8"]},"note":"static","attr":"","line":"static func addWithOverflow(lhs: UInt8, _ rhs: UInt8) -> (UInt8, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"ret":{"line":"(UInt8, overflow: Bool)","types":["Bool","UInt8"]},"note":"static","attr":"","line":"static func subtractWithOverflow(lhs: UInt8, _ rhs: UInt8) -> (UInt8, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"ret":{"line":"(UInt8, overflow: Bool)","types":["Bool","UInt8"]},"note":"static","attr":"","line":"static func multiplyWithOverflow(lhs: UInt8, _ rhs: UInt8) -> (UInt8, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a\n`Bool` that is true iff the operation caused an arithmetic\noverflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"ret":{"line":"(UInt8, overflow: Bool)","types":["Bool","UInt8"]},"note":"static","attr":"","line":"static func divideWithOverflow(lhs: UInt8, _ rhs: UInt8) -> (UInt8, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\na result and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"UInt8","note":"","default":"","types":["UInt8"]},{"name":"rhs","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"ret":{"line":"(UInt8, overflow: Bool)","types":["Bool","UInt8"]},"note":"static","attr":"","line":"static func remainderWithOverflow(lhs: UInt8, _ rhs: UInt8) -> (UInt8, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning\nthe remainder and a `Bool`\nthat is true iff the operation caused an arithmetic overflow."},{"kind":"func","name":"toUIntMax","slug":"toUIntMax","generic":{},"params":[],"ret":{"line":"UIntMax","types":["UIntMax"]},"note":"","attr":"","line":"func toUIntMax() -> UIntMax","comment":"Represent this number using Swift's widest native unsigned\ninteger type."},{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Explicitly convert to `IntMax`."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"encode","slug":"encode","generic":{},"params":[],"ret":{"line":"[Word]","types":["Word"]},"note":"","attr":"","line":"func encode() -> [Word]","comment":"Transform `self` into a series of machine words that can be\nappropriately interpreted by C varargs"}],"types":[],"properties":[{"kind":"var","name":"value","type":"Builtin.Int8","readonly":true,"stat":"","subtypes":["Builtin","Int8"],"comment":""},{"kind":"var","name":"max","type":"UInt8","readonly":true,"stat":"static","subtypes":["UInt8"],"comment":""},{"kind":"var","name":"min","type":"UInt8","readonly":true,"stat":"static","subtypes":["UInt8"],"comment":""},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"allZeros","type":"UInt8","readonly":true,"stat":"static","subtypes":["UInt8"],"comment":"The empty bitset of type UInt8."}],"aliases":[{"kind":"typealias","name":"Distance","type":"Int","proto":"","comment":"A type that can represent the number of steps between pairs of\nvalues."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an instance initialized to zero."},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int2048","note":"_builtinIntegerLiteral","default":"","types":["Builtin","Int2048"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"UInt8","note":"integerLiteral","default":"","types":["UInt8"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int8","note":"_","default":"","types":["Int8"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt16","note":"","default":"","types":["UInt16"]}],"init":"init","note":"","comment":"Construct a `UInt8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int16","note":"_","default":"","types":["Int16"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int16","note":"","default":"","types":["Int16"]}],"init":"init","note":"","comment":"Construct a `UInt8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt32","note":"","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Construct a `UInt8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int32","note":"_","default":"","types":["Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int32","note":"","default":"","types":["Int32"]}],"init":"init","note":"","comment":"Construct a `UInt8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt64","note":"_","default":"","types":["UInt64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt64","note":"","default":"","types":["UInt64"]}],"init":"init","note":"","comment":"Construct a `UInt8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int64","note":"_","default":"","types":["Int64"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int64","note":"","default":"","types":["Int64"]}],"init":"init","note":"","comment":"Construct a `UInt8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt","note":"_","default":"","types":["UInt"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"UInt","note":"","default":"","types":["UInt"]}],"init":"init","note":"","comment":"Construct a `UInt8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"truncatingBitPattern","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"Construct a `UInt8` having the same bitwise representation as\nthe least significant bits of the provided bit pattern.\n\nNo range or overflow checking occurs."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"Int8","note":"","default":"","types":["Int8"]}],"init":"init","note":"","comment":"Construct a `UInt8` having the same memory representation as\nthe `Int8` `bitPattern`.  No range or overflow checking\noccurs, and the resulting `UInt8` may not have the same numeric\nvalue as `bitPattern`--it is only guaranteed to use the same\npattern of bits."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float","note":"_","default":"","types":["Float"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Double","note":"_","default":"","types":["Double"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"other","type":"Float80","note":"_","default":"","types":["Float80"]}],"init":"init","note":"","comment":"Construct an instance that approximates `other`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UnicodeScalar","note":"_","default":"","types":["UnicodeScalar"]}],"init":"init","note":"","comment":"Construct with value `v.value`.\n\nRequires: `v.value` can be represented as UInt8."}],"subscripts":[],"comment":"A 8-bit unsigned integer value\ntype."},"UTF16":{"kind":"struct","name":"UTF16","slug":"UTF16","inherits":["UnicodeCodecType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"decode","slug":"decode","generic":{"line":"G : GeneratorType where CodeUnit == CodeUnit","types":["CodeUnit","GeneratorType"]},"params":[{"name":"input","type":"G","note":"inout","default":"","types":[]}],"ret":{"line":"UnicodeDecodingResult","types":["UnicodeDecodingResult"]},"note":"mutating","attr":"","line":"mutating func decode<G : GeneratorType where CodeUnit == CodeUnit>(inout input: G) -> UnicodeDecodingResult","comment":"Start or continue decoding a UTF sequence.\n\nIn order to decode a code unit sequence completely, this function should\nbe called repeatedly until it returns `UnicodeDecodingResult.EmptyInput`.\nChecking that the generator was exhausted is not sufficient.  The decoder\ncan have an internal buffer that is pre-filled with data from the input\ngenerator.\n\nBecause of buffering, it is impossible to find the corresponing position\nin the generator for a given returned `UnicodeScalar` or an error.\n\n:param: `next`: a *generator* of code units to be decoded."},{"kind":"func","name":"encode","slug":"encode","generic":{"line":"S : SinkType where CodeUnit == CodeUnit","types":["CodeUnit","SinkType"]},"params":[{"name":"input","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]},{"name":"output","type":"S","note":"inout","default":"","types":[]}],"ret":{},"note":"static","attr":"","line":"static func encode<S : SinkType where CodeUnit == CodeUnit>(input: UnicodeScalar, inout output: S)","comment":"Encode a `UnicodeScalar` as a series of `CodeUnit`\\ s by `put`\\\n'ing each `CodeUnit` to `output`."},{"kind":"func","name":"width","slug":"width","generic":{},"params":[{"name":"x","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]}],"ret":{"line":"Int","types":["Int"]},"note":"static","attr":"","line":"static func width(x: UnicodeScalar) -> Int","comment":"Return the number of code units required to encode `x`."},{"kind":"func","name":"leadSurrogate","slug":"leadSurrogate","generic":{},"params":[{"name":"x","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]}],"ret":{"line":"CodeUnit","types":["CodeUnit"]},"note":"static","attr":"","line":"static func leadSurrogate(x: UnicodeScalar) -> CodeUnit","comment":"Return the high surrogate code unit of a surrogate pair\nrepresenting `x`.\n\nRequires: `width(x) == 2`"},{"kind":"func","name":"trailSurrogate","slug":"trailSurrogate","generic":{},"params":[{"name":"x","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]}],"ret":{"line":"CodeUnit","types":["CodeUnit"]},"note":"static","attr":"","line":"static func trailSurrogate(x: UnicodeScalar) -> CodeUnit","comment":"Return the low surrogate code unit of a surrogate pair\nrepresenting `x`.\n\nRequires: `width(x) == 2`"},{"kind":"func","name":"measure","slug":"measure","generic":{"line":"Encoding : UnicodeCodecType, Input : GeneratorType where Encoding.CodeUnit == Encoding.CodeUnit","types":["CodeUnit","Encoding","GeneratorType","Input","UnicodeCodecType"]},"params":[{"name":"_","type":"Encoding.Type","note":"","default":"","types":["Encoding","Type"]},{"name":"input","type":"Input","note":"","default":"","types":["Input"]},{"name":"repairIllFormedSequences","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"(Int, Bool)?","types":["Bool","Int"]},"note":"static","attr":"","line":"static func measure<Encoding : UnicodeCodecType, Input : GeneratorType where Encoding.CodeUnit == Encoding.CodeUnit>(_: Encoding.Type, input: Input, repairIllFormedSequences: Bool) -> (Int, Bool)?","comment":"Returns the number of UTF-16 code units required for the given code unit\nsequence when transcoded to UTF-16, and a bit describing if the sequence\nwas found to contain only ASCII characters.\n\nIf `repairIllFormedSequences` is `true`, the function always succeeds.\nIf it is `false`, `nil` is returned if an ill-formed code unit sequence is\nfound in `input`."}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"CodeUnit","type":"UInt16","proto":"","comment":"A type that can hold code unit values for this\nencoding."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":""}],"subscripts":[],"comment":"A codec for UTF-16."},"UTF32":{"kind":"struct","name":"UTF32","slug":"UTF32","inherits":["UnicodeCodecType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"decode","slug":"decode","generic":{"line":"G : GeneratorType where CodeUnit == CodeUnit","types":["CodeUnit","GeneratorType"]},"params":[{"name":"input","type":"G","note":"inout","default":"","types":[]}],"ret":{"line":"UnicodeDecodingResult","types":["UnicodeDecodingResult"]},"note":"mutating","attr":"","line":"mutating func decode<G : GeneratorType where CodeUnit == CodeUnit>(inout input: G) -> UnicodeDecodingResult","comment":"Start or continue decoding a UTF sequence.\n\nIn order to decode a code unit sequence completely, this function should\nbe called repeatedly until it returns `UnicodeDecodingResult.EmptyInput`.\nChecking that the generator was exhausted is not sufficient.  The decoder\ncan have an internal buffer that is pre-filled with data from the input\ngenerator.\n\nBecause of buffering, it is impossible to find the corresponing position\nin the generator for a given returned `UnicodeScalar` or an error.\n\n:param: `next`: a *generator* of code units to be decoded."},{"kind":"func","name":"encode","slug":"encode","generic":{"line":"S : SinkType where CodeUnit == CodeUnit","types":["CodeUnit","SinkType"]},"params":[{"name":"input","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]},{"name":"output","type":"S","note":"inout","default":"","types":[]}],"ret":{},"note":"static","attr":"","line":"static func encode<S : SinkType where CodeUnit == CodeUnit>(input: UnicodeScalar, inout output: S)","comment":"Encode a `UnicodeScalar` as a series of `CodeUnit`\\ s by `put`\\\n'ing each `CodeUnit` to `output`."}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"CodeUnit","type":"UInt32","proto":"","comment":"A type that can hold code unit values for this\nencoding."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":""}],"subscripts":[],"comment":"A codec for UTF-32."},"UTF8":{"kind":"struct","name":"UTF8","slug":"UTF8","inherits":["UnicodeCodecType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"decode","slug":"decode","generic":{"line":"G : GeneratorType where CodeUnit == CodeUnit","types":["CodeUnit","GeneratorType"]},"params":[{"name":"next","type":"G","note":"inout","default":"","types":[]}],"ret":{"line":"UnicodeDecodingResult","types":["UnicodeDecodingResult"]},"note":"mutating","attr":"","line":"mutating func decode<G : GeneratorType where CodeUnit == CodeUnit>(inout next: G) -> UnicodeDecodingResult","comment":"Start or continue decoding a UTF sequence.\n\nIn order to decode a code unit sequence completely, this function should\nbe called repeatedly until it returns `UnicodeDecodingResult.EmptyInput`.\nChecking that the generator was exhausted is not sufficient.  The decoder\ncan have an internal buffer that is pre-filled with data from the input\ngenerator.\n\nBecause of buffering, it is impossible to find the corresponing position\nin the generator for a given returned `UnicodeScalar` or an error.\n\n:param: `next`: a *generator* of code units to be decoded."},{"kind":"func","name":"encode","slug":"encode","generic":{"line":"S : SinkType where CodeUnit == CodeUnit","types":["CodeUnit","SinkType"]},"params":[{"name":"input","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]},{"name":"output","type":"S","note":"inout","default":"","types":[]}],"ret":{},"note":"static","attr":"","line":"static func encode<S : SinkType where CodeUnit == CodeUnit>(input: UnicodeScalar, inout output: S)","comment":"Encode a `UnicodeScalar` as a series of `CodeUnit`\\ s by `put`\\\n'ing each `CodeUnit` to `output`."}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"CodeUnit","type":"UInt8","proto":"","comment":"A type that can hold code unit values for this\nencoding."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":""}],"subscripts":[],"comment":"A codec for UTF-8."},"UnicodeCodecType":{"kind":"protocol","name":"UnicodeCodecType","slug":"UnicodeCodecType","inherits":[],"inherited":["UTF16","UTF32","UTF8"],"attr":"","operators":[],"functions":[{"kind":"func","name":"decode","slug":"decode","generic":{"line":"G : GeneratorType where `Self`.CodeUnit == CodeUnit","types":["CodeUnit","GeneratorType","Self"]},"params":[{"name":"next","type":"G","note":"inout","default":"","types":[]}],"ret":{"line":"UnicodeDecodingResult","types":["UnicodeDecodingResult"]},"note":"mutating","attr":"","line":"mutating func decode<G : GeneratorType where `Self`.CodeUnit == CodeUnit>(inout next: G) -> UnicodeDecodingResult","comment":"Start or continue decoding a UTF sequence.\n\nIn order to decode a code unit sequence completely, this function should\nbe called repeatedly until it returns `UnicodeDecodingResult.EmptyInput`.\nChecking that the generator was exhausted is not sufficient.  The decoder\ncan have an internal buffer that is pre-filled with data from the input\ngenerator.\n\nBecause of buffering, it is impossible to find the corresponing position\nin the generator for a given returned `UnicodeScalar` or an error.\n\n:param: `next`: a *generator* of code units to be decoded."},{"kind":"func","name":"encode","slug":"encode","generic":{"line":"S : SinkType where `Self`.CodeUnit == CodeUnit","types":["CodeUnit","Self","SinkType"]},"params":[{"name":"input","type":"UnicodeScalar","note":"","default":"","types":["UnicodeScalar"]},{"name":"output","type":"S","note":"inout","default":"","types":[]}],"ret":{},"note":"class","attr":"","line":"class func encode<S : SinkType where `Self`.CodeUnit == CodeUnit>(input: UnicodeScalar, inout output: S)","comment":"Encode a `UnicodeScalar` as a series of `CodeUnit`\\ s by `put`\\\n'ing each `CodeUnit` to `output`."}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"CodeUnit","type":"","proto":"","comment":"A type that can hold code unit values for this\nencoding."}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":""}],"subscripts":[],"comment":"A Unicode encoding scheme.\n\nConsists of an underlying `CodeUnit` type and functions to\ntranslate between sequences of these code units and Unicode\nscalar values."},"UnicodeDecodingResult":{"kind":"enum","name":"UnicodeDecodingResult","slug":"UnicodeDecodingResult","inherits":[],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"isEmptyInput","slug":"isEmptyInput","generic":{},"params":[],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func isEmptyInput() -> Bool","comment":"Return true if `self` indicates no more unicode scalars are\navailable."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"The result of one Unicode decoding step\n\nA unicode scalar value, an indication that no more unicode scalars\nare available, or an indication of a decoding error.","cases":[{"kind":"case","name":"Result","associated":"(UnicodeScalar)","subtypes":["UnicodeScalar"],"comment":""},{"kind":"case","name":"EmptyInput","associated":"","subtypes":[],"comment":""},{"kind":"case","name":"Error","associated":"","subtypes":[],"comment":""}]},"UnicodeScalar":{"kind":"struct","name":"UnicodeScalar","slug":"UnicodeScalar","inherits":["UnicodeScalarLiteralConvertible","Reflectable","Streamable","Printable","DebugPrintable","Hashable","Comparable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"escape","slug":"escape","generic":{},"params":[{"name":"#asASCII","type":"Bool","note":"","default":"","types":["Bool"]}],"ret":{"line":"String","types":["String"]},"note":"","attr":"","line":"func escape(#asASCII: Bool) -> String","comment":"Return a String representation of `self` .\n\n:param: `asASCII`, if `true`, forces most values into a numeric\nrepresentation."},{"kind":"func","name":"isASCII","slug":"isASCII","generic":{},"params":[],"ret":{"line":"Bool","types":["Bool"]},"note":"","attr":"","line":"func isASCII() -> Bool","comment":"Returns true if this is an ASCII character (code point 0 to 127\ninclusive)."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"writeTo","slug":"writeTo","generic":{"line":"Target : OutputStreamType","types":["OutputStreamType","Target"]},"params":[{"name":"target","type":"Target","note":"inout","default":"","types":["Target"]}],"ret":{},"note":"","attr":"","line":"func writeTo<Target : OutputStreamType>(inout target: Target)","comment":"Write a textual representation of `self` into `target`"}],"types":[],"properties":[{"kind":"var","name":"value","type":"UInt32","readonly":true,"stat":"","subtypes":["UInt32"],"comment":"A numeric representation of `self`."},{"kind":"var","name":"description","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.Int32","note":"_builtinUnicodeScalarLiteral","default":"","types":["Builtin","Int32"]}],"init":"init","note":"","comment":""},{"kind":"init","generic":{},"params":[{"name":"value","type":"UnicodeScalar","note":"unicodeScalarLiteral","default":"","types":["UnicodeScalar"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."},{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Creates an instance of the NUL scalar value."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt32","note":"_","default":"","types":["UInt32"]}],"init":"init","note":"","comment":"Create an instance with numeric value `v`.\n\nRequires: `v` is a valid Unicode scalar value."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt16","note":"_","default":"","types":["UInt16"]}],"init":"init","note":"","comment":"Create an instance with numeric value `v`.\n\nRequires: `v` is a valid Unicode scalar value."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UInt8","note":"_","default":"","types":["UInt8"]}],"init":"init","note":"","comment":"Create an instance with numeric value `v`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"UnicodeScalar","note":"_","default":"","types":["UnicodeScalar"]}],"init":"init","note":"","comment":"Create a duplicate of `v`."},{"kind":"init","generic":{},"params":[{"name":"v","type":"Int","note":"_","default":"","types":["Int"]}],"init":"init","note":"","comment":"Construct with value `v`.\n\nRequires: `v` is a valid unicode scalar value."}],"subscripts":[],"comment":"A Unicode scalar value."},"UnicodeScalarLiteralConvertible":{"kind":"protocol","name":"UnicodeScalarLiteralConvertible","slug":"UnicodeScalarLiteralConvertible","inherits":[],"inherited":["ExtendedGraphemeClusterLiteralConvertible","StaticString","String","UnicodeScalar"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"UnicodeScalarLiteralType","type":"","proto":"","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"value","type":"UnicodeScalarLiteralType","note":"unicodeScalarLiteral","default":"","types":["UnicodeScalarLiteralType"]}],"init":"init","note":"","comment":"Create an instance initialized to `value`."}],"subscripts":[],"comment":"Conforming types can be initialized with string literals\ncontaining a single Unicode scalar value."},"Unmanaged":{"kind":"struct","name":"Unmanaged","slug":"Unmanaged","inherits":[],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"fromOpaque","slug":"fromOpaque","generic":{},"params":[{"name":"value","type":"COpaquePointer","note":"","default":"","types":["COpaquePointer"]}],"ret":{"line":"Unmanaged<T>","types":["Unmanaged"]},"note":"static","attr":"","line":"static func fromOpaque(value: COpaquePointer) -> Unmanaged<T>","comment":"Unsafely turn an opaque C pointer into an unmanaged\nclass reference.\n\nThis operation does not change reference counts.\n\n::\n\n  let str: CFString = Unmanaged.fromOpaque(ptr).takeUnretainedValue()"},{"kind":"func","name":"toOpaque","slug":"toOpaque","generic":{},"params":[],"ret":{"line":"COpaquePointer","types":["COpaquePointer"]},"note":"","attr":"","line":"func toOpaque() -> COpaquePointer","comment":"Unsafely turn an unmanaged class reference into an opaque\nC pointer.\n\nThis operation does not change reference counts.\n\n::\n\n  let str: CFString = Unmanaged.fromOpaque(ptr).takeUnretainedValue()"},{"kind":"func","name":"passRetained","slug":"passRetained","generic":{},"params":[{"name":"value","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Unmanaged<T>","types":["Unmanaged"]},"note":"static","attr":"","line":"static func passRetained(value: T) -> Unmanaged<T>","comment":"Create an unmanaged reference with an unbalanced retain.\nThe object will leak if nothing eventually balances the retain.\n\nThis is useful when passing an object to an API which Swift\ndoes not know the ownership rules for, but you know that the\nAPI expects you to pass the object at +1."},{"kind":"func","name":"passUnretained","slug":"passUnretained","generic":{},"params":[{"name":"value","type":"T","note":"","default":"","types":[]}],"ret":{"line":"Unmanaged<T>","types":["Unmanaged"]},"note":"static","attr":"","line":"static func passUnretained(value: T) -> Unmanaged<T>","comment":"Create an unmanaged reference without performing an unbalanced\nretain.\n\nThis is useful when passing a reference to an API which Swift\ndoes not know the ownership rules for, but you know that the\nAPI expects you to pass the object at +0.\n\n::\n\n  CFArraySetValueAtIndex(.passUnretained(array), i,\n                         .passUnretained(object))"},{"kind":"func","name":"takeUnretainedValue","slug":"takeUnretainedValue","generic":{},"params":[],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func takeUnretainedValue() -> T","comment":"Get the value of this unmanaged reference as a managed\nreference without consuming an unbalanced retain of it.\n\nThis is useful when a function returns an unmanaged reference\nand you know that you're not responsible for releasing the result."},{"kind":"func","name":"takeRetainedValue","slug":"takeRetainedValue","generic":{},"params":[],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func takeRetainedValue() -> T","comment":"Get the value of this unmanaged reference as a managed\nreference and consume an unbalanced retain of it.\n\nThis is useful when a function returns an unmanaged reference\nand you know that you're responsible for releasing the result."},{"kind":"func","name":"retain","slug":"retain","generic":{},"params":[],"ret":{"line":"Unmanaged<T>","types":["Unmanaged"]},"note":"","attr":"","line":"func retain() -> Unmanaged<T>","comment":"Perform an unbalanced retain of the object."},{"kind":"func","name":"release","slug":"release","generic":{},"params":[],"ret":{},"note":"","attr":"","line":"func release()","comment":"Perform an unbalanced release of the object."},{"kind":"func","name":"autorelease","slug":"autorelease","generic":{},"params":[],"ret":{"line":"Unmanaged<T>","types":["Unmanaged"]},"note":"","attr":"","line":"func autorelease() -> Unmanaged<T>","comment":"Perform an unbalanced autorelease of the object."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A type for propagating an unmanaged object reference.\n\nWhen you use this type, you become partially responsible for\nkeeping the object alive."},"UnsafeBufferPointer":{"kind":"struct","name":"UnsafeBufferPointer","slug":"UnsafeBufferPointer","inherits":["CollectionType","DebugPrintable"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"UnsafeBufferPointerGenerator<T>","types":["UnsafeBufferPointerGenerator"]},"note":"","attr":"","line":"func generate() -> UnsafeBufferPointerGenerator<T>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"Always zero, which is the index of the first element in a\nnon-empty buffer."},{"kind":"var","name":"endIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The \"past the end\" position; always identical to `count`.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."},{"kind":"var","name":"baseAddress","type":"UnsafePointer<T>","readonly":true,"stat":"","subtypes":["UnsafePointer"],"comment":"A pointer to the first element of the buffer"},{"kind":"var","name":"count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The number of elements in the buffer"},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"start","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"Construct an UnsafePointer over the `count` contiguous\n`T` instances beginning at `start`."}],"subscripts":[{"kind":"subscript","params":[{"name":"i","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T { get }","types":[]},"comment":""}],"comment":"A non-owning pointer to buffer of  `T`\\ s stored\ncontiguously in memory, presenting a `Collection` interface to the\nunderlying elements."},"UnsafeBufferPointerGenerator":{"kind":"struct","name":"UnsafeBufferPointerGenerator","slug":"UnsafeBufferPointerGenerator","inherits":["GeneratorType","SequenceType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"T?","types":[]},"note":"mutating","attr":"","line":"mutating func next() -> T?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists."},{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"UnsafeBufferPointerGenerator<T>","types":["UnsafeBufferPointerGenerator"]},"note":"","attr":"","line":"func generate() -> UnsafeBufferPointerGenerator<T>","comment":"`UnsafeBufferPointerGenerator` is also a `SequenceType`, so it\n`generate`\\ 's a copy of itself"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A generator for the elements in the buffer referenced by\n`UnsafeBufferPointer` or `UnsafeMutableBufferPointer`"},"UnsafeMutableBufferPointer":{"kind":"struct","name":"UnsafeMutableBufferPointer","slug":"UnsafeMutableBufferPointer","inherits":["MutableCollectionType","DebugPrintable"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"UnsafeBufferPointerGenerator<T>","types":["UnsafeBufferPointerGenerator"]},"note":"","attr":"","line":"func generate() -> UnsafeBufferPointerGenerator<T>","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"Always zero, which is the index of the first element in a\nnon-empty buffer."},{"kind":"var","name":"endIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The \"past the end\" position; always identical to `count`.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."},{"kind":"var","name":"baseAddress","type":"UnsafeMutablePointer<T>","readonly":true,"stat":"","subtypes":["UnsafeMutablePointer"],"comment":"A pointer to the first element of the buffer"},{"kind":"var","name":"count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The number of elements in the buffer"},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"start","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":"Construct an UnsafeMutablePointer over the `count` contiguous\n`T` instances beginning at `start`."}],"subscripts":[{"kind":"subscript","params":[{"name":"i","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T { get nonmutating set }","types":[]},"comment":""}],"comment":"A non-owning pointer to buffer of mutable `T`\\ s stored\ncontiguously in memory, presenting a `Collection` interface to the\nunderlying elements."},"UnsafeMutablePointer":{"kind":"struct","name":"UnsafeMutablePointer","slug":"UnsafeMutablePointer","inherits":["RandomAccessIndexType","Hashable","NilLiteralConvertible","DebugPrintable","Reflectable","SinkType"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"null","slug":"null","generic":{},"params":[],"ret":{"line":"UnsafeMutablePointer<T>","types":["UnsafeMutablePointer"]},"note":"static","attr":"","line":"static func null() -> UnsafeMutablePointer<T>","comment":"Return a `nil` instance."},{"kind":"func","name":"alloc","slug":"alloc","generic":{},"params":[{"name":"num","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"UnsafeMutablePointer<T>","types":["UnsafeMutablePointer"]},"note":"static","attr":"","line":"static func alloc(num: Int) -> UnsafeMutablePointer<T>","comment":"Allocate memory for `num` objects of type `T`.\n\nPostcondition: the memory is allocated, but not initialized."},{"kind":"func","name":"dealloc","slug":"dealloc","generic":{},"params":[{"name":"num","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"","attr":"","line":"func dealloc(num: Int)","comment":"Deallocate `num` objects.\n\n:param: num number of objects to deallocate.  Should match exactly\nthe value that was passed to `alloc()` (partial deallocations are not\npossible).\n\nPrecondition: the memory is not initialized.\n\nPostcondition: the memory has been deallocated."},{"kind":"func","name":"initialize","slug":"initialize","generic":{},"params":[{"name":"newvalue","type":"T","note":"","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func initialize(newvalue: T)","comment":"Initialize the value the pointer points to, to construct\nan object where there was no object previously stored.\n\nPrecondition: the memory is not initialized.\n\nPostcondition: the memory is initalized; the value should eventually\nbe destroyed or moved from to avoid leaks."},{"kind":"func","name":"move","slug":"move","generic":{},"params":[],"ret":{"line":"T","types":[]},"note":"","attr":"","line":"func move() -> T","comment":"Retrieve the value the pointer points to, moving it away\nfrom the location referenced in memory.\n\nEquivalent to reading `memory` property and calling `destroy()`,\nbut more efficient.\n\nPrecondition: the memory is initialized.\n\nPostcondition: the value has been destroyed and the memory must\nbe initialized before being used again."},{"kind":"func","name":"moveInitializeBackwardFrom","slug":"moveInitializeBackwardFrom","generic":{},"params":[{"name":"source","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"","attr":"","line":"func moveInitializeBackwardFrom(source: UnsafeMutablePointer<T>, count: Int)","comment":"Move count values beginning at source into uninitialized memory,\ntransforming the source values into raw memory, proceeding from\nthe last value to the first.  Use this for copying ranges into\nlater memory that may overlap with the source range.\n\nRequires: either `source` precedes `self` or follows `self + count`."},{"kind":"func","name":"moveAssignFrom","slug":"moveAssignFrom","generic":{},"params":[{"name":"source","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"","attr":"","line":"func moveAssignFrom(source: UnsafeMutablePointer<T>, count: Int)","comment":"Assign from count values beginning at source into initialized\nmemory, transforming the source values into raw memory."},{"kind":"func","name":"assignFrom","slug":"assignFrom","generic":{},"params":[{"name":"source","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"","attr":"","line":"func assignFrom(source: UnsafeMutablePointer<T>, count: Int)","comment":"Assign from `count` values beginning at source into initialized\nmemory, proceeding from the first element to the last."},{"kind":"func","name":"assignBackwardFrom","slug":"assignBackwardFrom","generic":{},"params":[{"name":"source","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"","attr":"","line":"func assignBackwardFrom(source: UnsafeMutablePointer<T>, count: Int)","comment":"Assign from `count` values beginning at `source` into\ninitialized memory, proceeding from the last value to the first.\nUse this for assigning ranges into later memory that may overlap\nwith the source range.\n\nRequires: either `source` precedes `self` or follows `self + count`."},{"kind":"func","name":"moveInitializeFrom","slug":"moveInitializeFrom","generic":{},"params":[{"name":"source","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"","attr":"","line":"func moveInitializeFrom(source: UnsafeMutablePointer<T>, count: Int)","comment":"Move count values beginning at source into raw memory,\ntransforming the source values into raw memory."},{"kind":"func","name":"initializeFrom","slug":"initializeFrom","generic":{},"params":[{"name":"source","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"","attr":"","line":"func initializeFrom(source: UnsafeMutablePointer<T>, count: Int)","comment":"Copy count values beginning at source into raw memory.\n\nPrecondition: the memory is not initialized."},{"kind":"func","name":"initializeFrom","slug":"initializeFrom","generic":{"line":"C : CollectionType where T == T","types":["CollectionType"]},"params":[{"name":"source","type":"C","note":"","default":"","types":[]}],"ret":{},"note":"","attr":"","line":"func initializeFrom<C : CollectionType where T == T>(source: C)","comment":"Copy the elements of `C` into raw memory.\n\nPrecondition: the memory is not initialized."},{"kind":"func","name":"destroy","slug":"destroy","generic":{},"params":[],"ret":{},"note":"","attr":"","line":"func destroy()","comment":"Destroy the object the pointer points to.\n\nPrecondition: the memory is initialized.\n\nPostcondition: the value has been destroyed and the memory must\nbe initialized before being used again."},{"kind":"func","name":"destroy","slug":"destroy","generic":{},"params":[{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"ret":{},"note":"","attr":"","line":"func destroy(count: Int)","comment":"Destroy the `count` objects the pointer points to.\nPrecondition: the memory is initialized.\n\nPostcondition: the value has been destroyed and the memory must\nbe initialized before being used again."},{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"UnsafeMutablePointer<T>","types":["UnsafeMutablePointer"]},"note":"","attr":"","line":"func successor() -> UnsafeMutablePointer<T>","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"UnsafeMutablePointer<T>","types":["UnsafeMutablePointer"]},"note":"","attr":"","line":"func predecessor() -> UnsafeMutablePointer<T>","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"x","type":"UnsafeMutablePointer<T>","note":"","default":"","types":["UnsafeMutablePointer"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func distanceTo(x: UnsafeMutablePointer<T>) -> Int","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"n","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"UnsafeMutablePointer<T>","types":["UnsafeMutablePointer"]},"note":"","attr":"","line":"func advancedBy(n: Int) -> UnsafeMutablePointer<T>","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."},{"kind":"func","name":"put","slug":"put","generic":{},"params":[{"name":"x","type":"T","note":"","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func put(x: T)","comment":""}],"types":[],"properties":[{"kind":"var","name":"memory","type":"T","readonly":false,"stat":"","subtypes":[],"comment":"Access the underlying raw memory, getting and\nsetting values."},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Construct a null pointer."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.RawPointer","note":"_","default":"","types":["Builtin","RawPointer"]}],"init":"init","note":"","comment":"Construct an `UnsafeMutablePointer` from a builtin raw pointer."},{"kind":"init","generic":{},"params":[{"name":"other","type":"COpaquePointer","note":"_","default":"","types":["COpaquePointer"]}],"init":"init","note":"","comment":"Convert from an opaque C pointer to a typed pointer\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"Word","note":"","default":"","types":["Word"]}],"init":"init","note":"","comment":"Construct an `UnsafeMutablePointer` from a given address in memory.\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"UWord","note":"","default":"","types":["UWord"]}],"init":"init","note":"","comment":"Construct an `UnsafeMutablePointer` from a given address in memory.\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{"line":"U","types":[]},"params":[{"name":"from","type":"UnsafeMutablePointer<U>","note":"_","default":"","types":["UnsafeMutablePointer"]}],"init":"init","note":"","comment":"Convert from an UnsafeMutablePointer of a different type.\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{"line":"U","types":[]},"params":[{"name":"from","type":"UnsafePointer<U>","note":"_","default":"","types":["UnsafePointer"]}],"init":"init","note":"","comment":"Convert from a UnsafePointer of a different type.\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{},"params":[{"name":"nilLiteral","type":"()","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance initialized with `nil`."}],"subscripts":[{"kind":"subscript","params":[{"name":"i","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T { get nonmutating set }","types":[]},"comment":""}],"comment":"A pointer to an object of type `T`.  This type provides no automated\nmemory management, and therefore the user must take care to allocate\nand free memory appropriately.\n\nThe pointer can be in one of the following states:\n\n- memory is not allocated (for example, pointer is null, or memory has\nbeen deallocated previously);\n\n- memory is allocated, but value has not been initialized;\n\n- memory is allocated and value is initialized."},"UnsafePointer":{"kind":"struct","name":"UnsafePointer","slug":"UnsafePointer","inherits":["RandomAccessIndexType","Hashable","NilLiteralConvertible","DebugPrintable","Reflectable"],"inherited":[],"generic":{"line":"T","types":[]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"null","slug":"null","generic":{},"params":[],"ret":{"line":"UnsafePointer<T>","types":["UnsafePointer"]},"note":"static","attr":"","line":"static func null() -> UnsafePointer<T>","comment":"Return a `nil` instance."},{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"UnsafePointer<T>","types":["UnsafePointer"]},"note":"","attr":"","line":"func successor() -> UnsafePointer<T>","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"UnsafePointer<T>","types":["UnsafePointer"]},"note":"","attr":"","line":"func predecessor() -> UnsafePointer<T>","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"x","type":"UnsafePointer<T>","note":"","default":"","types":["UnsafePointer"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func distanceTo(x: UnsafePointer<T>) -> Int","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1)."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"n","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"UnsafePointer<T>","types":["UnsafePointer"]},"note":"","attr":"","line":"func advancedBy(n: Int) -> UnsafePointer<T>","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"memory","type":"T","readonly":true,"stat":"","subtypes":[],"comment":"Access the underlying raw memory, getting and\nsetting values."},{"kind":"var","name":"hashValue","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The hash value.\n\n**Axiom:** `x == y` implies `x.hashValue == y.hashValue`\n\n**Note:** the hash value is not guaranteed to be stable across\ndifferent invocations of the same program.  Do not persist the\nhash value across program runs."},{"kind":"var","name":"debugDescription","type":"String","readonly":true,"stat":"","subtypes":["String"],"comment":"A textual representation of `self`, suitable for debugging."}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Construct a null pointer."},{"kind":"init","generic":{},"params":[{"name":"value","type":"Builtin.RawPointer","note":"_","default":"","types":["Builtin","RawPointer"]}],"init":"init","note":"","comment":"Construct an `UnsafePointer` from a builtin raw pointer."},{"kind":"init","generic":{},"params":[{"name":"other","type":"COpaquePointer","note":"_","default":"","types":["COpaquePointer"]}],"init":"init","note":"","comment":"Convert from an opaque C pointer to a typed pointer\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"Word","note":"","default":"","types":["Word"]}],"init":"init","note":"","comment":"Construct an `UnsafePointer` from a given address in memory.\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{},"params":[{"name":"bitPattern","type":"UWord","note":"","default":"","types":["UWord"]}],"init":"init","note":"","comment":"Construct an `UnsafePointer` from a given address in memory.\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{"line":"U","types":[]},"params":[{"name":"from","type":"UnsafeMutablePointer<U>","note":"_","default":"","types":["UnsafeMutablePointer"]}],"init":"init","note":"","comment":"Convert from an UnsafeMutablePointer of a different type.\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{"line":"U","types":[]},"params":[{"name":"from","type":"UnsafePointer<U>","note":"_","default":"","types":["UnsafePointer"]}],"init":"init","note":"","comment":"Convert from a UnsafePointer of a different type.\n\nThis is a fundamentally unsafe conversion."},{"kind":"init","generic":{},"params":[{"name":"nilLiteral","type":"()","note":"","default":"","types":[]}],"init":"init","note":"","comment":"Create an instance initialized with `nil`."}],"subscripts":[{"kind":"subscript","params":[{"name":"i","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"T { get }","types":[]},"comment":""}],"comment":"A pointer to an object of type `T`.  This type provides no automated\nmemory management, and therefore the user must take care to allocate\nand free memory appropriately.\n\nThe pointer can be in one of the following states:\n\n- memory is not allocated (for example, pointer is null, or memory has\nbeen deallocated previously);\n\n- memory is allocated, but value has not been initialized;\n\n- memory is allocated and value is initialized."},"UnsignedIntegerType":{"kind":"protocol","name":"UnsignedIntegerType","slug":"UnsignedIntegerType","inherits":["_UnsignedIntegerType","IntegerType"],"inherited":["UInt","UInt16","UInt32","UInt64","UInt8"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A set of common requirements for Swift's unsigned integer types."},"VaListBuilder":{"kind":"class","name":"VaListBuilder","slug":"VaListBuilder","inherits":[],"inherited":[],"generic":{},"attr":"","note":"final ","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"An object that can manage the lifetime of storage backing a\n`CVaListPointer`"},"Zip2":{"kind":"struct","name":"Zip2","slug":"Zip2","inherits":["SequenceType"],"inherited":[],"generic":{"line":"S0 : SequenceType, S1 : SequenceType","types":["S0","S1","SequenceType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"Generator","types":["Generator"]},"note":"","attr":"","line":"func generate() -> Generator","comment":"Return a *generator* over the elements of this *sequence*.\n\nComplexity: O(1)"}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Stream1","type":"S0.Generator","proto":"","comment":""},{"kind":"typealias","name":"Stream2","type":"S1.Generator","proto":"","comment":""},{"kind":"typealias","name":"Generator","type":"ZipGenerator2<S0.Generator, S1.Generator>","proto":"","comment":"A type whose instances can produce the elements of this\nsequence, in order."}],"inits":[{"kind":"init","generic":{},"params":[{"name":"s0","type":"S0","note":"_","default":"","types":["S0"]},{"name":"s1","type":"S1","note":"_","default":"","types":["S1"]}],"init":"init","note":"","comment":"Construct an instance that makes pairs of elements from `s0` and\n`s1`."}],"subscripts":[],"comment":"A sequence of pairs built out of two underlying sequences, where\nthe elements of the `i`\\ th pair are the `i`\\ th elements of each\nunderlying sequence."},"ZipGenerator2":{"kind":"struct","name":"ZipGenerator2","slug":"ZipGenerator2","inherits":["GeneratorType"],"inherited":[],"generic":{"line":"E0 : GeneratorType, E1 : GeneratorType","types":["E0","E1","GeneratorType"]},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"Element?","types":["Element"]},"note":"mutating","attr":"","line":"mutating func next() -> Element?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: `next()` has not been applied to a copy of `self`\nsince the copy was made, and no preceding call to `self.next()`\nhas returned `nil`."}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Element","type":"(E0.Element, E1.Element)","proto":"","comment":"The type of element returned by `next()`."}],"inits":[{"kind":"init","generic":{},"params":[{"name":"e0","type":"E0","note":"_","default":"","types":["E0"]},{"name":"e1","type":"E1","note":"_","default":"","types":["E1"]}],"init":"init","note":"","comment":"Construct around a pair of underlying generators."}],"subscripts":[],"comment":"A generator for the `Zip2` sequence"},"_ArrayBufferType":{"kind":"protocol","name":"_ArrayBufferType","slug":"_ArrayBufferType","inherits":["MutableCollectionType"],"inherited":[],"attr":"","operators":[],"functions":[{"kind":"func","name":"_uninitializedCopy","slug":"_uninitializedCopy","generic":{},"params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]},{"name":"target","type":"UnsafeMutablePointer<Element>","note":"","default":"","types":["Element","UnsafeMutablePointer"]}],"ret":{"line":"UnsafeMutablePointer<Element>","types":["Element","UnsafeMutablePointer"]},"note":"","attr":"","line":"func _uninitializedCopy(subRange: Range<Int>, target: UnsafeMutablePointer<Element>) -> UnsafeMutablePointer<Element>","comment":"Copy the given subRange of this buffer into uninitialized memory\nstarting at target.  Return a pointer past-the-end of the\njust-initialized memory."},{"kind":"func","name":"_asCocoaArray","slug":"_asCocoaArray","generic":{},"params":[],"ret":{"line":"_SwiftNSArrayRequiredOverridesType","types":["_SwiftNSArrayRequiredOverridesType"]},"note":"","attr":"","line":"func _asCocoaArray() -> _SwiftNSArrayRequiredOverridesType","comment":"Convert to an NSArray.\nPrecondition: _isBridgedToObjectiveC(Element.self)\nO(1) if the element type is bridged verbatim, O(N) otherwise"},{"kind":"func","name":"requestUniqueMutableBackingBuffer","slug":"requestUniqueMutableBackingBuffer","generic":{},"params":[{"name":"minimumCapacity","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"_ContiguousArrayBuffer<Element>?","types":["Element","_ContiguousArrayBuffer"]},"note":"mutating","attr":"","line":"mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Int) -> _ContiguousArrayBuffer<Element>?","comment":"If this buffer is backed by a uniquely-referenced mutable\n_ContiguousArrayBuffer that can be grown in-place to allow the self\nbuffer store minimumCapacity elements, returns that buffer.\nOtherwise, returns nil.  Note: the result's baseAddress may\nnot match ours, if we are a _SliceBuffer.\n\nNote: this function must remain mutating; otherwise the buffer\nmay acquire spurious extra references, which will cause\nunnecessary reallocation."},{"kind":"func","name":"isMutableAndUniquelyReferenced","slug":"isMutableAndUniquelyReferenced","generic":{},"params":[],"ret":{"line":"Bool","types":["Bool"]},"note":"mutating","attr":"","line":"mutating func isMutableAndUniquelyReferenced() -> Bool","comment":"Returns true iff this buffer is backed by a uniquely-referenced mutable\n_ContiguousArrayBuffer.\n\nNote: this function must remain mutating; otherwise the buffer\nmay acquire spurious extra references, which will cause\nunnecessary reallocation."},{"kind":"func","name":"requestNativeBuffer","slug":"requestNativeBuffer","generic":{},"params":[],"ret":{"line":"_ContiguousArrayBuffer<Element>?","types":["Element","_ContiguousArrayBuffer"]},"note":"","attr":"","line":"func requestNativeBuffer() -> _ContiguousArrayBuffer<Element>?","comment":"If this buffer is backed by a _ContiguousArrayBuffer, return it.\nOtherwise, return nil.  Note: the result's baseAddress may\nnot match ours, if we are a _SliceBuffer."},{"kind":"func","name":"replace","slug":"replace","generic":{"line":"C : CollectionType where `Self`.Element == Element","types":["CollectionType","Element","Self"]},"params":[{"name":"#subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]},{"name":"newCount","type":"Int","note":"with","default":"","types":["Int"]},{"name":"newValues","type":"C","note":"elementsOf","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func replace<C : CollectionType where `Self`.Element == Element>(#subRange: Range<Int>, with newCount: Int, elementsOf newValues: C)","comment":"Replace the given subRange with the first newCount elements of\nthe given collection.\n\nRequires: this buffer is backed by a uniquely-referenced\n_ContiguousArrayBuffer"},{"kind":"func","name":"withUnsafeBufferPointer","slug":"withUnsafeBufferPointer","generic":{"line":"R","types":[]},"params":[{"name":"body","type":"(UnsafeBufferPointer<Element>) -> R","note":"","default":"","types":["Element","UnsafeBufferPointer"]}],"ret":{"line":"R","types":[]},"note":"","attr":"","line":"func withUnsafeBufferPointer<R>(body: (UnsafeBufferPointer<Element>) -> R) -> R","comment":"Call `body(p)`, where `p` is an `UnsafeBufferPointer` over the\nunderlying contiguous storage.  If no such storage exists, it is\ncreated on-demand."},{"kind":"func","name":"withUnsafeMutableBufferPointer","slug":"withUnsafeMutableBufferPointer","generic":{"line":"R","types":[]},"params":[{"name":"body","type":"(UnsafeMutableBufferPointer<Element>) -> R","note":"","default":"","types":["Element","UnsafeMutableBufferPointer"]}],"ret":{"line":"R","types":[]},"note":"mutating","attr":"","line":"mutating func withUnsafeMutableBufferPointer<R>(body: (UnsafeMutableBufferPointer<Element>) -> R) -> R","comment":"Call `body(p)`, where `p` is an `UnsafeMutableBufferPointer`\nover the underlying contiguous storage.  Requires: such\ncontiguous storage exists or the buffer is empty"}],"types":[],"properties":[{"kind":"var","name":"count","type":"Int","readonly":false,"stat":"","subtypes":["Int"],"comment":"How many elements the buffer stores"},{"kind":"var","name":"capacity","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"How many elements the buffer can store without reallocation"},{"kind":"var","name":"owner","type":"AnyObject?","readonly":true,"stat":"","subtypes":["AnyObject"],"comment":"An object that keeps the elements stored in this buffer alive"},{"kind":"var","name":"baseAddress","type":"UnsafeMutablePointer<Element>","readonly":true,"stat":"","subtypes":["Element","UnsafeMutablePointer"],"comment":"If the elements are stored contiguously, a pointer to the first\nelement. Otherwise, nil."},{"kind":"var","name":"identity","type":"Word","readonly":true,"stat":"","subtypes":["Word"],"comment":"A value that identifies first mutable element, if any.  Two\narrays compare === iff they are both empty, or if their buffers\nhave the same identity and count."}],"aliases":[{"kind":"typealias","name":"Element","type":"","proto":"","comment":"The type of elements stored in the buffer"}],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"create an empty buffer"},{"kind":"init","generic":{},"params":[{"name":"buffer","type":"_ContiguousArrayBuffer<Element>","note":"_","default":"","types":["Element","_ContiguousArrayBuffer"]}],"init":"init","note":"","comment":"Adopt the storage of x"}],"subscripts":[{"kind":"subscript","params":[{"name":"index","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Element { get nonmutating set }","types":["Element"]},"comment":""},{"kind":"subscript","params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]}],"ret":{"line":"_SliceBuffer<Element> { get }","types":["Element","_SliceBuffer"]},"comment":""}],"comment":"The underlying buffer for an ArrayType conforms to _ArrayBufferType"},"_BidirectionalIndexType":{"kind":"protocol","name":"_BidirectionalIndexType","slug":"_BidirectionalIndexType","inherits":["_ForwardIndexType"],"inherited":["BidirectionalIndexType","_RandomAccessIndexType"],"attr":"","operators":[],"functions":[{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"Self","types":["Self"]},"note":"","attr":"","line":"func predecessor() -> Self","comment":"Return the previous consecutive value in a discrete sequence.\n\nIf `self` has a well-defined successor,\n`self.successor().predecessor() == self`.  If `self` has a\nwell-defined predecessor, `self.predecessor().successor() ==\nself`.\n\nRequires: `self` has a well-defined predecessor."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `BidirectionalIndexType`; do\nnot use it directly.\n\nIts requirements are inherited by `BidirectionalIndexType` and thus must\nbe satisfied by types conforming to that protocol."},"_CocoaStringType":{"kind":"protocol","name":"_CocoaStringType","slug":"_CocoaStringType","inherits":[],"inherited":[],"attr":"@objc ","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"Effectively a proxy for NSString that doesn't mention it by\nname.  NSString's conformance to this protocol is declared in\nFoundation."},"_CollectionType":{"kind":"protocol","name":"_CollectionType","slug":"_CollectionType","inherits":["_SequenceType"],"inherited":["CollectionType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The position of the first element in a non-empty collection.\n\nIdentical to `endIndex` in an empty collection."},{"kind":"var","name":"endIndex","type":"Index","readonly":true,"stat":"","subtypes":["Index"],"comment":"The collection's \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."}],"aliases":[{"kind":"typealias","name":"Index","type":"","proto":"ForwardIndexType","comment":"A type that represents a valid position in the collection.\n\nValid indices consist of the position of every element and a\n\"past the end\" position that's not valid for use as a subscript."},{"kind":"typealias","name":"_Element","type":"","proto":"","comment":""}],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"_i","type":"Index","note":"","default":"","types":["Index"]}],"ret":{"line":"_Element { get }","types":["_Element"]},"comment":""}],"comment":"This protocol is an implementation detail of `CollectionType`; do\nnot use it directly.\n\nIts requirements are inherited by `CollectionType` and thus must\nbe satisfied by types conforming to that protocol."},"_Comparable":{"kind":"protocol","name":"_Comparable","slug":"_Comparable","inherits":[],"inherited":["Comparable"],"attr":"","operators":[],"functions":[{"kind":"operator func","name":"<","slug":"lt","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Bool","types":["Bool"]},"attr":"","line":"func <(lhs: Self, rhs: Self) -> Bool","comment":"A `strict total order\n<http://en.wikipedia.org/wiki/Total_order#Strict_total_order>`_\nover instances of `Self`"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `Comparable`; do\nnot use it directly.\n\nIts requirements are inherited by `Comparable` and thus must\nbe satisfied by types conforming to that protocol."},"_ExtensibleCollectionType":{"kind":"protocol","name":"_ExtensibleCollectionType","slug":"_ExtensibleCollectionType","inherits":["CollectionType"],"inherited":["ExtensibleCollectionType"],"attr":"","operators":[],"functions":[{"kind":"func","name":"reserveCapacity","slug":"reserveCapacity","generic":{},"params":[{"name":"n","type":"Self.Index.Distance","note":"","default":"","types":["Distance","Index","Self"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func reserveCapacity(n: Self.Index.Distance)","comment":"A non-binding request to ensure `n` elements of available storage.\n\nThis works as an optimization to avoid multiple reallocations of\nlinear data structures like `Array`.  Conforming types may\nreserve more than `n`, exactly `n`, less than `n` elements of\nstorage, or even ignore the request completely."},{"kind":"func","name":"append","slug":"append","generic":{},"params":[{"name":"x","type":"Self.Generator.Element","note":"","default":"","types":["Element","Generator","Self"]}],"ret":{},"note":"mutating","attr":"","line":"mutating func append(x: Self.Generator.Element)","comment":"Append `x` to `self`.\n\nApplying `successor()` to the index of the new element yields\n`self.endIndex`.\n\nComplexity: amortized O(1)."},{"kind":"func","name":"extend","slug":"extend","generic":{"line":"S : SequenceType where `Self`.Generator.Element == Self.Generator.Element","types":["Element","Generator","Self","SequenceType"]},"params":[{"name":"newElements","type":"S","note":"","default":"","types":[]}],"ret":{},"note":"mutating","attr":"","line":"mutating func extend<S : SequenceType where `Self`.Generator.Element == Self.Generator.Element>(newElements: S)","comment":"Append the elements of `newElements` to `self`.\n\nComplexity: O(*length of result*) \n\nA possible implementation::\n\n  reserveCapacity(countElements(self) + underestimateCount(newElements))\n  for x in newElements {\n    newElements.append(x)\n  }"}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":"Create an empty instance"}],"subscripts":[],"comment":"This protocol is an implementation detail of `ExtensibleCollectionType`; do\nnot use it directly.\n\nIts requirements are inherited by `ExtensibleCollectionType` and thus must\nbe satisfied by types conforming to that protocol."},"_ForwardIndexType":{"kind":"protocol","name":"_ForwardIndexType","slug":"_ForwardIndexType","inherits":["_Incrementable"],"inherited":["ForwardIndexType","_BidirectionalIndexType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Distance","type":"","proto":"_SignedIntegerType = Int","comment":"A type that can represent the number of steps between pairs of\n`Self` values where one value is reachable from the other.\n\nReachability is defined by the ability to produce one value from\nthe other via zero or more applications of `successor`."},{"kind":"typealias","name":"_DisabledRangeIndex","type":"_DisabledRangeIndex_","proto":"","comment":""}],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `ForwardIndexType`; do\nnot use it directly.\n\nIts requirements are inherited by `ForwardIndexType` and thus must\nbe satisfied by types conforming to that protocol."},"_Incrementable":{"kind":"protocol","name":"_Incrementable","slug":"_Incrementable","inherits":["Equatable"],"inherited":["_ForwardIndexType","_IntegerType"],"attr":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"Self","types":["Self"]},"note":"","attr":"","line":"func successor() -> Self","comment":"Return the next consecutive value in a discrete sequence of\n`Self` values\n\nRequires: `self` has a well-defined successor."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `ForwardIndexType`; do\nnot use it directly.\n\nIts requirements are inherited by `ForwardIndexType` and thus must\nbe satisfied by types conforming to that protocol."},"_IntegerArithmeticType":{"kind":"protocol","name":"_IntegerArithmeticType","slug":"_IntegerArithmeticType","inherits":[],"inherited":["IntegerArithmeticType"],"attr":"","operators":[],"functions":[{"kind":"func","name":"addWithOverflow","slug":"addWithOverflow","generic":{},"params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"_","default":"","types":["Self"]}],"ret":{"line":"(Self, overflow: Bool)","types":["Bool","Self"]},"note":"class","attr":"","line":"class func addWithOverflow(lhs: Self, _ rhs: Self) -> (Self, overflow: Bool)","comment":"Add `lhs` and `rhs`, returning a result and a `Bool` that is\ntrue iff the operation caused an arithmetic overflow."},{"kind":"func","name":"subtractWithOverflow","slug":"subtractWithOverflow","generic":{},"params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"_","default":"","types":["Self"]}],"ret":{"line":"(Self, overflow: Bool)","types":["Bool","Self"]},"note":"class","attr":"","line":"class func subtractWithOverflow(lhs: Self, _ rhs: Self) -> (Self, overflow: Bool)","comment":"Subtract `lhs` and `rhs`, returning a result and a `Bool` that is\ntrue iff the operation caused an arithmetic overflow."},{"kind":"func","name":"multiplyWithOverflow","slug":"multiplyWithOverflow","generic":{},"params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"_","default":"","types":["Self"]}],"ret":{"line":"(Self, overflow: Bool)","types":["Bool","Self"]},"note":"class","attr":"","line":"class func multiplyWithOverflow(lhs: Self, _ rhs: Self) -> (Self, overflow: Bool)","comment":"Multiply `lhs` and `rhs`, returning a result and a `Bool` that is\ntrue iff the operation caused an arithmetic overflow."},{"kind":"func","name":"divideWithOverflow","slug":"divideWithOverflow","generic":{},"params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"_","default":"","types":["Self"]}],"ret":{"line":"(Self, overflow: Bool)","types":["Bool","Self"]},"note":"class","attr":"","line":"class func divideWithOverflow(lhs: Self, _ rhs: Self) -> (Self, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning a result and a `Bool` that is\ntrue iff the operation caused an arithmetic overflow."},{"kind":"func","name":"remainderWithOverflow","slug":"remainderWithOverflow","generic":{},"params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"_","default":"","types":["Self"]}],"ret":{"line":"(Self, overflow: Bool)","types":["Bool","Self"]},"note":"class","attr":"","line":"class func remainderWithOverflow(lhs: Self, _ rhs: Self) -> (Self, overflow: Bool)","comment":"Divide `lhs` and `rhs`, returning the remainder and a `Bool` that is\ntrue iff the operation caused an arithmetic overflow."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `IntegerArithmeticType`; do\nnot use it directly.\n\nIts requirements are inherited by `IntegerArithmeticType` and thus must\nbe satisfied by types conforming to that protocol."},"_IntegerType":{"kind":"protocol","name":"_IntegerType","slug":"_IntegerType","inherits":["IntegerLiteralConvertible","Printable","Hashable","IntegerArithmeticType","BitwiseOperationsType","_Incrementable"],"inherited":["IntegerType","_SignedIntegerType","_UnsignedIntegerType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `IntegerType`; do\nnot use it directly.\n\nIts requirements are inherited by `IntegerType` and thus must\nbe satisfied by types conforming to that protocol."},"_ObjectiveCBridgeable":{"kind":"protocol","name":"_ObjectiveCBridgeable","slug":"_ObjectiveCBridgeable","inherits":[],"inherited":["ImplicitlyUnwrappedOptional","String"],"attr":"","operators":[],"functions":[{"kind":"func","name":"_isBridgedToObjectiveC","slug":"_isBridgedToObjectiveC","generic":{},"params":[],"ret":{"line":"Bool","types":["Bool"]},"note":"class","attr":"","line":"class func _isBridgedToObjectiveC() -> Bool","comment":"Return true iff instances of `Self` can be converted to\nObjective-C.  Even if this method returns `true`, A given\ninstance of `Self._ObjectiveCType` may, or may not, convert\nsuccessfully to `Self`; for example, an `NSArray` will only\nconvert successfully to `[String]` if it contains only\n`NSString`\\ s."},{"kind":"func","name":"_getObjectiveCType","slug":"_getObjectiveCType","generic":{},"params":[],"ret":{"line":"Any.Type","types":["Any","Type"]},"note":"class","attr":"","line":"class func _getObjectiveCType() -> Any.Type","comment":"Must return `_ObjectiveCType.self`."},{"kind":"func","name":"_bridgeToObjectiveC","slug":"_bridgeToObjectiveC","generic":{},"params":[],"ret":{"line":"_ObjectiveCType","types":["_ObjectiveCType"]},"note":"","attr":"","line":"func _bridgeToObjectiveC() -> _ObjectiveCType","comment":"Convert `self` to Objective-C"},{"kind":"func","name":"_forceBridgeFromObjectiveC","slug":"_forceBridgeFromObjectiveC","generic":{},"params":[{"name":"source","type":"_ObjectiveCType","note":"","default":"","types":["_ObjectiveCType"]},{"name":"result","type":"Self?","note":"inout","default":"","types":["Self"]}],"ret":{},"note":"class","attr":"","line":"class func _forceBridgeFromObjectiveC(source: _ObjectiveCType, inout result: Self?)","comment":"Bridge from an Objective-C object of the bridged class type to a\nvalue of the Self type.\n\nThis bridging operation is used for forced downcasting (e.g.,\nvia as), and may defer complete checking until later. For\nexample, when bridging from NSArray to Array<T>, we can defer\nthe checking for the individual elements of the array.\n\n:param: result The location where the result is written. The optional\nwill always contain a value."},{"kind":"func","name":"_conditionallyBridgeFromObjectiveC","slug":"_conditionallyBridgeFromObjectiveC","generic":{},"params":[{"name":"source","type":"_ObjectiveCType","note":"","default":"","types":["_ObjectiveCType"]},{"name":"result","type":"Self?","note":"inout","default":"","types":["Self"]}],"ret":{"line":"Bool","types":["Bool"]},"note":"class","attr":"","line":"class func _conditionallyBridgeFromObjectiveC(source: _ObjectiveCType, inout result: Self?) -> Bool","comment":"Try to bridge from an Objective-C object of the bridged class\ntype to a value of the Self type.\n\nThis conditional bridging operation is used for conditional\ndowncasting (e.g., via as?) and therefore must perform a\ncomplete conversion to the value type; it cannot defer checking\nto a later time.\n\n:param: result The location where the result is written.\n\n:returns: true if bridging succeeded, false otherwise. This redundant\ninformation is provided for the convenience of the runtime's dynamic_cast\nimplementation, so that it need not look into the optional representation\nto determine success."}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"_ObjectiveCType","type":"","proto":"","comment":""}],"inits":[],"subscripts":[],"comment":"A Swift Array or Dictionary of types conforming to\n`_ObjectiveCBridgeable` can be passed to ObjectiveC as an NSArray or\nNSDictionary, respectively.  The elements of the resulting NSArray\nor NSDictionary will be the result of calling `_bridgeToObjectiveC`\non each elmeent of the source container."},"_RandomAccessIndexType":{"kind":"protocol","name":"_RandomAccessIndexType","slug":"_RandomAccessIndexType","inherits":["_BidirectionalIndexType","Strideable"],"inherited":["RandomAccessIndexType"],"attr":"","operators":[],"functions":[{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self.Distance","types":["Distance","Self"]},"note":"","attr":"","line":"func distanceTo(other: Self) -> Self.Distance","comment":"Return the minimum number of applications of `successor` or\n`predecessor` required to reach `other` from `self`.\n\nComplexity: O(1).\n\nAxioms::\n\n  x.distanceTo(x.successor())) == 1\n  x.distanceTo(x.predecessor())) == -1\n  x.advancedBy(x.distanceTo(y)) == y"},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"n","type":"Self.Distance","note":"","default":"","types":["Distance","Self"]}],"ret":{"line":"Self","types":["Self"]},"note":"","attr":"","line":"func advancedBy(n: Self.Distance) -> Self","comment":"Return `self` offset by `n` steps.\n\n:returns: If `n > 0`, the result of applying `successor` to\n`self` `n` times.  If `n < 0`, the result of applying\n`predecessor` to `self` `-n` times. Otherwise, `self`.\n\nComplexity: O(1)\n\nAxioms::\n\n  x.advancedBy(0) == x\n  x.advancedBy(1) == x.successor()\n  x.advancedBy(-1) == x.predecessor()\n  x.distanceTo(x.advancedBy(m)) == m"}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `RandomAccessIndexType`; do\nnot use it directly.\n\nIts requirements are inherited by `RandomAccessIndexType` and thus must\nbe satisfied by types conforming to that protocol."},"_RawOptionSetType":{"kind":"protocol","name":"_RawOptionSetType","slug":"_RawOptionSetType","inherits":["RawRepresentable","Equatable"],"inherited":["RawOptionSetType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"RawValue","type":"","proto":"BitwiseOperationsType, Equatable","comment":""}],"inits":[{"kind":"init","generic":{},"params":[{"name":"rawValue","type":"RawValue","note":"","default":"","types":["RawValue"]}],"init":"init","note":"","comment":""}],"subscripts":[],"comment":"This protocol is an implementation detail of `RawOptionSetType`; do\nnot use it directly.\n\nIts requirements are inherited by `RawOptionSetType` and thus must\nbe satisfied by types conforming to that protocol."},"_SequenceType":{"kind":"protocol","name":"_SequenceType","slug":"_SequenceType","inherits":[],"inherited":["_CollectionType","_Sequence_Type"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `SequenceType`; do\nnot use it directly.\n\nIts requirements are inherited by `SequenceType` and thus must\nbe satisfied by types conforming to that protocol."},"_Sequence_Type":{"kind":"protocol","name":"_Sequence_Type","slug":"_Sequence_Type","inherits":["_SequenceType"],"inherited":["SequenceType"],"attr":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"Generator","types":["Generator"]},"note":"","attr":"","line":"func generate() -> Generator","comment":"Return a *generator* over the elements of this *sequence*.  The\n*generator*\\ 's next element is the first element of the\nsequence.\n\nComplexity: O(1)"}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Generator","type":"","proto":"GeneratorType","comment":"A type whose instances can produce the elements of this\nsequence, in order."}],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `SequenceType`; do\nnot use it directly.\n\nIts requirements are inherited by `SequenceType` and thus must\nbe satisfied by types conforming to that protocol."},"_SignedIntegerType":{"kind":"protocol","name":"_SignedIntegerType","slug":"_SignedIntegerType","inherits":["_IntegerType","SignedNumberType"],"inherited":["SignedIntegerType"],"attr":"","operators":[],"functions":[{"kind":"func","name":"toIntMax","slug":"toIntMax","generic":{},"params":[],"ret":{"line":"IntMax","types":["IntMax"]},"note":"","attr":"","line":"func toIntMax() -> IntMax","comment":"Represent this number using Swift's widest native signed integer\ntype."}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"_","type":"IntMax","note":"","default":"","types":["IntMax"]}],"init":"init","note":"","comment":"Convert from Swift's widest signed integer type, trapping on\noverflow."}],"subscripts":[],"comment":"This protocol is an implementation detail of `SignedIntegerType`;\ndo not use it directly.\n\nIts requirements are inherited by `SignedIntegerType` and thus\nmust be satisfied by types conforming to that protocol."},"_SignedNumberType":{"kind":"protocol","name":"_SignedNumberType","slug":"_SignedNumberType","inherits":["Comparable","IntegerLiteralConvertible"],"inherited":["SignedNumberType"],"attr":"","operators":[],"functions":[{"kind":"operator func","name":"-","slug":"mns","generic":{},"place":"","params":[{"name":"lhs","type":"Self","note":"","default":"","types":["Self"]},{"name":"rhs","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Self","types":["Self"]},"attr":"","line":"func -(lhs: Self, rhs: Self) -> Self","comment":"Return the difference between `lhs` and `rhs`."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `SignedNumberType`; do\nnot use it directly.\n\nIts requirements are inherited by `SignedNumberType` and thus must\nbe satisfied by types conforming to that protocol."},"_Sliceable":{"kind":"protocol","name":"_Sliceable","slug":"_Sliceable","inherits":["CollectionType"],"inherited":["Sliceable"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `Sliceable`; do\nnot use it directly.\n\nIts requirements are inherited by `Sliceable` and thus must\nbe satisfied by types conforming to that protocol."},"_Strideable":{"kind":"protocol","name":"_Strideable","slug":"_Strideable","inherits":[],"inherited":["Strideable"],"attr":"","operators":[],"functions":[{"kind":"func","name":"distanceTo","slug":"distanceTo","generic":{},"params":[{"name":"other","type":"Self","note":"","default":"","types":["Self"]}],"ret":{"line":"Stride","types":["Stride"]},"note":"","attr":"","line":"func distanceTo(other: Self) -> Stride","comment":"Returns a stride `x` such that `self.advancedBy(x)` approximates\n`other`.\n\nComplexity: O(1).\n\nSee also: `RandomAccessIndexType`\\ 's `distanceTo`, which provides a\nstronger semantic guarantee."},{"kind":"func","name":"advancedBy","slug":"advancedBy","generic":{},"params":[{"name":"n","type":"Stride","note":"","default":"","types":["Stride"]}],"ret":{"line":"Self","types":["Self"]},"note":"","attr":"","line":"func advancedBy(n: Stride) -> Self","comment":"Returns a `Self` `x` such that `self.distanceTo(x)` approximates\n`n`.\n\nComplexity: O(1).\n\nSee also: `RandomAccessIndexType`\\ 's `advancedBy`, which\nprovides a stronger semantic guarantee."}],"types":[],"properties":[],"aliases":[{"kind":"typealias","name":"Stride","type":"","proto":"SignedNumberType","comment":"A type that can represent the distance between two values of `Self`"}],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `Strideable`; do\nnot use it directly.\n\nIts requirements are inherited by `Strideable` and thus must\nbe satisfied by types conforming to that protocol."},"_SwiftNSArrayRequiredOverridesType":{"kind":"protocol","name":"_SwiftNSArrayRequiredOverridesType","slug":"_SwiftNSArrayRequiredOverridesType","inherits":["_SwiftNSCopyingType","_SwiftNSFastEnumerationType"],"inherited":["_SwiftNSArrayType"],"attr":"@unsafe_no_objc_tagged_pointer @objc ","operators":[],"functions":[{"kind":"func","name":"objectAtIndex","slug":"objectAtIndex","generic":{},"params":[{"name":"index","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"AnyObject","types":["AnyObject"]},"note":"","attr":"","line":"func objectAtIndex(index: Int) -> AnyObject","comment":""},{"kind":"func","name":"getObjects","slug":"getObjects","generic":{},"params":[{"name":"_","type":"UnsafeMutablePointer<AnyObject>","note":"","default":"","types":["AnyObject","UnsafeMutablePointer"]},{"name":"range","type":"_SwiftNSRange","note":"","default":"","types":["_SwiftNSRange"]}],"ret":{},"note":"","attr":"","line":"func getObjects(_: UnsafeMutablePointer<AnyObject>, range: _SwiftNSRange)","comment":""},{"kind":"func","name":"countByEnumeratingWithState","slug":"countByEnumeratingWithState","generic":{},"params":[{"name":"state","type":"UnsafeMutablePointer<_SwiftNSFastEnumerationState>","note":"","default":"","types":["UnsafeMutablePointer","_SwiftNSFastEnumerationState"]},{"name":"objects","type":"UnsafeMutablePointer<AnyObject>","note":"","default":"","types":["AnyObject","UnsafeMutablePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func countByEnumeratingWithState(state: UnsafeMutablePointer<_SwiftNSFastEnumerationState>, objects: UnsafeMutablePointer<AnyObject>, count: Int) -> Int","comment":""},{"kind":"func","name":"copyWithZone","slug":"copyWithZone","generic":{},"params":[{"name":"zone","type":"_SwiftNSZone","note":"","default":"","types":["_SwiftNSZone"]}],"ret":{"line":"AnyObject","types":["AnyObject"]},"note":"","attr":"","line":"func copyWithZone(zone: _SwiftNSZone) -> AnyObject","comment":""}],"types":[],"properties":[{"kind":"var","name":"count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":""}],"aliases":[],"inits":[],"subscripts":[],"comment":""},"_SwiftNSArrayType":{"kind":"protocol","name":"_SwiftNSArrayType","slug":"_SwiftNSArrayType","inherits":["_SwiftNSArrayRequiredOverridesType"],"inherited":[],"attr":"@unsafe_no_objc_tagged_pointer @objc ","operators":[],"functions":[{"kind":"func","name":"indexOfObject","slug":"indexOfObject","generic":{},"params":[{"name":"anObject","type":"AnyObject","note":"","default":"","types":["AnyObject"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func indexOfObject(anObject: AnyObject) -> Int","comment":""}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":""},"_SwiftNSCopyingType":{"kind":"protocol","name":"_SwiftNSCopyingType","slug":"_SwiftNSCopyingType","inherits":[],"inherited":["_SwiftNSArrayRequiredOverridesType","_SwiftNSDictionaryRequiredOverridesType","_SwiftNSStringRequiredOverridesType"],"attr":"@objc ","operators":[],"functions":[{"kind":"func","name":"copyWithZone","slug":"copyWithZone","generic":{},"params":[{"name":"zone","type":"_SwiftNSZone","note":"","default":"","types":["_SwiftNSZone"]}],"ret":{"line":"AnyObject","types":["AnyObject"]},"note":"","attr":"","line":"func copyWithZone(zone: _SwiftNSZone) -> AnyObject","comment":""}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":""},"_SwiftNSDictionaryRequiredOverridesType":{"kind":"protocol","name":"_SwiftNSDictionaryRequiredOverridesType","slug":"_SwiftNSDictionaryRequiredOverridesType","inherits":["_SwiftNSCopyingType","_SwiftNSFastEnumerationType"],"inherited":["_SwiftNSDictionaryType"],"attr":"@objc ","operators":[],"functions":[{"kind":"func","name":"objectForKey","slug":"objectForKey","generic":{},"params":[{"name":"aKey","type":"AnyObject?","note":"","default":"","types":["AnyObject"]}],"ret":{"line":"AnyObject?","types":["AnyObject"]},"note":"","attr":"","line":"func objectForKey(aKey: AnyObject?) -> AnyObject?","comment":""},{"kind":"func","name":"keyEnumerator","slug":"keyEnumerator","generic":{},"params":[],"ret":{"line":"_SwiftNSEnumeratorType?","types":["_SwiftNSEnumeratorType"]},"note":"","attr":"","line":"func keyEnumerator() -> _SwiftNSEnumeratorType?","comment":""},{"kind":"func","name":"copyWithZone","slug":"copyWithZone","generic":{},"params":[{"name":"zone","type":"_SwiftNSZone","note":"","default":"","types":["_SwiftNSZone"]}],"ret":{"line":"AnyObject","types":["AnyObject"]},"note":"","attr":"","line":"func copyWithZone(zone: _SwiftNSZone) -> AnyObject","comment":""},{"kind":"func","name":"countByEnumeratingWithState","slug":"countByEnumeratingWithState","generic":{},"params":[{"name":"state","type":"UnsafeMutablePointer<_SwiftNSFastEnumerationState>","note":"","default":"","types":["UnsafeMutablePointer","_SwiftNSFastEnumerationState"]},{"name":"objects","type":"UnsafeMutablePointer<AnyObject>","note":"","default":"","types":["AnyObject","UnsafeMutablePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func countByEnumeratingWithState(state: UnsafeMutablePointer<_SwiftNSFastEnumerationState>, objects: UnsafeMutablePointer<AnyObject>, count: Int) -> Int","comment":""}],"types":[],"properties":[{"kind":"var","name":"count","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":""}],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"objects","type":"UnsafePointer<AnyObject?>","note":"","default":"","types":["AnyObject","UnsafePointer"]},{"name":"forKeys","type":"UnsafePointer<Void>","note":"","default":"","types":["UnsafePointer","Void"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"init":"init","note":"","comment":""}],"subscripts":[],"comment":""},"_SwiftNSDictionaryType":{"kind":"protocol","name":"_SwiftNSDictionaryType","slug":"_SwiftNSDictionaryType","inherits":["_SwiftNSDictionaryRequiredOverridesType"],"inherited":[],"attr":"@unsafe_no_objc_tagged_pointer @objc ","operators":[],"functions":[{"kind":"func","name":"getObjects","slug":"getObjects","generic":{},"params":[{"name":"objects","type":"UnsafeMutablePointer<AnyObject>","note":"","default":"","types":["AnyObject","UnsafeMutablePointer"]},{"name":"keys","type":"UnsafeMutablePointer<AnyObject>","note":"andKeys","default":"","types":["AnyObject","UnsafeMutablePointer"]}],"ret":{},"note":"","attr":"","line":"func getObjects(objects: UnsafeMutablePointer<AnyObject>, andKeys keys: UnsafeMutablePointer<AnyObject>)","comment":""}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":""},"_SwiftNSEnumeratorType":{"kind":"protocol","name":"_SwiftNSEnumeratorType","slug":"_SwiftNSEnumeratorType","inherits":[],"inherited":[],"attr":"@objc ","operators":[],"functions":[{"kind":"func","name":"nextObject","slug":"nextObject","generic":{},"params":[],"ret":{"line":"AnyObject?","types":["AnyObject"]},"note":"","attr":"","line":"func nextObject() -> AnyObject?","comment":""}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[],"init":"init","note":"","comment":""}],"subscripts":[],"comment":""},"_SwiftNSFastEnumerationType":{"kind":"protocol","name":"_SwiftNSFastEnumerationType","slug":"_SwiftNSFastEnumerationType","inherits":[],"inherited":["_SwiftNSArrayRequiredOverridesType","_SwiftNSDictionaryRequiredOverridesType","_SwiftNSStringRequiredOverridesType"],"attr":"@objc ","operators":[],"functions":[{"kind":"func","name":"countByEnumeratingWithState","slug":"countByEnumeratingWithState","generic":{},"params":[{"name":"state","type":"UnsafeMutablePointer<_SwiftNSFastEnumerationState>","note":"","default":"","types":["UnsafeMutablePointer","_SwiftNSFastEnumerationState"]},{"name":"objects","type":"UnsafeMutablePointer<AnyObject>","note":"","default":"","types":["AnyObject","UnsafeMutablePointer"]},{"name":"count","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func countByEnumeratingWithState(state: UnsafeMutablePointer<_SwiftNSFastEnumerationState>, objects: UnsafeMutablePointer<AnyObject>, count: Int) -> Int","comment":""}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":""},"_SwiftNSStringRequiredOverridesType":{"kind":"protocol","name":"_SwiftNSStringRequiredOverridesType","slug":"_SwiftNSStringRequiredOverridesType","inherits":["_SwiftNSCopyingType","_SwiftNSFastEnumerationType"],"inherited":["_SwiftNSStringType"],"attr":"@objc ","operators":[],"functions":[{"kind":"func","name":"length","slug":"length","generic":{},"params":[],"ret":{"line":"Int","types":["Int"]},"note":"","attr":"","line":"func length() -> Int","comment":""},{"kind":"func","name":"characterAtIndex","slug":"characterAtIndex","generic":{},"params":[{"name":"index","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"UInt16","types":["UInt16"]},"note":"","attr":"","line":"func characterAtIndex(index: Int) -> UInt16","comment":""}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":""},"_SwiftNSStringType":{"kind":"protocol","name":"_SwiftNSStringType","slug":"_SwiftNSStringType","inherits":["_SwiftNSStringRequiredOverridesType"],"inherited":[],"attr":"@objc ","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":""},"_UnsignedIntegerType":{"kind":"protocol","name":"_UnsignedIntegerType","slug":"_UnsignedIntegerType","inherits":["_IntegerType"],"inherited":["UnsignedIntegerType"],"attr":"","operators":[],"functions":[{"kind":"func","name":"toUIntMax","slug":"toUIntMax","generic":{},"params":[],"ret":{"line":"UIntMax","types":["UIntMax"]},"note":"","attr":"","line":"func toUIntMax() -> UIntMax","comment":"Represent this number using Swift's widest native unsigned\ninteger type."}],"types":[],"properties":[],"aliases":[],"inits":[{"kind":"init","generic":{},"params":[{"name":"_","type":"UIntMax","note":"","default":"","types":["UIntMax"]}],"init":"init","note":"","comment":"Convert from Swift's widest unsigned integer type, trapping on\noverflow."}],"subscripts":[],"comment":"This protocol is an implementation detail of `SignedIntegerType`;\ndo not use it directly.\n\nIts requirements are inherited by `SignedIntegerType` and thus\nmust be satisfied by types conforming to that protocol."},"_ArrayType":{"kind":"protocol","name":"_ArrayType","slug":"_ArrayType","inherits":["CollectionType"],"inherited":["ArrayType"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `Array` and `Slice`. It is *internal* to the Swift standard library and is included here only to link `Array` and `Slice` to other protocols."},"ArrayType":{"kind":"protocol","name":"ArrayType","slug":"ArrayType","inherits":["_ArrayType","RangeReplaceableCollectionType","MutableSliceable","ArrayLiteralConvertible"],"inherited":["Array","ContiguousArray","Slice"],"attr":"","operators":[],"functions":[],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"This protocol is an implementation detail of `Array` and `Slice`. It is *internal* to the Swift standard library and is included here only to link `Array` and `Slice` to other protocols."},"String.Index":{"kind":"struct","name":"String.Index","slug":"Index","inherits":["BidirectionalIndexType","Comparable","Reflectable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"String.Index","types":["Index","String"]},"note":"","attr":"","line":"func successor() -> String.Index","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"String.Index","types":["Index","String"]},"note":"","attr":"","line":"func predecessor() -> String.Index","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A character position in a `String`"},"String.UTF8View":{"kind":"struct","name":"String.UTF8View","slug":"UTF8View","inherits":["CollectionType","Reflectable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"IndexingGenerator<String.UTF8View>","types":["IndexingGenerator","String","UTF8View"]},"note":"","attr":"","line":"func generate() -> IndexingGenerator<String.UTF8View>","comment":"Return a *generator* over the code points that comprise this\n*sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":["String.UTF8View.Index"],"properties":[{"kind":"var","name":"startIndex","type":"String.UTF8View.Index","readonly":true,"stat":"","subtypes":["Index","String","UTF8View"],"comment":"The position of the first code unit if the `String` is\nnon-empty; identical to `endIndex` otherwise."},{"kind":"var","name":"endIndex","type":"String.UTF8View.Index","readonly":true,"stat":"","subtypes":["Index","String","UTF8View"],"comment":"The \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."}],"aliases":[],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"String.UTF8View.Index","note":"","default":"","types":["Index","String","UTF8View"]}],"ret":{"line":"CodeUnit { get }","types":["CodeUnit"]},"comment":""}],"comment":"A collection of UTF-8 code units that encodes a `String` value."},"String.UnicodeScalarView":{"kind":"struct","name":"String.UnicodeScalarView","slug":"UnicodeScalarView","inherits":["Sliceable","SequenceType","Reflectable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"String.UnicodeScalarView.Generator","types":["Generator","String","UnicodeScalarView"]},"note":"","attr":"","line":"func generate() -> String.UnicodeScalarView.Generator","comment":"Return a *generator* over the `UnicodeScalar`\\ s that comprise\nthis *sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":["String.UnicodeScalarView.Index","String.UnicodeScalarView.Generator"],"properties":[{"kind":"var","name":"startIndex","type":"String.UnicodeScalarView.Index","readonly":true,"stat":"","subtypes":["Index","String","UnicodeScalarView"],"comment":"The position of the first `UnicodeScalar` if the `String` is\nnon-empty; identical to `endIndex` otherwise."},{"kind":"var","name":"endIndex","type":"String.UnicodeScalarView.Index","readonly":true,"stat":"","subtypes":["Index","String","UnicodeScalarView"],"comment":"The \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."}],"aliases":[],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"String.UnicodeScalarView.Index","note":"","default":"","types":["Index","String","UnicodeScalarView"]}],"ret":{"line":"UnicodeScalar { get }","types":["UnicodeScalar"]},"comment":""},{"kind":"subscript","params":[{"name":"r","type":"Range<String.UnicodeScalarView.Index>","note":"","default":"","types":["Index","Range","String","UnicodeScalarView"]}],"ret":{"line":"String.UnicodeScalarView { get }","types":["String","UnicodeScalarView"]},"comment":""}],"comment":"A collection of Unicode scalar values that\nencode a `String` ."},"String.UTF16View":{"kind":"struct","name":"String.UTF16View","slug":"UTF16View","inherits":["Sliceable","Reflectable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"generate","slug":"generate","generic":{},"params":[],"ret":{"line":"Generator","types":["Generator"]},"note":"","attr":"","line":"func generate() -> Generator","comment":"Return a *generator* over the code points that comprise this\n*sequence*.\n\nComplexity: O(1)"},{"kind":"func","name":"getMirror","slug":"getMirror","generic":{},"params":[],"ret":{"line":"MirrorType","types":["MirrorType"]},"note":"","attr":"","line":"func getMirror() -> MirrorType","comment":"Returns a mirror that reflects `self`."}],"types":[],"properties":[{"kind":"var","name":"startIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The position of the first code unit if the `String` is\nnon-empty; identical to `endIndex` otherwise."},{"kind":"var","name":"endIndex","type":"Int","readonly":true,"stat":"","subtypes":["Int"],"comment":"The \"past the end\" position.\n\n`endIndex` is not a valid argument to `subscript`, and is always\nreachable from `startIndex` by zero or more applications of\n`successor()`."}],"aliases":[{"kind":"typealias","name":"Generator","type":"","proto":"","comment":"A type whose instances can produce the elements of this\nsequence, in order."}],"inits":[],"subscripts":[{"kind":"subscript","params":[{"name":"position","type":"Int","note":"","default":"","types":["Int"]}],"ret":{"line":"UInt16 { get }","types":["UInt16"]},"comment":""},{"kind":"subscript","params":[{"name":"subRange","type":"Range<Int>","note":"","default":"","types":["Int","Range"]}],"ret":{"line":"String.UTF16View { get }","types":["String","UTF16View"]},"comment":""}],"comment":"A collection of UTF-16 code units that encodes a `String` value."},"String.UTF8View.Index":{"kind":"struct","name":"String.UTF8View.Index","slug":"Index","inherits":["ForwardIndexType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"String.UTF8View.Index","types":["Index","String","UTF8View"]},"note":"","attr":"","line":"func successor() -> String.UTF8View.Index","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A position in a `String.UTF8View`"},"String.UnicodeScalarView.Index":{"kind":"struct","name":"String.UnicodeScalarView.Index","slug":"Index","inherits":["BidirectionalIndexType","Comparable"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"successor","slug":"successor","generic":{},"params":[],"ret":{"line":"String.UnicodeScalarView.Index","types":["Index","String","UnicodeScalarView"]},"note":"","attr":"","line":"func successor() -> String.UnicodeScalarView.Index","comment":"Returns the next consecutive value after `self`.\n\nRequires: the next value is representable."},{"kind":"func","name":"predecessor","slug":"predecessor","generic":{},"params":[],"ret":{"line":"String.UnicodeScalarView.Index","types":["Index","String","UnicodeScalarView"]},"note":"","attr":"","line":"func predecessor() -> String.UnicodeScalarView.Index","comment":"Returns the previous consecutive value before `self`.\n\nRequires: the previous value is representable."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A position in a `String.UnicodeScalarView`"},"String.UnicodeScalarView.Generator":{"kind":"struct","name":"String.UnicodeScalarView.Generator","slug":"Generator","inherits":["GeneratorType"],"inherited":[],"generic":{},"attr":"","note":"","operators":[],"functions":[{"kind":"func","name":"next","slug":"next","generic":{},"params":[],"ret":{"line":"UnicodeScalar?","types":["UnicodeScalar"]},"note":"mutating","attr":"","line":"mutating func next() -> UnicodeScalar?","comment":"Advance to the next element and return it, or `nil` if no next\nelement exists.\n\nRequires: no preceding call to `self.next()` has returned\n`nil`."}],"types":[],"properties":[],"aliases":[],"inits":[],"subscripts":[],"comment":"A type whose instances can produce the elements of this\nsequence, in order."}}}
